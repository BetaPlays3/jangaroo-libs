<?xml version="1.0" encoding="UTF-8"?>
<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="http://extjs.com/ext3" xmlns:ext="http://extjs.com/ext3" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:complexType name='ext.data.ArrayStore'>
    <xs:complexContent>
      <xs:extension base='ext:ext.data.Store'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='arraystore' name='arraystore' type='ext:ext.data.ArrayStore' substitutionGroup='ext:store'>
    <xs:annotation>
      <xs:documentation>
<p>Formerly known as "SimpleStore".</p><p>Small helper class to make creating {@link Ext.data.Store}s from Array data easier. An ArrayStore will be automatically configured with a {@link Ext.data.ArrayReader}.</p><p>A store configuration would be something like:</p><pre><code>var store = new Ext.data.ArrayStore({
// store configs
autoDestroy: true,
storeId: 'myStore',
// reader configs
idIndex: 0,  
fields: [
'company',
{name: 'price', type: 'float'},
{name: 'change', type: 'float'},
{name: 'pctChange', type: 'float'},
{name: 'lastChange', type: 'date', dateFormat: 'n/j h:ia'}
]
});
</code></pre><br/><br/> <p>This store is configured to consume a returned object of the form:</p><pre><code>var myData = [
['3m Co',71.72,0.02,0.03,'9/1 12:00am'],
['Alcoa Inc',29.01,0.42,1.47,'9/1 12:00am'],
['Boeing Co.',75.43,0.53,0.71,'9/1 12:00am'],
['Hewlett-Packard Co.',36.53,-0.03,-0.08,'9/1 12:00am'],
['Wal-Mart Stores, Inc.',45.45,0.73,1.63,'9/1 12:00am']
];
</code></pre>An object literal of this form could also be used as the {@link #data} config option.<br/><br/> <p><b>*Note:</b> Although not listed here, this class accepts all of the configuration options of <b>{@link Ext.data.ArrayReader ArrayReader}</b>.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.chart.BarChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.CartesianChart'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='barchart' name='barchart' type='ext:ext.chart.BarChart' substitutionGroup='ext:cartesianchart'>
  </xs:element>
  <xs:complexType name='ext.grid.BooleanColumn'>
    <xs:complexContent>
      <xs:extension base='ext:ext.grid.Column'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:string' name='trueText'>
          <xs:annotation>
            <xs:documentation>
The string returned by the renderer when the column value is not falsey (defaults to <tt>'true'</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='falseText'>
          <xs:annotation>
            <xs:documentation>
The string returned by the renderer when the column value is falsey (but not undefined) (defaults to <tt>'false'</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='undefinedText'>
          <xs:annotation>
            <xs:documentation>
The string returned by the renderer when the column value is undefined (defaults to <tt>'Â '</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='booleancolumn' name='booleancolumn' type='ext:ext.grid.BooleanColumn' substitutionGroup='ext:gridcolumn'>
    <xs:annotation>
      <xs:documentation>
<p>A Column definition class which renders boolean data fields. See the {@link Ext.grid.Column#xtype xtype} config option of {@link Ext.grid.Column} for more details.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.BoxComponent'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Component'>
        <xs:sequence>
            <xs:element name='margins' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p><b>Note</b>: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the <b>{@link Ext.layout.BorderLayout BorderLayout}</b> or one of the two <b>{@link Ext.layout.BoxLayout BoxLayout} subclasses.</b></p><p>An object containing margins to apply to this BoxComponent in the format:</p><pre><code>{
top: (top margin),
right: (right margin),
bottom: (bottom margin),
left: (left margin)
}</code></pre><p>May also be a string containing space-separated, numeric margin values. The order of the sides associated with each value matches the way CSS processes margin values:</p><div class="mdetail-params"><ul><li>If there is only one value, it applies to all sides.</li><li>If there are two values, the top and bottom borders are set to the first value and the right and left are set to the second.</li><li>If there are three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the third.</li><li>If there are four values, they apply to the top, right, bottom, and left, respectively.</li></ul></div><br/><br/> <p>Defaults to:</p><pre><code>{top:0, right:0, bottom:0, left:0}
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='tabTip'>
          <xs:annotation>
            <xs:documentation>
<p><b>Note</b>: this config is only used when this BoxComponent is a child item of a TabPanel.</p>A string to be used as innerHTML (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element. {@link Ext.QuickTips}.init() must be called in order for the tips to render.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='region'>
          <xs:annotation>
            <xs:documentation>
<p><b>Note</b>: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the <b>{@link Ext.layout.BorderLayout BorderLayout}</b> layout manager (e.g. specifying <tt>layout:'border'</tt>).</p><br/><p>See {@link Ext.layout.BorderLayout} also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='margins'>
          <xs:annotation>
            <xs:documentation>
<p><b>Note</b>: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the <b>{@link Ext.layout.BorderLayout BorderLayout}</b> or one of the two <b>{@link Ext.layout.BoxLayout BoxLayout} subclasses.</b></p><p>An object containing margins to apply to this BoxComponent in the format:</p><pre><code>{
top: (top margin),
right: (right margin),
bottom: (bottom margin),
left: (left margin)
}</code></pre><p>May also be a string containing space-separated, numeric margin values. The order of the sides associated with each value matches the way CSS processes margin values:</p><div class="mdetail-params"><ul><li>If there is only one value, it applies to all sides.</li><li>If there are two values, the top and bottom borders are set to the first value and the right and left are set to the second.</li><li>If there are three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the third.</li><li>If there are four values, they apply to the top, right, bottom, and left, respectively.</li></ul></div><br/><br/> <p>Defaults to:</p><pre><code>{top:0, right:0, bottom:0, left:0}
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='align'>
          <xs:annotation>
            <xs:documentation>
<p><b>Note</b>: this config is only used when this BoxComponent is rendered by a Container which has been configured to use one of the two <b>{@link Ext.layout.BoxLayout BoxLayout} subclasses.</b></p>Controls how the child items of the container are aligned. Acceptable configuration values for this property are: For {@link Ext.layout.HBoxLayout HBoxLayout}: <div class="mdetail-params"><ul><li><b><tt>top</tt></b> : <b>Default</b><div class="sub-desc">child items are aligned vertically at the <b>left</b> side of the container</div></li><li><b><tt>middle</tt></b> : <div class="sub-desc">child items are aligned vertically at the <b>mid-height</b> of the container</div></li><li><b><tt>stretch</tt></b> : <div class="sub-desc">child items are stretched vertically to fill the height of the container</div></li><li><b><tt>stretchmax</tt></b> : <div class="sub-desc">child items are stretched vertically to the size of the largest item.</div></li></ul></div>For {@link Ext.layout.VBoxLayout VBoxLayout}: <div class="mdetail-params"><ul><li><b><tt>left</tt></b> : <b>Default</b><div class="sub-desc">child items are aligned horizontally at the <b>left</b> side of the container</div></li><li><b><tt>center</tt></b> : <div class="sub-desc">child items are aligned horizontally at the <b>mid-width</b> of the container</div></li><li><b><tt>stretch</tt></b> : <div class="sub-desc">child items are stretched horizontally to fill the width of the container</div></li><li><b><tt>stretchmax</tt></b> : <div class="sub-desc">child items are stretched horizontally to the size of the largest item.</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='pack'>
          <xs:annotation>
            <xs:documentation>
<p><b>Note</b>: this config is only used when this BoxComponent is rendered by a Container which has been configured to use one of the two <b>{@link Ext.layout.BoxLayout BoxLayout} subclasses.</b></p>Controls how the child items of the container are packed together. Acceptable configuration values for this property are: For {@link Ext.layout.HBoxLayout HBoxLayout}: <div class="mdetail-params"><ul><li><b><tt>start</tt></b> : <b>Default</b><div class="sub-desc">child items are packed together at <b>left</b> side of container</div></li><li><b><tt>center</tt></b> : <div class="sub-desc">child items are packed together at <b>mid-width</b> of container</div></li><li><b><tt>end</tt></b> : <div class="sub-desc">child items are packed together at <b>right</b> side of container</div></li></ul></div>For {@link Ext.layout.VBoxLayout VBoxLayout}: <div class="mdetail-params"><ul><li><b><tt>start</tt></b> : <b>Default</b><div class="sub-desc">child items are packed together at <b>top</b> side of container</div></li><li><b><tt>center</tt></b> : <div class="sub-desc">child items are packed together at <b>mid-height</b> of container</div></li><li><b><tt>end</tt></b> : <div class="sub-desc">child items are packed together at <b>bottom</b> side of container</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='flex'>
          <xs:annotation>
            <xs:documentation>
<p><b>Note</b>: this config is only used when this BoxComponent is rendered by a Container which has been configured to use one of the two <b>{@link Ext.layout.BoxLayout BoxLayout} subclasses.</b></p>This configuration option is to be applied to <b>child <tt>items</tt></b> of the container managed by this layout. Each child item with a <tt>flex</tt> property will be flexed <b>horizontally</b> ({@link Ext.layout.HBoxLayout HBoxLayout}) or <b>vertically</b> ({@link Ext.layout.VBoxLayout VBoxLayout}) according to each item's <b>relative</b> <tt>flex</tt> value compared to the sum of all items with a <tt>flex</tt> value specified. Any child items that have either a <tt>flex = 0</tt> or <tt>flex = undefined</tt> will not be 'flexed' (the initial size will not be changed).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='x'>
          <xs:annotation>
            <xs:documentation>
The local x (left) coordinate for this component if contained within a positioning container.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='y'>
          <xs:annotation>
            <xs:documentation>
The local y (top) coordinate for this component if contained within a positioning container.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='pageX'>
          <xs:annotation>
            <xs:documentation>
The page level x coordinate for this component if contained within a positioning container.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='pageY'>
          <xs:annotation>
            <xs:documentation>
The page level y coordinate for this component if contained within a positioning container.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='height'>
          <xs:annotation>
            <xs:documentation>
The height of this component in pixels (defaults to auto). <b>Note</b> to express this dimension as a percentage or offset see {@link Ext.Component#anchor}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='width'>
          <xs:annotation>
            <xs:documentation>
The width of this component in pixels (defaults to auto). <b>Note</b> to express this dimension as a percentage or offset see {@link Ext.Component#anchor}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoHeight'>
          <xs:annotation>
            <xs:documentation>
<p>True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's {@link Ext.Container#layout layout manager}. Defaults to false.</p><p><b>Note</b>: Although many components inherit this config option, not all will function as expected with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's contents, and that Ext will not manage it at all.</p><p>If the <i>browser</i> is managing the height, be aware that resizes performed by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the height might result in elements needing to be synchronized with the new height. Example:</p><pre><code>var w = new Ext.Window({
title: 'Window',
width: 600,
autoHeight: true,
items: {
title: 'Collapse Me',
height: 400,
collapsible: true,
border: false,
listeners: {
beforecollapse: function() {
w.el.shadow.hide();
},
beforeexpand: function() {
w.el.shadow.hide();
},
collapse: function() {
w.syncShadow();
},
expand: function() {
w.syncShadow();
}
}
}
}).show();
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoWidth'>
          <xs:annotation>
            <xs:documentation>
<p>True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's {@link Ext.Container#layout layout manager}. Defaults to false.</p><p><b>Note</b>: Although many components inherit this config option, not all will function as expected with a width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and that Ext will not manage it at all.</p><p>If the <i>browser</i> is managing the width, be aware that resizes performed by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might result in elements needing to be synchronized with the new width. For example, where the target element is:</p><pre><code>&lt;div id='grid-container' style='margin-left:25%;width:50%'&gt;&lt;/div&gt;
</code></pre>A Panel rendered into that target element must listen for browser window resize in order to relay its child items when the browser changes its width:<pre><code>var myPanel = new Ext.Panel({
renderTo: 'grid-container',
monitorResize: true, // relay on browser resize
title: 'Panel',
height: 400,
autoWidth: true,
layout: 'hbox',
layoutConfig: {
align: 'stretch'
},
defaults: {
flex: 1
},
items: [{
title: 'Box 1',
}, {
title: 'Box 2'
}, {
title: 'Box 3'
}],
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='box' name='box' type='ext:ext.BoxComponent' substitutionGroup='ext:component'>
    <xs:annotation>
      <xs:documentation>
<p>Base class for any {@link Ext.Component Component} that is to be sized as a box, using width and height.</p><p>BoxComponent provides automatic box model adjustments for sizing and positioning and will work correctly within the Component rendering model.</p><p>A BoxComponent may be created as a custom Component which encapsulates any HTML element, either a pre-existing element, or one that is created to your specifications at render time. Usually, to participate in layouts, a Component will need to be a <b>Box</b>Component in order to have its width and height managed.</p><p>To use a pre-existing element as a BoxComponent, configure it so that you preset the <b>el</b> property to the element to reference:</p><pre><code>var pageHeader = new Ext.BoxComponent({
el: 'my-header-div'
});</code></pre>This may then be {@link Ext.Container#add added} to a {@link Ext.Container Container} as a child item.<br/><br/> <p>To create a BoxComponent based around a HTML element to be created at render time, use the {@link Ext.Component#autoEl autoEl} config option which takes the form of a {@link Ext.DomHelper DomHelper} specification:</p><pre><code>var myImage = new Ext.BoxComponent({
autoEl: {
tag: 'img',
src: '/images/my-image.jpg'
}
});</code></pre><br/><br/>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Button'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
            <xs:element name='handler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A function called when the button is clicked (can be used instead of click event). The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>b</code> : Button<div class="sub-desc">This Button.</div></li><li><code>e</code> : EventObject<div class="sub-desc">The click event.</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='tooltip' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The tooltip for the button - can be a string to be used as innerHTML (html tags are accepted) or QuickTips config object
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='repeat' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    True to repeat fire the click event while the mouse is down. This can also be a {@link Ext.util.ClickRepeater ClickRepeater} config object (defaults to false).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='toggleHandler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Function called when a Button with {@link #enableToggle} set to true is clicked. Two arguments are passed:<ul class="mdetail-params"><li><b>button</b> : Ext.Button<div class="sub-desc">this Button object</div></li><li><b>state</b> : Boolean<div class="sub-desc">The next state if the Button, true means pressed.</div></li></ul>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='menu' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Standard menu attribute consisting of a reference to a menu object, a menu id or a menu config blob (defaults to undefined).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='scope' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> and <code>{@link #toggleHandler}</code> is executed. Defaults to this Button.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='template' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    (Optional) <p>A {@link Ext.Template Template} used to create the Button's DOM structure.</p>Instances, or subclasses which need a different DOM structure may provide a different template layout in conjunction with an implementation of {@link #getTemplateArgs}. @type Ext.Template @property template
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='text'>
          <xs:annotation>
            <xs:documentation>
The button text to be used as innerHTML (html tags are accepted)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='icon'>
          <xs:annotation>
            <xs:documentation>
The path to an image to display in the button (the image will be set as the background-image CSS property of the button by default, so if you want a mixed icon/text button, set cls:'x-btn-text-icon')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='handler'>
          <xs:annotation>
            <xs:documentation>
A function called when the button is clicked (can be used instead of click event). The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>b</code> : Button<div class="sub-desc">This Button.</div></li><li><code>e</code> : EventObject<div class="sub-desc">The click event.</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width for this button (used to give a set of buttons a common width). See also {@link Ext.Panel}.<tt>{@link Ext.Panel#minButtonWidth minButtonWidth}</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tooltip'>
          <xs:annotation>
            <xs:documentation>
The tooltip for the button - can be a string to be used as innerHTML (html tags are accepted) or QuickTips config object
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='pressed'>
          <xs:annotation>
            <xs:documentation>
True to start pressed (only if enableToggle = true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='toggleGroup'>
          <xs:annotation>
            <xs:documentation>
The group this toggle button is a member of (only 1 per group can be pressed)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='repeat'>
          <xs:annotation>
            <xs:documentation>
True to repeat fire the click event while the mouse is down. This can also be a {@link Ext.util.ClickRepeater ClickRepeater} config object (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='tabIndex'>
          <xs:annotation>
            <xs:documentation>
Set a DOM tabIndex for this button (defaults to undefined)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowDepress'>
          <xs:annotation>
            <xs:documentation>
False to not allow a pressed Button to be depressed (defaults to undefined). Only valid when {@link #enableToggle} is true.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableToggle'>
          <xs:annotation>
            <xs:documentation>
True to enable pressed/not pressed toggling (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='toggleHandler'>
          <xs:annotation>
            <xs:documentation>
Function called when a Button with {@link #enableToggle} set to true is clicked. Two arguments are passed:<ul class="mdetail-params"><li><b>button</b> : Ext.Button<div class="sub-desc">this Button object</div></li><li><b>state</b> : Boolean<div class="sub-desc">The next state if the Button, true means pressed.</div></li></ul>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='menu'>
          <xs:annotation>
            <xs:documentation>
Standard menu attribute consisting of a reference to a menu object, a menu id or a menu config blob (defaults to undefined).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='menuAlign'>
          <xs:annotation>
            <xs:documentation>
The position to align the menu to (see {@link Ext.Element#alignTo} for more details, defaults to 'tl-bl?').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='overflowText'>
          <xs:annotation>
            <xs:documentation>
If used in a {@link Ext.Toolbar Toolbar}, the text to be used if this item is shown in the overflow menu. See also {@link Ext.Toolbar.Item}.<code>{@link Ext.Toolbar.Item#overflowText overflowText}</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='iconCls'>
          <xs:annotation>
            <xs:documentation>
A css class which sets a background image to be used as the icon for this button
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='type'>
          <xs:annotation>
            <xs:documentation>
submit, reset or button - defaults to 'button'
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='clickEvent'>
          <xs:annotation>
            <xs:documentation>
The DOM event that will fire the handler of the button. This can be any valid event name (dblclick, contextmenu). Defaults to <tt>'click'</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='handleMouseEvents'>
          <xs:annotation>
            <xs:documentation>
False to disable visual cues on mouseover, mouseout and mousedown (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tooltipType'>
          <xs:annotation>
            <xs:documentation>
The type of tooltip to use. Either 'qtip' (default) for QuickTips or 'title' for title attribute.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='buttonSelector'>
          <xs:annotation>
            <xs:documentation>
<p>(Optional) A {@link Ext.DomQuery DomQuery} selector which is used to extract the active, clickable element from the DOM structure created.</p><p>When a custom {@link #template} is used, you must ensure that this selector results in the selection of a focussable element.</p><p>Defaults to <b><tt>'button:first-child'</tt></b>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scale'>
          <xs:annotation>
            <xs:documentation>
<p>(Optional) The size of the Button. Three values are allowed:</p><ul class="mdetail-params"><li>'small'<div class="sub-desc">Results in the button element being 16px high.</div></li><li>'medium'<div class="sub-desc">Results in the button element being 24px high.</div></li><li>'large'<div class="sub-desc">Results in the button element being 32px high.</div></li></ul><p>Defaults to <b><tt>'small'</tt></b>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scope'>
          <xs:annotation>
            <xs:documentation>
The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> and <code>{@link #toggleHandler}</code> is executed. Defaults to this Button.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='iconAlign'>
          <xs:annotation>
            <xs:documentation>
<p>(Optional) The side of the Button box to render the icon. Four values are allowed:</p><ul class="mdetail-params"><li>'top'</li><li>'right'</li><li>'bottom'</li><li>'left'</li></ul><p>Defaults to <b><tt>'left'</tt></b>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='arrowAlign'>
          <xs:annotation>
            <xs:documentation>
<p>(Optional) The side of the Button box to render the arrow if the button has an associated {@link #menu}. Two values are allowed:</p><ul class="mdetail-params"><li>'right'</li><li>'bottom'</li></ul><p>Defaults to <b><tt>'right'</tt></b>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='template'>
          <xs:annotation>
            <xs:documentation>
(Optional) <p>A {@link Ext.Template Template} used to create the Button's DOM structure.</p>Instances, or subclasses which need a different DOM structure may provide a different template layout in conjunction with an implementation of {@link #getTemplateArgs}. @type Ext.Template @property template
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='button' name='button' type='ext:ext.Button' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
Simple Button class
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.ButtonGroup'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:int' name='columns'>
          <xs:annotation>
            <xs:documentation>
The <tt>columns</tt> configuration property passed to the {@link #layout configured layout manager}. See {@link Ext.layout.TableLayout#columns}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='buttongroup' name='buttongroup' type='ext:ext.ButtonGroup' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>
Container for a group of buttons. Example usage: <pre><code>var p = new Ext.Panel({
title: 'Panel with Button Group',
width: 300,
height:200,
renderTo: document.body,
html: 'whatever',
tbar: [{
xtype: 'buttongroup',
{@link #columns}: 3,
title: 'Clipboard',
items: [{
text: 'Paste',
scale: 'large',
rowspan: 3, iconCls: 'add',
iconAlign: 'top',
cls: 'x-btn-as-arrow'
},{
xtype:'splitbutton',
text: 'Menu Button',
scale: 'large',
rowspan: 3,
iconCls: 'add',
iconAlign: 'top',
arrowAlign:'bottom',
menu: [{text: 'Menu Item 1'}]
},{
xtype:'splitbutton', text: 'Cut', iconCls: 'add16', menu: [{text: 'Cut Menu Item'}]
},{
text: 'Copy', iconCls: 'add16'
},{
text: 'Format', iconCls: 'add16'
}]
}]
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.chart.CartesianChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.Chart'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='cartesianchart' name='cartesianchart' type='ext:ext.chart.CartesianChart' substitutionGroup='ext:chart'>
  </xs:element>
  <xs:complexType name='ext.chart.Chart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.FlashComponent'>
        <xs:sequence>
            <xs:element name='chartStyle' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Sets styles for this chart. Contains a number of default values. Modifying this property will override the base styles on the chart.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='extraStyle' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Contains extra styles that will be added or overwritten to the default chartStyle. Defaults to <tt>null</tt>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='chartStyle'>
          <xs:annotation>
            <xs:documentation>
Sets styles for this chart. Contains a number of default values. Modifying this property will override the base styles on the chart.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='extraStyle'>
          <xs:annotation>
            <xs:documentation>
Contains extra styles that will be added or overwritten to the default chartStyle. Defaults to <tt>null</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='disableCaching'>
          <xs:annotation>
            <xs:documentation>
True to add a "cache buster" to the end of the chart url. Defaults to true for Opera and IE.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='chart' name='chart' type='ext:ext.chart.Chart' substitutionGroup='ext:flash'>
    <xs:annotation>
      <xs:documentation>
The Ext.chart package provides the capability to visualize data with flash based charting. Each chart binds directly to an Ext.data.Store enabling automatic updates of the chart.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.Checkbox'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Field'>
        <xs:sequence>
            <xs:element name='handler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A function called when the {@link #checked} value changes (can be used instead of handling the check event). The handler is passed the following parameters: <div class="mdetail-params"><ul><li><b>checkbox</b> : Ext.form.Checkbox<div class="sub-desc">The Checkbox being toggled.</div></li><li><b>checked</b> : Boolean<div class="sub-desc">The new checked state of the checkbox.</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='scope' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An object to use as the scope ('this' reference) of the {@link #handler} function (defaults to this Checkbox).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='checked'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> if the checkbox should render initially checked (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='boxLabel'>
          <xs:annotation>
            <xs:documentation>
The text that appears beside the checkbox
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='inputValue'>
          <xs:annotation>
            <xs:documentation>
The value that should go into the generated input element's value attribute
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='handler'>
          <xs:annotation>
            <xs:documentation>
A function called when the {@link #checked} value changes (can be used instead of handling the check event). The handler is passed the following parameters: <div class="mdetail-params"><ul><li><b>checkbox</b> : Ext.form.Checkbox<div class="sub-desc">The Checkbox being toggled.</div></li><li><b>checked</b> : Boolean<div class="sub-desc">The new checked state of the checkbox.</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scope'>
          <xs:annotation>
            <xs:documentation>
An object to use as the scope ('this' reference) of the {@link #handler} function (defaults to this Checkbox).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='checkbox' name='checkbox' type='ext:ext.form.Checkbox' substitutionGroup='ext:field'>
    <xs:annotation>
      <xs:documentation>
Single checkbox field. Can be used as a direct replacement for traditional checkbox fields.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.CheckboxGroup'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Field'>
        <xs:sequence>
            <xs:element name='items' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An Array of {@link Ext.form.Checkbox Checkbox}es or Checkbox config objects to arrange in the group.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='columns' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Specifies the number of columns to use when displaying grouped checkbox/radio controls using automatic layout. This config can take several types of values: <ul><li><b>'auto'</b> : <p class="sub-desc">The controls will be rendered one per column on one row and the width of each column will be evenly distributed based on the width of the overall field container. This is the default.</p></li><li><b>Number</b> : <p class="sub-desc">If you specific a number (e.g., 3) that number of columns will be created and the contained controls will be automatically distributed based on the value of {@link #vertical}.</p></li><li><b>Array</b> : Object<p class="sub-desc">You can also specify an array of column widths, mixing integer (fixed width) and float (percentage width) values as needed (e.g., [100, .25, .75]). Any integer values will be rendered first, then any float values will be calculated as a percentage of the remaining space. Float values do not have to add up to 1 (100%) although if you want the controls to take up the entire field container you should do so.</p></li></ul>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='items'>
          <xs:annotation>
            <xs:documentation>
An Array of {@link Ext.form.Checkbox Checkbox}es or Checkbox config objects to arrange in the group.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='columns'>
          <xs:annotation>
            <xs:documentation>
Specifies the number of columns to use when displaying grouped checkbox/radio controls using automatic layout. This config can take several types of values: <ul><li><b>'auto'</b> : <p class="sub-desc">The controls will be rendered one per column on one row and the width of each column will be evenly distributed based on the width of the overall field container. This is the default.</p></li><li><b>Number</b> : <p class="sub-desc">If you specific a number (e.g., 3) that number of columns will be created and the contained controls will be automatically distributed based on the value of {@link #vertical}.</p></li><li><b>Array</b> : Object<p class="sub-desc">You can also specify an array of column widths, mixing integer (fixed width) and float (percentage width) values as needed (e.g., [100, .25, .75]). Any integer values will be rendered first, then any float values will be calculated as a percentage of the remaining space. Float values do not have to add up to 1 (100%) although if you want the controls to take up the entire field container you should do so.</p></li></ul>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='vertical'>
          <xs:annotation>
            <xs:documentation>
True to distribute contained controls across columns, completely filling each column top to bottom before starting on the next column. The number of controls in each column will be automatically calculated to keep columns as even as possible. The default value is false, so that controls will be added to columns one at a time, completely filling each row left to right before starting on the next row.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowBlank'>
          <xs:annotation>
            <xs:documentation>
False to validate that at least one item in the group is checked (defaults to true). If no items are selected at validation time, {@link @blankText} will be used as the error text.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='blankText'>
          <xs:annotation>
            <xs:documentation>
Error text to display if the {@link #allowBlank} validation fails (defaults to "You must select at least one item in this group")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='checkboxgroup' name='checkboxgroup' type='ext:ext.form.CheckboxGroup' substitutionGroup='ext:field'>
    <xs:annotation>
      <xs:documentation>
<p>A grouping container for {@link Ext.form.Checkbox} controls.</p><p>Sample usage:</p><pre><code>var myCheckboxGroup = new Ext.form.CheckboxGroup({
id:'myGroup',
xtype: 'checkboxgroup',
fieldLabel: 'Single Column',
itemCls: 'x-check-group-alt',
// Put all controls in a single column with width 100%
columns: 1,
items: [
{boxLabel: 'Item 1', name: 'cb-col-1'},
{boxLabel: 'Item 2', name: 'cb-col-2', checked: true},
{boxLabel: 'Item 3', name: 'cb-col-3'}
]
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.ColorMenu'>
    <xs:complexContent>
      <xs:extension base='ext:ext.menu.Menu'>
        <xs:sequence>
            <xs:element name='handler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Optional. A function that will handle the select event of this menu. The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>palette</code> : ColorPalette<div class="sub-desc">The {@link #palette Ext.ColorPalette}.</div></li><li><code>color</code> : String<div class="sub-desc">The 6-digit color hex code (without the # symbol).</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='scope' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> function will be called. Defaults to this ColorMenu instance.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='handler'>
          <xs:annotation>
            <xs:documentation>
Optional. A function that will handle the select event of this menu. The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>palette</code> : ColorPalette<div class="sub-desc">The {@link #palette Ext.ColorPalette}.</div></li><li><code>color</code> : String<div class="sub-desc">The 6-digit color hex code (without the # symbol).</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scope'>
          <xs:annotation>
            <xs:documentation>
The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> function will be called. Defaults to this ColorMenu instance.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideOnClick'>
          <xs:annotation>
            <xs:documentation>
False to continue showing the menu after a color is selected, defaults to true.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='paletteId'>
          <xs:annotation>
            <xs:documentation>
An id to assign to the underlying color palette. Defaults to <tt>null</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='colormenu' name='colormenu' type='ext:ext.menu.ColorMenu' substitutionGroup='ext:menu'>
    <xs:annotation>
      <xs:documentation>
<p>A menu containing a {@link Ext.ColorPalette} Component.</p><p>Notes:</p><div class="mdetail-params"><ul><li>Although not listed here, the <b>constructor</b> for this class accepts all of the configuration options of <b>{@link Ext.ColorPalette}</b>.</li><li>If subclassing ColorMenu, any configuration options for the ColorPalette must be applied to the <tt><b>initialConfig</b></tt> property of the ColorMenu. Applying {@link Ext.ColorPalette ColorPalette} configuration settings to <b><tt>this</tt></b> will <b>not</b> affect the ColorPalette's configuration.</li></ul></div>*
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.ColorPalette'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Component'>
        <xs:sequence>
            <xs:element name='handler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Optional. A function that will handle the select event of this palette. The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>palette</code> : ColorPalette<div class="sub-desc">The {@link #palette Ext.ColorPalette}.</div></li><li><code>color</code> : String<div class="sub-desc">The 6-digit color hex code (without the # symbol).</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='scope' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> function will be called. Defaults to this ColorPalette instance.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='tpl'>
          <xs:annotation>
            <xs:documentation>
An existing XTemplate instance to be used in place of the default template for rendering the component.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='value'>
          <xs:annotation>
            <xs:documentation>
The initial color to highlight (should be a valid 6-digit color hex code without the # symbol). Note that the hex codes are case-sensitive.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowReselect'>
          <xs:annotation>
            <xs:documentation>
If set to true then reselecting a color that is already selected fires the {@link #select} event
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='handler'>
          <xs:annotation>
            <xs:documentation>
Optional. A function that will handle the select event of this palette. The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>palette</code> : ColorPalette<div class="sub-desc">The {@link #palette Ext.ColorPalette}.</div></li><li><code>color</code> : String<div class="sub-desc">The 6-digit color hex code (without the # symbol).</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scope'>
          <xs:annotation>
            <xs:documentation>
The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> function will be called. Defaults to this ColorPalette instance.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='colorpalette' name='colorpalette' type='ext:ext.ColorPalette' substitutionGroup='ext:component'>
    <xs:annotation>
      <xs:documentation>
Simple color palette class for choosing colors. The palette can be rendered to any container.<br/>Here's an example of typical usage: <pre><code>var cp = new Ext.ColorPalette({value:'993300'});  // initial selected color
cp.render('my-div');

cp.on('select', function(palette, selColor){
// do something with selColor
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.chart.ColumnChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.CartesianChart'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='columnchart' name='columnchart' type='ext:ext.chart.ColumnChart' substitutionGroup='ext:cartesianchart'>
  </xs:element>
  <xs:complexType name='ext.form.ComboBox'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.TriggerField'>
        <xs:sequence>
            <xs:element name='transform' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The id, DOM node or element of an existing HTML SELECT to convert to a ComboBox. Note that if you specify this and the combo is going to be in an {@link Ext.form.BasicForm} or {@link Ext.form.FormPanel}, you must also set <tt>{@link #lazyRender} = true</tt>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='store' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The data source to which this combo is bound (defaults to <tt>undefined</tt>). Acceptable values for this property are: <div class="mdetail-params"><ul><li><b>any {@link Ext.data.Store Store} subclass</b></li><li><b>an Array</b> : Arrays will be converted to a {@link Ext.data.ArrayStore} internally, automatically generating {@link Ext.data.Field#name field names} to work with all data components. <div class="mdetail-params"><ul><li><b>1-dimensional array</b> : (e.g., <tt>['Foo','Bar']</tt>)<div class="sub-desc">A 1-dimensional array will automatically be expanded (each array item will be used for both the combo {@link #valueField} and {@link #displayField})</div></li><li><b>2-dimensional array</b> : (e.g., <tt>[['f','Foo'],['b','Bar']]</tt>)<div class="sub-desc">For a multi-dimensional array, the value in index 0 of each item will be assumed to be the combo {@link #valueField}, while the value at index 1 is assumed to be the combo {@link #displayField}.</div></li></ul></div></li></ul></div><p>See also <tt>{@link #mode}</tt>.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='tpl' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>The template string, or {@link Ext.XTemplate} instance to use to display each item in the dropdown list. The dropdown list is displayed in a DataView. See {@link #view}.</p><p>The default template string is:</p><pre><code>'&lt;tpl for="."&gt;&lt;div class="x-combo-list-item"&gt;{' + this.displayField + '}&lt;/div&gt;&lt;/tpl&gt;'
</code></pre><p>Override the default value to create custom UI layouts for items in the list. For example:</p><pre><code>'&lt;tpl for="."&gt;&lt;div ext:qtip="{state}. {nick}" class="x-combo-list-item"&gt;{state}&lt;/div&gt;&lt;/tpl&gt;'
</code></pre><p>The template <b>must</b> contain one or more substitution parameters using field names from the Combo's {@link #store Store}. In the example above an</p><pre>ext:qtip</pre>attribute is added to display other fields from the Store.<br/><br/> <p>To preserve the default visual look of list items, add the CSS class name</p><pre>x-combo-list-item</pre>to the template's container element.<br/><br/> <p>Also see {@link #itemSelector} for additional details.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='transform'>
          <xs:annotation>
            <xs:documentation>
The id, DOM node or element of an existing HTML SELECT to convert to a ComboBox. Note that if you specify this and the combo is going to be in an {@link Ext.form.BasicForm} or {@link Ext.form.FormPanel}, you must also set <tt>{@link #lazyRender} = true</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='lazyRender'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to prevent the ComboBox from rendering until requested (should always be used when rendering into an {@link Ext.Editor} (e.g. {@link Ext.grid.EditorGridPanel Grids}), defaults to <tt>false</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='store'>
          <xs:annotation>
            <xs:documentation>
The data source to which this combo is bound (defaults to <tt>undefined</tt>). Acceptable values for this property are: <div class="mdetail-params"><ul><li><b>any {@link Ext.data.Store Store} subclass</b></li><li><b>an Array</b> : Arrays will be converted to a {@link Ext.data.ArrayStore} internally, automatically generating {@link Ext.data.Field#name field names} to work with all data components. <div class="mdetail-params"><ul><li><b>1-dimensional array</b> : (e.g., <tt>['Foo','Bar']</tt>)<div class="sub-desc">A 1-dimensional array will automatically be expanded (each array item will be used for both the combo {@link #valueField} and {@link #displayField})</div></li><li><b>2-dimensional array</b> : (e.g., <tt>[['f','Foo'],['b','Bar']]</tt>)<div class="sub-desc">For a multi-dimensional array, the value in index 0 of each item will be assumed to be the combo {@link #valueField}, while the value at index 1 is assumed to be the combo {@link #displayField}.</div></li></ul></div></li></ul></div><p>See also <tt>{@link #mode}</tt>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='title'>
          <xs:annotation>
            <xs:documentation>
If supplied, a header element is created containing this text and added into the top of the dropdown list (defaults to undefined, with no header element)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='listWidth'>
          <xs:annotation>
            <xs:documentation>
The width (used as a parameter to {@link Ext.Element#setWidth}) of the dropdown list (defaults to the width of the ComboBox field). See also <tt>{@link #minListWidth}</tt>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='displayField'>
          <xs:annotation>
            <xs:documentation>
The underlying {@link Ext.data.Field#name data field name} to bind to this ComboBox (defaults to undefined if <tt>{@link #mode} = 'remote'</tt> or <tt>'field1'</tt> if {@link #transform transforming a select} or if the {@link #store field name is autogenerated based on the store configuration}). <p>See also <tt>{@link #valueField}</tt>.</p><p><b>Note</b>: if using a ComboBox in an {@link Ext.grid.EditorGridPanel Editor Grid} a {@link Ext.grid.Column#renderer renderer} will be needed to show the displayField when the editor is not active.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='valueField'>
          <xs:annotation>
            <xs:documentation>
The underlying {@link Ext.data.Field#name data value name} to bind to this ComboBox (defaults to undefined if <tt>{@link #mode} = 'remote'</tt> or <tt>'field2'</tt> if {@link #transform transforming a select} or if the {@link #store field name is autogenerated based on the store configuration}). <p><b>Note</b>: use of a <tt>valueField</tt> requires the user to make a selection in order for a value to be mapped. See also <tt>{@link #hiddenName}</tt>, <tt>{@link #hiddenValue}</tt>, and <tt>{@link #displayField}</tt>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='hiddenName'>
          <xs:annotation>
            <xs:documentation>
If specified, a hidden form field with this name is dynamically generated to store the field's data value (defaults to the underlying DOM element's name). Required for the combo's value to automatically post during a form submission. See also {@link #valueField}. <p><b>Note</b>: the hidden field's id will also default to this name if {@link #hiddenId} is not specified. The ComboBox {@link Ext.Component#id id} and the <tt>{@link #hiddenId}</tt> <b>should be different</b>, since no two DOM nodes should share the same id. So, if the ComboBox <tt>{@link Ext.form.Field#name name}</tt> and <tt>hiddenName</tt> are the same, you should specify a unique <tt>{@link #hiddenId}</tt>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='hiddenId'>
          <xs:annotation>
            <xs:documentation>
If <tt>{@link #hiddenName}</tt> is specified, <tt>hiddenId</tt> can also be provided to give the hidden field a unique id (defaults to the <tt>{@link #hiddenName}</tt>). The <tt>hiddenId</tt> and combo {@link Ext.Component#id id} should be different, since no two DOM nodes should share the same id.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='hiddenValue'>
          <xs:annotation>
            <xs:documentation>
Sets the initial value of the hidden field if {@link #hiddenName} is specified to contain the selected {@link #valueField}, from the Store. Defaults to the configured <tt>{@link Ext.form.Field#value value}</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='listClass'>
          <xs:annotation>
            <xs:documentation>
The CSS class to add to the predefined <tt>'x-combo-list'</tt> class applied the dropdown list element (defaults to '').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='selectedClass'>
          <xs:annotation>
            <xs:documentation>
CSS class to apply to the selected item in the dropdown list (defaults to <tt>'x-combo-selected'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='listEmptyText'>
          <xs:annotation>
            <xs:documentation>
The empty text to display in the data view if no items are found. (defaults to '')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='shadow'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> or <tt>"sides"</tt> for the default effect, <tt>"frame"</tt> for 4-way shadow, and <tt>"drop"</tt> for bottom-right
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='listAlign'>
          <xs:annotation>
            <xs:documentation>
A valid anchor position value. See <tt>{@link Ext.Element#alignTo}</tt> for details on supported anchor positions (defaults to <tt>'tl-bl?'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxHeight'>
          <xs:annotation>
            <xs:documentation>
The maximum height in pixels of the dropdown list before scrollbars are shown (defaults to <tt>300</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minHeight'>
          <xs:annotation>
            <xs:documentation>
The minimum height in pixels of the dropdown list when the list is constrained by its distance to the viewport edges (defaults to <tt>90</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='triggerAction'>
          <xs:annotation>
            <xs:documentation>
The action to execute when the trigger is clicked. <div class="mdetail-params"><ul><li><b><tt>'query'</tt></b> : <b>Default</b> <p class="sub-desc">{@link #doQuery run the query} using the {@link Ext.form.Field#getRawValue raw value}.</p></li><li><b><tt>'all'</tt></b> : <p class="sub-desc">{@link #doQuery run the query} specified by the <tt>{@link #allQuery}</tt> config option</p></li></ul></div><p>See also <code>{@link #queryParam}</code>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minChars'>
          <xs:annotation>
            <xs:documentation>
The minimum number of characters the user must type before autocomplete and {@link #typeAhead} activate (defaults to <tt>4</tt> if <tt>{@link #mode} = 'remote'</tt> or <tt>0</tt> if <tt>{@link #mode} = 'local'</tt>, does not apply if <tt>{@link Ext.form.TriggerField#editable editable} = false</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='typeAhead'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to populate and autoselect the remainder of the text being typed after a configurable delay ({@link #typeAheadDelay}) if it matches a known value (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='queryDelay'>
          <xs:annotation>
            <xs:documentation>
The length of time in milliseconds to delay between the start of typing and sending the query to filter the dropdown list (defaults to <tt>500</tt> if <tt>{@link #mode} = 'remote'</tt> or <tt>10</tt> if <tt>{@link #mode} = 'local'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='pageSize'>
          <xs:annotation>
            <xs:documentation>
If greater than <tt>0</tt>, a {@link Ext.PagingToolbar} is displayed in the footer of the dropdown list and the {@link #doQuery filter queries} will execute with page start and {@link Ext.PagingToolbar#pageSize limit} parameters. Only applies when <tt>{@link #mode} = 'remote'</tt> (defaults to <tt>0</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='queryParam'>
          <xs:annotation>
            <xs:documentation>
Name of the query ({@link Ext.data.Store#baseParam baseParam} name for the store) as it will be passed on the querystring (defaults to <tt>'query'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='loadingText'>
          <xs:annotation>
            <xs:documentation>
The text to display in the dropdown list while data is loading. Only applies when <tt>{@link #mode} = 'remote'</tt> (defaults to <tt>'Loading...'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='resizable'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to add a resize handle to the bottom of the dropdown list (creates an {@link Ext.Resizable} with 'se' {@link Ext.Resizable#pinned pinned} handles). Defaults to <tt>false</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='handleHeight'>
          <xs:annotation>
            <xs:documentation>
The height in pixels of the dropdown list resize handle if <tt>{@link #resizable} = true</tt> (defaults to <tt>8</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='allQuery'>
          <xs:annotation>
            <xs:documentation>
The text query to send to the server to return all records for the list with no filtering (defaults to '')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='mode'>
          <xs:annotation>
            <xs:documentation>
Acceptable values are: <div class="mdetail-params"><ul><li><b><tt>'remote'</tt></b> : <b>Default</b> <p class="sub-desc">Automatically loads the <tt>{@link #store}</tt> the <b>first</b> time the trigger is clicked. If you do not want the store to be automatically loaded the first time the trigger is clicked, set to <tt>'local'</tt> and manually load the store. To force a requery of the store <b>every</b> time the trigger is clicked see <tt>{@link #lastQuery}</tt>.</p></li><li><b><tt>'local'</tt></b> : <p class="sub-desc">ComboBox loads local data</p><pre><code>var combo = new Ext.form.ComboBox({
renderTo: document.body,
mode: 'local',
store: new Ext.data.ArrayStore({
id: 0,
fields: [
'myId',  // numeric value is the key
'displayText'
],
data: [[1, 'item1'], [2, 'item2']]  // data is local
}),
valueField: 'myId',
displayField: 'displayText',
triggerAction: 'all'
});
</code></pre></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minListWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width of the dropdown list in pixels (defaults to <tt>70</tt>, will be ignored if <tt>{@link #listWidth}</tt> has a higher value)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='forceSelection'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to restrict the selected value to one of the values in the list, <tt>false</tt> to allow the user to set arbitrary text into the field (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='typeAheadDelay'>
          <xs:annotation>
            <xs:documentation>
The length of time in milliseconds to wait until the typeahead text is displayed if <tt>{@link #typeAhead} = true</tt> (defaults to <tt>250</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='valueNotFoundText'>
          <xs:annotation>
            <xs:documentation>
When using a name/value combo, if the value passed to setValue is not found in the store, valueNotFoundText will be displayed as the field text if defined (defaults to undefined). If this default text is used, it means there is no value set and no validation will occur on this field.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='lazyInit'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to not initialize the list for this combo until the field is focused (defaults to <tt>true</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tpl'>
          <xs:annotation>
            <xs:documentation>
<p>The template string, or {@link Ext.XTemplate} instance to use to display each item in the dropdown list. The dropdown list is displayed in a DataView. See {@link #view}.</p><p>The default template string is:</p><pre><code>'&lt;tpl for="."&gt;&lt;div class="x-combo-list-item"&gt;{' + this.displayField + '}&lt;/div&gt;&lt;/tpl&gt;'
</code></pre><p>Override the default value to create custom UI layouts for items in the list. For example:</p><pre><code>'&lt;tpl for="."&gt;&lt;div ext:qtip="{state}. {nick}" class="x-combo-list-item"&gt;{state}&lt;/div&gt;&lt;/tpl&gt;'
</code></pre><p>The template <b>must</b> contain one or more substitution parameters using field names from the Combo's {@link #store Store}. In the example above an</p><pre>ext:qtip</pre>attribute is added to display other fields from the Store.<br/><br/> <p>To preserve the default visual look of list items, add the CSS class name</p><pre>x-combo-list-item</pre>to the template's container element.<br/><br/> <p>Also see {@link #itemSelector} for additional details.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='itemSelector'>
          <xs:annotation>
            <xs:documentation>
<p>A simple CSS selector (e.g. div.some-class or span:first-child) that will be used to determine what nodes the {@link #view Ext.DataView} which handles the dropdown display will be working with.</p><p><b>Note</b>: this setting is <b>required</b> if a custom XTemplate has been specified in {@link #tpl} which assigns a class other than</p><pre>'x-combo-list-item'</pre>to dropdown list items
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='combo' name='combo' type='ext:ext.form.ComboBox' substitutionGroup='ext:trigger'>
    <xs:annotation>
      <xs:documentation>
<p>A combobox control with support for autocomplete, remote-loading, paging and many other features.</p><p>A ComboBox works in a similar manner to a traditional HTML &lt;select&gt; field. The difference is that to submit the {@link #valueField}, you must specify a {@link #hiddenName} to create a hidden input field to hold the value of the valueField. The <i>{@link #displayField}</i> is shown in the text field which is named according to the {@link #name}.</p><p style="font-weight: bold"><u>Events</u></p><p>To do something when something in ComboBox is selected, configure the select event:</p><pre><code>var cb = new Ext.form.ComboBox({
// all of your config options
listeners:{
scope: yourScope,
'select': yourFunction
}
});

// Alternatively, you can assign events after the object is created:
var cb = new Ext.form.ComboBox(yourOptions);
cb.on('select', yourFunction, yourScope);
</code></pre><br/><br/> <p style="font-weight: bold"><u>ComboBox in Grid</u></p><p>If using a ComboBox in an {@link Ext.grid.EditorGridPanel Editor Grid} a {@link Ext.grid.Column#renderer renderer} will be needed to show the displayField when the editor is not active. Set up the renderer manually, or implement a reusable render, for example:</p><pre><code>// create reusable renderer
Ext.util.Format.comboRenderer = function(combo){
return function(value){
var record = combo.findRecord(combo.{@link #valueField}, value);
return record ? record.get(combo.{@link #displayField}) : combo.{@link #valueNotFoundText};
}
}

// create the combo instance
var combo = new Ext.form.ComboBox({
{@link #typeAhead}: true,
{@link #triggerAction}: 'all',
{@link #lazyRender}:true,
{@link #mode}: 'local',
{@link #store}: new Ext.data.ArrayStore({
id: 0,
fields: [
'myId',
'displayText'
],
data: [[1, 'item1'], [2, 'item2']]
}),
{@link #valueField}: 'myId',
{@link #displayField}: 'displayText'
});

// snippet of column model used within grid
var cm = new Ext.grid.ColumnModel([{
...
},{
header: "Some Header",
dataIndex: 'whatever',
width: 130,
editor: combo, // specify reference to combo instance
renderer: Ext.util.Format.comboRenderer(combo) // pass combo instance to reusable renderer
},
...
]);
</code></pre><br/><br/> <p style="font-weight: bold"><u>Filtering</u></p><p>A ComboBox {@link #doQuery uses filtering itself}, for information about filtering the ComboBox store manually see <tt>{@link #lastQuery}</tt>.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Component'>
    <xs:complexContent>
      <xs:extension base='ext:ext.util.Observable'>
        <xs:sequence>
            <xs:element name='plugins' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An object or array of objects that will provide custom functionality for this component. The only requirement for a valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is created, if any plugins are available, the component will call the init method on each plugin, passing a reference to itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='applyTo' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in the document that specifies some structural markup for this component.</p><div><ul><li><b>Description</b> : <div style="margin-left: 2em">When <tt>applyTo</tt> is used, constituent parts of the component can also be specified by id or CSS class name within the main element, and the component being created may attempt to create its subcomponents from that markup if applicable.</div></li><li><b>Notes</b> : <div style="margin-left: 2em"><div class="sub-desc">When using this config, a call to render() is not required.</div><div class="sub-desc">If applyTo is specified, any value passed for {@link #renderTo} will be ignored and the target element's parent node will automatically be used as the component's container.</div></div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='renderTo' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>Specify the id of the element, a DOM element or an existing Element that this component will be rendered into.</p><div><ul><li><b>Notes</b> : <div style="margin-left: 2em"><div class="sub-desc">Do <u>not</u> use this option if the Component is to be a child item of a {@link Ext.Container Container}. It is the responsibility of the {@link Ext.Container Container}'s {@link Ext.Container#layout layout manager} to render and manage its child items.</div><div class="sub-desc">When using this config, a call to render() is not required.</div></div></li></ul></div><p>See <tt>{@link #render}</tt> also.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='stateEvents' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>An array of events that, when fired, should trigger this component to save its state (defaults to none). <code>stateEvents</code> may be any type of event supported by this component, including browser or custom events (e.g., <tt>['click', 'customerchange']</tt>).</p><p>See <code>{@link #stateful}</code> for an explanation of saving and restoring Component state.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='autoEl' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A tag name or {@link Ext.DomHelper DomHelper} spec used to create the {@link #getEl Element} which will encapsulate this Component.</p><p>You do not normally need to specify this. For the base classes {@link Ext.Component}, {@link Ext.BoxComponent}, and {@link Ext.Container}, this defaults to <b><tt>'div'</tt></b>. The more complex Ext classes use a more complex DOM structure created by their own onRender methods.</p><p>This is intended to allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example usage:</p><pre><code>{
xtype: 'box',
autoEl: {
tag: 'img',
src: 'http://www.example.com/example.jpg'
}
}, {
xtype: 'box',
autoEl: {
tag: 'blockquote',
html: 'autoEl is cool!'
}
}, {
xtype: 'container',
autoEl: 'ul',
cls: 'ux-unordered-list',
items: {
xtype: 'box',
autoEl: 'li',
html: 'First list item'
}
}
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='fieldLabel'>
          <xs:annotation>
            <xs:documentation>
<p>The label text to display next to this Component (defaults to '').</p><br/><p><b>Note</b>: this config is only used when this Component is rendered by a Container which has been configured to use the <b>{@link Ext.layout.FormLayout FormLayout}</b> layout manager (e.g. {@link Ext.form.FormPanel} or specifying <tt>layout:'form'</tt>).</p><br/><p>Also see <tt>{@link #hideLabel}</tt> and {@link Ext.layout.FormLayout}.{@link Ext.layout.FormLayout#fieldTpl fieldTpl}.</p>Example use:<pre><code>new Ext.FormPanel({
height: 100,
renderTo: Ext.getBody(),
items: [{
xtype: 'textfield',
fieldLabel: 'Name'
}]
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='labelStyle'>
          <xs:annotation>
            <xs:documentation>
<p>A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value if set (e.g., <tt>{@link Ext.layout.FormLayout#labelStyle}</tt> , or '').</p><br/><p><b>Note</b>: see the note for <code>{@link #clearCls}</code>.</p><br/><p>Also see <code>{@link #hideLabel}</code> and <code>{@link Ext.layout.FormLayout}.{@link Ext.layout.FormLayout#fieldTpl fieldTpl}.</code></p>Example use:<pre><code>new Ext.FormPanel({
height: 100,
renderTo: Ext.getBody(),
items: [{
xtype: 'textfield',
fieldLabel: 'Name',
labelStyle: 'font-weight:bold;'
}]
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='labelSeparator'>
          <xs:annotation>
            <xs:documentation>
<p>The separator to display after the text of each <tt>{@link #fieldLabel}</tt>. This property may be configured at various levels. The order of precedence is:</p><div class="mdetail-params"><ul><li>field / component level</li><li>container level</li><li>{@link Ext.layout.FormLayout#labelSeparator layout level} (defaults to colon <tt>':'</tt>)</li></ul></div>To display no separator for this field's label specify empty string ''.<br/><br/> <br/><p><b>Note</b>: see the note for <tt>{@link #clearCls}</tt>.</p><br/><p>Also see <tt>{@link #hideLabel}</tt> and {@link Ext.layout.FormLayout}.{@link Ext.layout.FormLayout#fieldTpl fieldTpl}.</p>Example use:<pre><code>new Ext.FormPanel({
height: 100,
renderTo: Ext.getBody(),
layoutConfig: {
labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
},
{@link Ext.layout.FormLayout#labelSeparator labelSeparator}: '&gt;&gt;',     // config at container level
items: [{
xtype: 'textfield',
fieldLabel: 'Field 1',
labelSeparator: '...' // field/component level config supersedes others
},{
xtype: 'textfield',
fieldLabel: 'Field 2' // labelSeparator will be '='
}]
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideLabel'>
          <xs:annotation>
            <xs:documentation>
<p><tt>true</tt> to completely hide the label element ({@link #fieldLabel label} and {@link #labelSeparator separator}). Defaults to <tt>false</tt>. By default, even if you do not specify a <tt>{@link #fieldLabel}</tt> the space will still be reserved so that the field will line up with other fields that do have labels. Setting this to <tt>true</tt> will cause the field to not reserve that space.</p><br/><p><b>Note</b>: see the note for <tt>{@link #clearCls}</tt>.</p><br/>Example use:<pre><code>new Ext.FormPanel({
height: 100,
renderTo: Ext.getBody(),
items: [{
xtype: 'textfield'
hideLabel: true
}]
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='clearCls'>
          <xs:annotation>
            <xs:documentation>
<p>The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide field clearing (defaults to <tt>'x-form-clear-left'</tt>).</p><br/><p><b>Note</b>: this config is only used when this Component is rendered by a Container which has been configured to use the <b>{@link Ext.layout.FormLayout FormLayout}</b> layout manager (e.g. {@link Ext.form.FormPanel} or specifying <tt>layout:'form'</tt>) and either a <tt>{@link #fieldLabel}</tt> is specified or <tt>isFormField=true</tt> is specified.</p><br/><p>See {@link Ext.layout.FormLayout}.{@link Ext.layout.FormLayout#fieldTpl fieldTpl} also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='itemCls'>
          <xs:annotation>
            <xs:documentation>
<p><b>Note</b>: this config is only used when this Component is rendered by a Container which has been configured to use the <b>{@link Ext.layout.FormLayout FormLayout}</b> layout manager (e.g. {@link Ext.form.FormPanel} or specifying <tt>layout:'form'</tt>).</p><br/><p>An additional CSS class to apply to the div wrapping the form item element of this field. If supplied, <tt>itemCls</tt> at the <b>field</b> level will override the default <tt>itemCls</tt> supplied at the <b>container</b> level. The value specified for <tt>itemCls</tt> will be added to the default class (<tt>'x-form-item'</tt>).</p><p>Since it is applied to the item wrapper (see {@link Ext.layout.FormLayout}.{@link Ext.layout.FormLayout#fieldTpl fieldTpl}), it allows you to write standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the field.</p><br/><p><b>Note</b>: see the note for <tt>{@link #fieldLabel}</tt>.</p><br/>Example use:<pre><code>// Apply a style to the field's label:
&lt;style&gt;
.required .x-form-item-label {font-weight:bold;color:red;}
&lt;/style&gt;

new Ext.FormPanel({
height: 100,
renderTo: Ext.getBody(),
items: [{
xtype: 'textfield',
fieldLabel: 'Name',
itemCls: 'required' //this label will be styled
},{
xtype: 'textfield',
fieldLabel: 'Favorite Color'
}]
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='anchor'>
          <xs:annotation>
            <xs:documentation>
<p><b>Note</b>: this config is only used when this Component is rendered by a Container which has been configured to use an <b>{@link Ext.layout.AnchorLayout AnchorLayout}</b> based layout manager, for example:</p><div class="mdetail-params"><ul><li>{@link Ext.form.FormPanel}</li><li>specifying <code>layout: 'anchor' // or 'form', or 'absolute'</code></li></ul></div><br/><br/> <p>See {@link Ext.layout.AnchorLayout}.{@link Ext.layout.AnchorLayout#anchor anchor} also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='id'>
          <xs:annotation>
            <xs:documentation>
<p>The <b>unique</b> id of this component (defaults to an {@link #getId auto-assigned id}). You should assign an id if you need to be able to access the component later and you do not have an object reference available (e.g., using {@link Ext}.{@link Ext#getCmp getCmp}).</p><p>Note that this id will also be used as the element id for the containing HTML element that is rendered to the page for this component. This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to select sub-elements using this component's id as the parent.</p><p><b>Note</b>: to avoid complications imposed by a unique <tt>id</tt> also see <code>{@link #itemId}</code> and <code>{@link #ref}</code>.</p><p><b>Note</b>: to access the container of an item see <code>{@link #ownerCt}</code>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='itemId'>
          <xs:annotation>
            <xs:documentation>
<p>An <tt>itemId</tt> can be used as an alternative way to get a reference to a component when no object reference is available. Instead of using an <code>{@link #id}</code> with {@link Ext}.{@link Ext#getCmp getCmp}, use <code>itemId</code> with {@link Ext.Container}.{@link Ext.Container#getComponent getComponent} which will retrieve <code>itemId</code>'s or <tt>{@link #id}</tt>'s. Since <code>itemId</code>'s are an index to the container's internal MixedCollection, the <code>itemId</code> is scoped locally to the container -- avoiding potential conflicts with {@link Ext.ComponentMgr} which requires a <b>unique</b> <code>{@link #id}</code>.</p><pre><code>var c = new Ext.Panel({ //
{@link Ext.BoxComponent#height height}: 300,
{@link #renderTo}: document.body,
{@link Ext.Container#layout layout}: 'auto',
{@link Ext.Container#items items}: [
{
itemId: 'p1',
{@link Ext.Panel#title title}: 'Panel 1',
{@link Ext.BoxComponent#height height}: 150
},
{
itemId: 'p2',
{@link Ext.Panel#title title}: 'Panel 2',
{@link Ext.BoxComponent#height height}: 150
}
]
})
p1 = c.{@link Ext.Container#getComponent getComponent}('p1'); // not the same as {@link Ext#getCmp Ext.getCmp()}
p2 = p1.{@link #ownerCt}.{@link Ext.Container#getComponent getComponent}('p2'); // reference via a sibling
</code></pre><p>Also see <tt>{@link #id}</tt> and <code>{@link #ref}</code>.</p><p><b>Note</b>: to access the container of an item see <tt>{@link #ownerCt}</tt>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='xtype'>
          <xs:annotation>
            <xs:documentation>
The registered <tt>xtype</tt> to create. This config option is not used when passing a config object into a constructor. This config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not as a fully instantiated Component, but as a <i>Component config object</i>. The <tt>xtype</tt> will be looked up at render time up to determine what type of child Component to create.<br/><br/>The predefined xtypes are listed {@link Ext.Component here}. <br/><br/>If you subclass Components to create your own Components, you may register them using {@link Ext.ComponentMgr#registerType} in order to be able to take advantage of lazy instantiation and rendering.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='ptype'>
          <xs:annotation>
            <xs:documentation>
The registered <tt>ptype</tt> to create. This config option is not used when passing a config object into a constructor. This config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully instantiated Component, but as a <i>Component config object</i>. The <tt>ptype</tt> will be looked up at render time up to determine what type of Plugin to create.<br/><br/>If you create your own Plugins, you may register them using {@link Ext.ComponentMgr#registerPlugin} in order to be able to take advantage of lazy instantiation and rendering.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='cls'>
          <xs:annotation>
            <xs:documentation>
An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for adding customized styles to the component or any of its children using standard CSS rules.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='overCls'>
          <xs:annotation>
            <xs:documentation>
An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles to the component or any of its children using standard CSS rules.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='style'>
          <xs:annotation>
            <xs:documentation>
A custom style specification to be applied to this component's Element. Should be a valid argument to {@link Ext.Element#applyStyles}. <pre><code>new Ext.Panel({
title: 'Some Title',
renderTo: Ext.getBody(),
width: 400, height: 300,
layout: 'form',
items: [{
xtype: 'textarea',
style: {
width: '95%',
marginBottom: '10px'
}
},
new Ext.Button({
text: 'Send',
minWidth: '100',
style: {
marginBottom: '10px'
}
})
]
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='ctCls'>
          <xs:annotation>
            <xs:documentation>
<p>An optional extra CSS class that will be added to this component's container. This can be useful for adding customized styles to the container or any of its children using standard CSS rules. See {@link Ext.layout.ContainerLayout}.{@link Ext.layout.ContainerLayout#extraCls extraCls} also.</p><p><b>Note</b>: <tt>ctCls</tt> defaults to <tt>''</tt> except for the following class which assigns a value by default:</p><div class="mdetail-params"><ul><li>{@link Ext.layout.Box Box Layout} : <tt>'x-box-layout-ct'</tt></li></ul></div>To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout (Hbox and Vbox):<pre><code>ctCls: 'x-box-layout-ct custom-class'
</code></pre><br/><br/>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='disabled'>
          <xs:annotation>
            <xs:documentation>
Render this component disabled (default is false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hidden'>
          <xs:annotation>
            <xs:documentation>
Render this component hidden (default is false). If <tt>true</tt>, the {@link #hide} method will be called internally.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='plugins'>
          <xs:annotation>
            <xs:documentation>
An object or array of objects that will provide custom functionality for this component. The only requirement for a valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is created, if any plugins are available, the component will call the init method on each plugin, passing a reference to itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='applyTo'>
          <xs:annotation>
            <xs:documentation>
<p>Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in the document that specifies some structural markup for this component.</p><div><ul><li><b>Description</b> : <div style="margin-left: 2em">When <tt>applyTo</tt> is used, constituent parts of the component can also be specified by id or CSS class name within the main element, and the component being created may attempt to create its subcomponents from that markup if applicable.</div></li><li><b>Notes</b> : <div style="margin-left: 2em"><div class="sub-desc">When using this config, a call to render() is not required.</div><div class="sub-desc">If applyTo is specified, any value passed for {@link #renderTo} will be ignored and the target element's parent node will automatically be used as the component's container.</div></div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='renderTo'>
          <xs:annotation>
            <xs:documentation>
<p>Specify the id of the element, a DOM element or an existing Element that this component will be rendered into.</p><div><ul><li><b>Notes</b> : <div style="margin-left: 2em"><div class="sub-desc">Do <u>not</u> use this option if the Component is to be a child item of a {@link Ext.Container Container}. It is the responsibility of the {@link Ext.Container Container}'s {@link Ext.Container#layout layout manager} to render and manage its child items.</div><div class="sub-desc">When using this config, a call to render() is not required.</div></div></li></ul></div><p>See <tt>{@link #render}</tt> also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='stateful'>
          <xs:annotation>
            <xs:documentation>
<p>A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup. The component must have either a <code>{@link #stateId}</code> or <code>{@link #id}</code> assigned for state to be managed. Auto-generated ids are not guaranteed to be stable across page loads and cannot be relied upon to save and restore the same state for a component.</p><p>For state saving to work, the state manager's provider must have been set to an implementation of {@link Ext.state.Provider} which overrides the {@link Ext.state.Provider#set set} and {@link Ext.state.Provider#get get} methods to save and recall name/value pairs. A built-in implementation, {@link Ext.state.CookieProvider} is available.</p><p>To set the state provider for the current page:</p><pre><code>Ext.state.Manager.setProvider(new Ext.state.CookieProvider({
expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
}));
</code></pre><p>A stateful Component attempts to save state when one of the events listed in the <code>{@link #stateEvents}</code> configuration fires.</p><p>To save state, a stateful Component first serializes its state by calling <b><code>getState</code></b>. By default, this function does nothing. The developer must provide an implementation which returns an object hash which represents the Component's restorable state.</p><p>The value yielded by getState is passed to {@link Ext.state.Manager#set} which uses the configured {@link Ext.state.Provider} to save the object keyed by the Component's <code>{@link stateId}</code>, or, if that is not specified, its <code>{@link #id}</code>.</p><p>During construction, a stateful Component attempts to <i>restore</i> its state by calling {@link Ext.state.Manager#get} passing the <code>{@link #stateId}</code>, or, if that is not specified, the <code>{@link #id}</code>.</p><p>The resulting object is passed to <b><code>applyState</code></b>. The default implementation of <code>applyState</code> simply copies properties into the object, but a developer may override this to support more behaviour.</p><p>You can perform extra processing on state save and restore by attaching handlers to the {@link #beforestaterestore}, {@link #staterestore}, {@link #beforestatesave} and {@link #statesave} events.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='stateId'>
          <xs:annotation>
            <xs:documentation>
The unique id for this component to use for state management purposes (defaults to the component id if one was set, otherwise null if the component is using a generated id). <p>See <code>{@link #stateful}</code> for an explanation of saving and restoring Component state.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='stateEvents'>
          <xs:annotation>
            <xs:documentation>
<p>An array of events that, when fired, should trigger this component to save its state (defaults to none). <code>stateEvents</code> may be any type of event supported by this component, including browser or custom events (e.g., <tt>['click', 'customerchange']</tt>).</p><p>See <code>{@link #stateful}</code> for an explanation of saving and restoring Component state.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='autoEl'>
          <xs:annotation>
            <xs:documentation>
<p>A tag name or {@link Ext.DomHelper DomHelper} spec used to create the {@link #getEl Element} which will encapsulate this Component.</p><p>You do not normally need to specify this. For the base classes {@link Ext.Component}, {@link Ext.BoxComponent}, and {@link Ext.Container}, this defaults to <b><tt>'div'</tt></b>. The more complex Ext classes use a more complex DOM structure created by their own onRender methods.</p><p>This is intended to allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example usage:</p><pre><code>{
xtype: 'box',
autoEl: {
tag: 'img',
src: 'http://www.example.com/example.jpg'
}
}, {
xtype: 'box',
autoEl: {
tag: 'blockquote',
html: 'autoEl is cool!'
}
}, {
xtype: 'container',
autoEl: 'ul',
cls: 'ux-unordered-list',
items: {
xtype: 'box',
autoEl: 'li',
html: 'First list item'
}
}
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledClass'>
          <xs:annotation>
            <xs:documentation>
CSS class added to the component when it is disabled (defaults to 'x-item-disabled').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowDomMove'>
          <xs:annotation>
            <xs:documentation>
Whether the component can move the Dom node when rendering (defaults to true).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoShow'>
          <xs:annotation>
            <xs:documentation>
True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='hideMode'>
          <xs:annotation>
            <xs:documentation>
<p>How this component should be hidden. Supported values are <tt>'visibility'</tt> (css visibility), <tt>'offsets'</tt> (negative offset position) and <tt>'display'</tt> (css display).</p><br/><p><b>Note</b>: the default of <tt>'display'</tt> is generally preferred since items are automatically laid out when they are first shown (no sizing is done while hidden).</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideParent'>
          <xs:annotation>
            <xs:documentation>
True to hide and show the component's container when hide/show is called on the component, false to hide and show the component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by setting hide:true on the button when adding it to its parent container.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='ref'>
          <xs:annotation>
            <xs:documentation>
<p>A path specification, relative to the Component's {@link #ownerCt} specifying into which ancestor Container to place a named reference to this Component.</p><p>The ancestor axis can be traversed by using '/' characters in the path. For example, to put a reference to a Toolbar Button into <i>the Panel which owns the Toolbar</i>:</p><pre><code>var myGrid = new Ext.grid.EditorGridPanel({
title: 'My EditorGridPanel',
store: myStore,
colModel: myColModel,
tbar: [{
text: 'Save',
handler: saveChanges,
disabled: true,
ref: '../saveButton'
}],
listeners: {
afteredit: function() {
//          The button reference is in the GridPanel
myGrid.saveButton.enable();
}
}
});
</code></pre><p>In the code above, if the ref had been <code>'saveButton'</code> the reference would have been placed into the Toolbar. Each '/' in the ref moves up one level from the Component's {@link #ownerCt}.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='component' name='component' type='ext:ext.Component' substitutionGroup='ext:observable'>
    <xs:annotation>
      <xs:documentation>
<p>Base class for all Ext components. All subclasses of Component may participate in the automated Ext component lifecycle of creation, rendering and destruction which is provided by the {@link Ext.Container Container} class. Components may be added to a Container through the {@link Ext.Container#items items} config option at the time the Container is created, or they may be added dynamically via the {@link Ext.Container#add add} method.</p><p>The Component base class has built-in support for basic hide/show and enable/disable behavior.</p><p>All Components are registered with the {@link Ext.ComponentMgr} on construction so that they can be referenced at any time via {@link Ext#getCmp}, passing the {@link #id}.</p><p>All user-developed visual widgets that are required to participate in automated lifecycle and size management should subclass Component (or {@link Ext.BoxComponent} if managed box model handling is required, ie height and width management).</p><p>See the <a href="http://extjs.com/learn/Tutorial:Creating_new_UI_controls">Creating new UI controls</a> tutorial for details on how and to either extend or augment ExtJs base classes to create custom Components.</p><p>Every component has a specific xtype, which is its Ext-specific type name, along with methods for checking the xtype like {@link #getXType} and {@link #isXType}. This is the list of all valid xtypes:</p><pre>xtype            Class
-------------    ------------------
box              {@link Ext.BoxComponent}
button           {@link Ext.Button}
buttongroup      {@link Ext.ButtonGroup}
colorpalette     {@link Ext.ColorPalette}
component        {@link Ext.Component}
container        {@link Ext.Container}
cycle            {@link Ext.CycleButton}
dataview         {@link Ext.DataView}
datepicker       {@link Ext.DatePicker}
editor           {@link Ext.Editor}
editorgrid       {@link Ext.grid.EditorGridPanel}
flash            {@link Ext.FlashComponent}
grid             {@link Ext.grid.GridPanel}
listview         {@link Ext.ListView}
panel            {@link Ext.Panel}
progress         {@link Ext.ProgressBar}
propertygrid     {@link Ext.grid.PropertyGrid}
slider           {@link Ext.Slider}
spacer           {@link Ext.Spacer}
splitbutton      {@link Ext.SplitButton}
tabpanel         {@link Ext.TabPanel}
treepanel        {@link Ext.tree.TreePanel}
viewport         {@link Ext.ViewPort}
window           {@link Ext.Window}

Toolbar components
---------------------------------------
paging           {@link Ext.PagingToolbar}
toolbar          {@link Ext.Toolbar}
tbbutton         {@link Ext.Toolbar.Button}        (deprecated; use button)
tbfill           {@link Ext.Toolbar.Fill}
tbitem           {@link Ext.Toolbar.Item}
tbseparator      {@link Ext.Toolbar.Separator}
tbspacer         {@link Ext.Toolbar.Spacer}
tbsplit          {@link Ext.Toolbar.SplitButton}   (deprecated; use splitbutton)
tbtext           {@link Ext.Toolbar.TextItem}

Menu components
---------------------------------------
menu             {@link Ext.menu.Menu}
colormenu        {@link Ext.menu.ColorMenu}
datemenu         {@link Ext.menu.DateMenu}
menubaseitem     {@link Ext.menu.BaseItem}
menucheckitem    {@link Ext.menu.CheckItem}
menuitem         {@link Ext.menu.Item}
menuseparator    {@link Ext.menu.Separator}
menutextitem     {@link Ext.menu.TextItem}

Form components
---------------------------------------
form             {@link Ext.FormPanel}
checkbox         {@link Ext.form.Checkbox}
checkboxgroup    {@link Ext.form.CheckboxGroup}
combo            {@link Ext.form.ComboBox}
datefield        {@link Ext.form.DateField}
displayfield     {@link Ext.form.DisplayField}
field            {@link Ext.form.Field}
fieldset         {@link Ext.form.FieldSet}
hidden           {@link Ext.form.Hidden}
htmleditor       {@link Ext.form.HtmlEditor}
label            {@link Ext.form.Label}
numberfield      {@link Ext.form.NumberField}
radio            {@link Ext.form.Radio}
radiogroup       {@link Ext.form.RadioGroup}
textarea         {@link Ext.form.TextArea}
textfield        {@link Ext.form.TextField}
timefield        {@link Ext.form.TimeField}
trigger          {@link Ext.form.TriggerField}

Chart components
---------------------------------------
chart            {@link Ext.chart.Chart}
barchart         {@link Ext.chart.BarChart}
cartesianchart   {@link Ext.chart.CartesianChart}
columnchart      {@link Ext.chart.ColumnChart}
linechart        {@link Ext.chart.LineChart}
piechart         {@link Ext.chart.PieChart}

Store xtypes
---------------------------------------
arraystore       {@link Ext.data.ArrayStore}
directstore      {@link Ext.data.DirectStore}
groupingstore    {@link Ext.data.GroupingStore}
jsonstore        {@link Ext.data.JsonStore}
simplestore      {@link Ext.data.SimpleStore}      (deprecated; use arraystore)
store            {@link Ext.data.Store}
xmlstore         {@link Ext.data.XmlStore}
</pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Container'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
            <xs:element name='layout' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p><b>*Important</b>: In order for child items to be correctly sized and positioned, typically a layout manager <b>must</b> be specified through the <code>layout</code> configuration option.</p><br/><p>The sizing and positioning of child {@link items} is the responsibility of the Container's layout manager which creates and manages the type of layout you have in mind. For example:</p><pre><code>new Ext.Window({
width:300, height: 300,
layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
items: [{
title: 'Panel inside a Window'
}]
}).show();
</code></pre><p>If the {@link #layout} configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the {@link Ext.layout.ContainerLayout default layout manager} will be used which does nothing but render child components sequentially into the Container (no sizing or positioning will be performed in this situation). Some container classes implicitly specify a default layout (e.g. FormPanel specifies <code>layout:'form'</code>). Other specific purpose classes internally specify/manage their internal layout (e.g. GridPanel, TabPanel, TreePanel, Toolbar, Menu, etc.).</p><br/><p><b><code>layout</code></b> may be specified as either as an Object or as a String:</p><div><ul class="mdetail-params"><li><u>Specify as an Object</u></li><li style="list-style: none"><div><ul class="mdetail-params"><li>Example usage:</li><li style="list-style: none"><pre><code>layout: {
type: 'vbox',
padding: '5',
align: 'left'
}
</code></pre></li><li><tt><b>type</b></tt></li><li style="list-style: none"><br/><p>The layout type to be used for this container. If not specified, a default {@link Ext.layout.ContainerLayout} will be created and used.</p><br/><p>Valid layout <tt>type</tt> values are:</p><div class="sub-desc"><ul class="mdetail-params"><li><tt><b>{@link Ext.layout.AbsoluteLayout absolute}</b></tt></li><li><tt><b>{@link Ext.layout.AccordionLayout accordion}</b></tt></li><li><tt><b>{@link Ext.layout.AnchorLayout anchor}</b></tt></li><li><tt><b>{@link Ext.layout.ContainerLayout auto}</b></tt> Â Â Â  <b>Default</b></li><li><tt><b>{@link Ext.layout.BorderLayout border}</b></tt></li><li><tt><b>{@link Ext.layout.CardLayout card}</b></tt></li><li><tt><b>{@link Ext.layout.ColumnLayout column}</b></tt></li><li><tt><b>{@link Ext.layout.FitLayout fit}</b></tt></li><li><tt><b>{@link Ext.layout.FormLayout form}</b></tt></li><li><tt><b>{@link Ext.layout.HBoxLayout hbox}</b></tt></li><li><tt><b>{@link Ext.layout.MenuLayout menu}</b></tt></li><li><tt><b>{@link Ext.layout.TableLayout table}</b></tt></li><li><tt><b>{@link Ext.layout.ToolbarLayout toolbar}</b></tt></li><li><tt><b>{@link Ext.layout.VBoxLayout vbox}</b></tt></li></ul></div></li><li>Layout specific configuration properties</li><li style="list-style: none"><br/><p>Additional layout specific configuration properties may also be specified. For complete details regarding the valid config options for each layout type, see the layout class corresponding to the <tt>type</tt> specified.</p></li></ul></div></li><li><u>Specify as a String</u></li><li style="list-style: none"><div><ul class="mdetail-params"><li>Example usage:</li><li style="list-style: none"><pre><code>layout: 'vbox',
layoutConfig: {
padding: '5',
align: 'left'
}
</code></pre></li><li><tt><b>layout</b></tt></li><li style="list-style: none"><br/><p>The layout <tt>type</tt> to be used for this container (see list of valid layout type values above).</p><br/></li><li><tt><b>{@link #layoutConfig}</b></tt></li><li style="list-style: none"><br/><p>Additional layout specific configuration properties. For complete details regarding the valid config options for each layout type, see the layout class corresponding to the <tt>layout</tt> specified.</p></li></ul></div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='layoutConfig' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    This is a config object containing properties specific to the chosen <b><code>{@link #layout}</code></b> if <b><code>{@link #layout}</code></b> has been specified as a <i>string</i>.<br/><br/>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='items' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <pre><b>** IMPORTANT</b>: be sure to <b>{@link #layout specify a <code>layout</code>} if needed ! **</b></pre><p>A single item, or an array of child Components to be added to this container, for example:</p><pre><code>// specifying a single item
items: {...},
layout: 'fit',    // specify a layout!

// specifying multiple items
items: [{...}, {...}],
layout: 'anchor', // specify a layout!
</code></pre><p>Each item may be:</p><div><ul class="mdetail-params"><li>any type of object based on {@link Ext.Component}</li><li>a fully instanciated object or</li><li>an object literal that:</li><li style="list-style: none"><div><ul class="mdetail-params"><li>has a specified <code>{@link Ext.Component#xtype xtype}</code></li><li>the {@link Ext.Component#xtype} specified is associated with the Component desired and should be chosen from one of the available xtypes as listed in {@link Ext.Component}.</li><li>If an <code>{@link Ext.Component#xtype xtype}</code> is not explicitly specified, the {@link #defaultType} for that Container is used.</li><li>will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object</li></ul></div></li></ul></div><p><b>Notes</b>:</p><div><ul class="mdetail-params"><li>Ext uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out when they are first shown (no sizing is done while hidden), or in response to a {@link #doLayout} call.</li><li>Do not specify <code>{@link Ext.Panel#contentEl contentEl}</code>/ <code>{@link Ext.Panel#html html}</code> with <code>items</code>.</li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='defaults' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A config object that will be applied to all components added to this container either via the {@link #items} config or via the {@link #add} or {@link #insert} methods. The <tt>defaults</tt> config can contain any number of name/value property pairs to be added to each item, and should be valid for the types of items being added to the container. For example, to automatically apply padding to the body of each of a set of contained {@link Ext.Panel} items, you could pass: <tt>defaults: {bodyStyle:'padding:15px'}</tt>.</p><br/><p><b>Note</b>: <tt>defaults</tt> will not be applied to config objects if the option is already specified. For example:</p><pre><code>defaults: {               // defaults are applied to items, not the container
autoScroll:true
},
items: [
{
xtype: 'panel',   // defaults <b>do not</b> have precedence over
id: 'panel1',     // options in config objects, so the defaults
autoScroll: false // will not be applied here, panel1 will be autoScroll:false
},
new Ext.Panel({       // defaults <b>do</b> have precedence over options
id: 'panel2',     // options in components, so the defaults
autoScroll: false // will be applied here, panel2 will be autoScroll:true.
})
]
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='bubbleEvents' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>An array of events that, when fired, should be bubbled to any parent container. Defaults to <tt>['add', 'remove']</tt>.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='monitorResize'>
          <xs:annotation>
            <xs:documentation>
True to automatically monitor window resize events to handle anything that is sensitive to the current size of the viewport. This value is typically managed by the chosen <code>{@link #layout}</code> and should not need to be set manually.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='layout'>
          <xs:annotation>
            <xs:documentation>
<p><b>*Important</b>: In order for child items to be correctly sized and positioned, typically a layout manager <b>must</b> be specified through the <code>layout</code> configuration option.</p><br/><p>The sizing and positioning of child {@link items} is the responsibility of the Container's layout manager which creates and manages the type of layout you have in mind. For example:</p><pre><code>new Ext.Window({
width:300, height: 300,
layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
items: [{
title: 'Panel inside a Window'
}]
}).show();
</code></pre><p>If the {@link #layout} configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the {@link Ext.layout.ContainerLayout default layout manager} will be used which does nothing but render child components sequentially into the Container (no sizing or positioning will be performed in this situation). Some container classes implicitly specify a default layout (e.g. FormPanel specifies <code>layout:'form'</code>). Other specific purpose classes internally specify/manage their internal layout (e.g. GridPanel, TabPanel, TreePanel, Toolbar, Menu, etc.).</p><br/><p><b><code>layout</code></b> may be specified as either as an Object or as a String:</p><div><ul class="mdetail-params"><li><u>Specify as an Object</u></li><li style="list-style: none"><div><ul class="mdetail-params"><li>Example usage:</li><li style="list-style: none"><pre><code>layout: {
type: 'vbox',
padding: '5',
align: 'left'
}
</code></pre></li><li><tt><b>type</b></tt></li><li style="list-style: none"><br/><p>The layout type to be used for this container. If not specified, a default {@link Ext.layout.ContainerLayout} will be created and used.</p><br/><p>Valid layout <tt>type</tt> values are:</p><div class="sub-desc"><ul class="mdetail-params"><li><tt><b>{@link Ext.layout.AbsoluteLayout absolute}</b></tt></li><li><tt><b>{@link Ext.layout.AccordionLayout accordion}</b></tt></li><li><tt><b>{@link Ext.layout.AnchorLayout anchor}</b></tt></li><li><tt><b>{@link Ext.layout.ContainerLayout auto}</b></tt> Â Â Â  <b>Default</b></li><li><tt><b>{@link Ext.layout.BorderLayout border}</b></tt></li><li><tt><b>{@link Ext.layout.CardLayout card}</b></tt></li><li><tt><b>{@link Ext.layout.ColumnLayout column}</b></tt></li><li><tt><b>{@link Ext.layout.FitLayout fit}</b></tt></li><li><tt><b>{@link Ext.layout.FormLayout form}</b></tt></li><li><tt><b>{@link Ext.layout.HBoxLayout hbox}</b></tt></li><li><tt><b>{@link Ext.layout.MenuLayout menu}</b></tt></li><li><tt><b>{@link Ext.layout.TableLayout table}</b></tt></li><li><tt><b>{@link Ext.layout.ToolbarLayout toolbar}</b></tt></li><li><tt><b>{@link Ext.layout.VBoxLayout vbox}</b></tt></li></ul></div></li><li>Layout specific configuration properties</li><li style="list-style: none"><br/><p>Additional layout specific configuration properties may also be specified. For complete details regarding the valid config options for each layout type, see the layout class corresponding to the <tt>type</tt> specified.</p></li></ul></div></li><li><u>Specify as a String</u></li><li style="list-style: none"><div><ul class="mdetail-params"><li>Example usage:</li><li style="list-style: none"><pre><code>layout: 'vbox',
layoutConfig: {
padding: '5',
align: 'left'
}
</code></pre></li><li><tt><b>layout</b></tt></li><li style="list-style: none"><br/><p>The layout <tt>type</tt> to be used for this container (see list of valid layout type values above).</p><br/></li><li><tt><b>{@link #layoutConfig}</b></tt></li><li style="list-style: none"><br/><p>Additional layout specific configuration properties. For complete details regarding the valid config options for each layout type, see the layout class corresponding to the <tt>layout</tt> specified.</p></li></ul></div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='layoutConfig'>
          <xs:annotation>
            <xs:documentation>
This is a config object containing properties specific to the chosen <b><code>{@link #layout}</code></b> if <b><code>{@link #layout}</code></b> has been specified as a <i>string</i>.<br/><br/>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bufferResize'>
          <xs:annotation>
            <xs:documentation>
When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a large quantity of sub-components for which frequent layout calls would be expensive. Defaults to <tt>50</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='activeItem'>
          <xs:annotation>
            <xs:documentation>
A string component id or the numeric index of the component that should be initially activated within the container's layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's collection). activeItem only applies to layout styles that can display items one at a time (like {@link Ext.layout.AccordionLayout}, {@link Ext.layout.CardLayout} and {@link Ext.layout.FitLayout}). Related to {@link Ext.layout.ContainerLayout#activeItem}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='items'>
          <xs:annotation>
            <xs:documentation>
<pre><b>** IMPORTANT</b>: be sure to <b>{@link #layout specify a <code>layout</code>} if needed ! **</b></pre><p>A single item, or an array of child Components to be added to this container, for example:</p><pre><code>// specifying a single item
items: {...},
layout: 'fit',    // specify a layout!

// specifying multiple items
items: [{...}, {...}],
layout: 'anchor', // specify a layout!
</code></pre><p>Each item may be:</p><div><ul class="mdetail-params"><li>any type of object based on {@link Ext.Component}</li><li>a fully instanciated object or</li><li>an object literal that:</li><li style="list-style: none"><div><ul class="mdetail-params"><li>has a specified <code>{@link Ext.Component#xtype xtype}</code></li><li>the {@link Ext.Component#xtype} specified is associated with the Component desired and should be chosen from one of the available xtypes as listed in {@link Ext.Component}.</li><li>If an <code>{@link Ext.Component#xtype xtype}</code> is not explicitly specified, the {@link #defaultType} for that Container is used.</li><li>will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object</li></ul></div></li></ul></div><p><b>Notes</b>:</p><div><ul class="mdetail-params"><li>Ext uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out when they are first shown (no sizing is done while hidden), or in response to a {@link #doLayout} call.</li><li>Do not specify <code>{@link Ext.Panel#contentEl contentEl}</code>/ <code>{@link Ext.Panel#html html}</code> with <code>items</code>.</li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaults'>
          <xs:annotation>
            <xs:documentation>
<p>A config object that will be applied to all components added to this container either via the {@link #items} config or via the {@link #add} or {@link #insert} methods. The <tt>defaults</tt> config can contain any number of name/value property pairs to be added to each item, and should be valid for the types of items being added to the container. For example, to automatically apply padding to the body of each of a set of contained {@link Ext.Panel} items, you could pass: <tt>defaults: {bodyStyle:'padding:15px'}</tt>.</p><br/><p><b>Note</b>: <tt>defaults</tt> will not be applied to config objects if the option is already specified. For example:</p><pre><code>defaults: {               // defaults are applied to items, not the container
autoScroll:true
},
items: [
{
xtype: 'panel',   // defaults <b>do not</b> have precedence over
id: 'panel1',     // options in config objects, so the defaults
autoScroll: false // will not be applied here, panel1 will be autoScroll:false
},
new Ext.Panel({       // defaults <b>do</b> have precedence over options
id: 'panel2',     // options in components, so the defaults
autoScroll: false // will be applied here, panel2 will be autoScroll:true.
})
]
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoDestroy'>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='forceLayout'>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideBorders'>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultType'>
        </xs:attribute>
        <xs:attribute type='xs:string' name='resizeEvent'>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bubbleEvents'>
          <xs:annotation>
            <xs:documentation>
<p>An array of events that, when fired, should be bubbled to any parent container. Defaults to <tt>['add', 'remove']</tt>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='container' name='container' type='ext:ext.Container' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
<p>Base class for any {@link Ext.BoxComponent} that may contain other Components. Containers handle the basic behavior of containing items, namely adding, inserting and removing items.</p><p>The most commonly used Container classes are {@link Ext.Panel}, {@link Ext.Window} and {@link Ext.TabPanel}. If you do not need the capabilities offered by the aforementioned classes you can create a lightweight Container to be encapsulated by an HTML element to your specifications by using the <tt><b>{@link Ext.Component#autoEl autoEl}</b></tt> config option. This is a useful technique when creating embedded {@link Ext.layout.ColumnLayout column} layouts inside {@link Ext.form.FormPanel FormPanels} for example.</p><p>The code below illustrates both how to explicitly create a Container, and how to implicitly create one using the <b><tt>'container'</tt></b> xtype:</p><pre><code>// explicitly create a Container
var embeddedColumns = new Ext.Container({
autoEl: 'div',  // This is the default
layout: 'column',
defaults: {
// implicitly create Container by specifying xtype
xtype: 'container',
autoEl: 'div', // This is the default.
layout: 'form',
columnWidth: 0.5,
style: {
padding: '10px'
}
},
//  The two items below will be Ext.Containers, each encapsulated by a &lt;DIV&gt; element.
items: [{
items: {
xtype: 'datefield',
name: 'startDate',
fieldLabel: 'Start date'
}
}, {
items: {
xtype: 'datefield',
name: 'endDate',
fieldLabel: 'End date'
}
}]
});</code></pre><br/><br/> <p><u><b>Layout</b></u></p><p>Container classes delegate the rendering of child Components to a layout manager class which must be configured into the Container using the <code><b>{@link #layout}</b></code> configuration property.</p><p>When either specifying child <code>{@link #items}</code> of a Container, or dynamically {@link #add adding} Components to a Container, remember to consider how you wish the Container to arrange those child elements, and whether those child elements need to be sized using one of Ext's built-in <b><code>{@link #layout}</code></b> schemes. By default, Containers use the {@link Ext.layout.ContainerLayout ContainerLayout} scheme which only renders child components, appending them one after the other inside the Container, and <b>does not apply any sizing</b> at all.</p><p>A common mistake is when a developer neglects to specify a <b><code>{@link #layout}</code></b> (e.g. widgets like GridPanels or TreePanels are added to Containers for which no <tt><b>{@link #layout}</b></tt> has been specified). If a Container is left to use the default {@link Ext.layout.ContainerLayout ContainerLayout} scheme, none of its child components will be resized, or changed in any way when the Container is resized.</p><p>Certain layout managers allow dynamic addition of child components. Those that do include {@link Ext.layout.CardLayout}, {@link Ext.layout.AnchorLayout}, {@link Ext.layout.FormLayout}, and {@link Ext.layout.TableLayout}. For example:</p><pre><code>//  Create the GridPanel.
var myNewGrid = new Ext.grid.GridPanel({
store: myStore,
columns: myColumnModel,
title: 'Results', // the title becomes the title of the tab
});

myTabPanel.add(myNewGrid); // {@link Ext.TabPanel} implicitly uses {@link Ext.layout.CardLayout CardLayout}
myTabPanel.{@link Ext.TabPanel#setActiveTab setActiveTab}(myNewGrid);
</code></pre><br/><br/> <p>The example above adds a newly created GridPanel to a TabPanel. Note that a TabPanel uses {@link Ext.layout.CardLayout} as its layout manager which means all its child items are sized to {@link Ext.layout.FitLayout fit} exactly into its client area.</p><p><b><u>Overnesting is a common problem</u></b>. An example of overnesting occurs when a GridPanel is added to a TabPanel by wrapping the GridPanel <i>inside</i> a wrapping Panel (that has no <tt><b>{@link #layout}</b></tt> specified) and then add that wrapping Panel to the TabPanel. The point to realize is that a GridPanel <b>is</b> a Component which can be added directly to a Container. If the wrapping Panel has no <tt><b>{@link #layout}</b></tt> configuration, then the overnested GridPanel will not be sized as expected.</p><p/><p><u><b>Adding via remote configuration</b></u></p><p>A server side script can be used to add Components which are generated dynamically on the server. An example of adding a GridPanel to a TabPanel where the GridPanel is generated by the server based on certain parameters:</p><pre><code>// execute an Ajax request to invoke server side script:
Ext.Ajax.request({
url: 'gen-invoice-grid.php',
// send additional parameters to instruct server script
params: {
startDate: Ext.getCmp('start-date').getValue(),
endDate: Ext.getCmp('end-date').getValue()
},
// process the response object to add it to the TabPanel:
success: function(xhr) {
var newComponent = eval(xhr.responseText); // see discussion below
myTabPanel.add(newComponent); // add the component to the TabPanel
myTabPanel.setActiveTab(newComponent);
},
failure: function() {
Ext.Msg.alert("Grid create failed", "Server communication failure");
}
});
</code></pre><p>The server script needs to return an executable Javascript statement which, when processed using <tt>eval()</tt>, will return either a config object with an {@link Ext.Component#xtype xtype}, or an instantiated Component. The server might return this for example:</p><pre><code>(function() {
function formatDate(value){
return value ? value.dateFormat('M d, Y') : '';
};

var store = new Ext.data.Store({
url: 'get-invoice-data.php',
baseParams: {
startDate: '01/01/2008',
endDate: '01/31/2008'
},
reader: new Ext.data.JsonReader({
record: 'transaction',
idProperty: 'id',
totalRecords: 'total'
}, [
'customer',
'invNo',
{name: 'date', type: 'date', dateFormat: 'm/d/Y'},
{name: 'value', type: 'float'}
])
});

var grid = new Ext.grid.GridPanel({
title: 'Invoice Report',
bbar: new Ext.PagingToolbar(store),
store: store,
columns: [
{header: "Customer", width: 250, dataIndex: 'customer', sortable: true},
{header: "Invoice Number", width: 120, dataIndex: 'invNo', sortable: true},
{header: "Invoice Date", width: 100, dataIndex: 'date', renderer: formatDate, sortable: true},
{header: "Value", width: 120, dataIndex: 'value', renderer: 'usMoney', sortable: true}
],
});
store.load();
return grid;  // return instantiated component
})();
</code></pre><p>When the above code fragment is passed through the <tt>eval</tt> function in the success handler of the Ajax request, the code is executed by the Javascript processor, and the anonymous function runs, and returns the instantiated grid component.</p><p>Note: since the code above is <i>generated</i> by a server script, the <tt>baseParams</tt> for the Store, the metadata to allow generation of the Record layout, and the ColumnModel can all be generated into the code since these are all known on the server.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.CycleButton'>
    <xs:complexContent>
      <xs:extension base='ext:ext.SplitButton'>
        <xs:sequence>
            <xs:element name='items' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of {@link Ext.menu.CheckItem} <b>config</b> objects to be used when creating the button's menu items (e.g., {text:'Foo', iconCls:'foo-icon'})
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='changeHandler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A callback function that will be invoked each time the active menu item in the button's menu has changed. If this callback is not supplied, the SplitButton will instead fire the {@link #change} event on active item change. The changeHandler function will be called with the following argument list: (SplitButton this, Ext.menu.CheckItem item)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='items'>
          <xs:annotation>
            <xs:documentation>
An array of {@link Ext.menu.CheckItem} <b>config</b> objects to be used when creating the button's menu items (e.g., {text:'Foo', iconCls:'foo-icon'})
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='showText'>
          <xs:annotation>
            <xs:documentation>
True to display the active item's text as the button text (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='prependText'>
          <xs:annotation>
            <xs:documentation>
A static string to prepend before the active item's text when displayed as the button's text (only applies when showText = true, defaults to '')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='changeHandler'>
          <xs:annotation>
            <xs:documentation>
A callback function that will be invoked each time the active menu item in the button's menu has changed. If this callback is not supplied, the SplitButton will instead fire the {@link #change} event on active item change. The changeHandler function will be called with the following argument list: (SplitButton this, Ext.menu.CheckItem item)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='forceIcon'>
          <xs:annotation>
            <xs:documentation>
A css class which sets an image to be used as the static icon for this button. This icon will always be displayed regardless of which item is selected in the dropdown list. This overrides the default behavior of changing the button's icon to match the selected item's icon on change.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='cycle' name='cycle' type='ext:ext.CycleButton' substitutionGroup='ext:splitbutton'>
    <xs:annotation>
      <xs:documentation>
A specialized SplitButton that contains a menu of {@link Ext.menu.CheckItem} elements. The button automatically cycles through each menu item on click, raising the button's {@link #change} event (or calling the button's {@link #changeHandler} function, if supplied) for the active menu item. Clicking on the arrow section of the button displays the dropdown menu just like a normal SplitButton. Example usage: <pre><code>var btn = new Ext.CycleButton({
showText: true,
prependText: 'View as ',
items: [{
text:'text only',
iconCls:'view-text',
checked:true
},{
text:'HTML',
iconCls:'view-html'
}],
changeHandler:function(btn, item){
Ext.Msg.alert('Change View', item.text);
}
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.data.Field'>
        <xs:sequence>
            <xs:element name='convert' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    (Optional) A function which converts the value provided by the Reader into an object that will be stored in the Record. It is passed the following parameters:<div class="mdetail-params"><ul><li><b>v</b> : Mixed<div class="sub-desc">The data value as read by the Reader, if undefined will use the configured <tt>{@link Ext.data.Field#defaultValue defaultValue}</tt>.</div></li><li><b>rec</b> : Mixed<div class="sub-desc">The data object containing the row as read by the Reader. Depending on the Reader type, this could be an Array ({@link Ext.data.ArrayReader ArrayReader}), an object ({@link Ext.data.JsonReader JsonReader}), or an XML element ({@link Ext.data.XMLReader XMLReader}).</div></li></ul></div><pre><code>// example of convert function
function fullName(v, record){
return record.name.last + ', ' + record.name.first;
}

function location(v, record){
return !record.city ? '' : (record.city + ', ' + record.state);
}

var Dude = Ext.data.Record.create([
{name: 'fullname',  convert: fullName},
{name: 'firstname', mapping: 'name.first'},
{name: 'lastname',  mapping: 'name.last'},
{name: 'city', defaultValue: 'homeless'},
'state',
{name: 'location',  convert: location}
]);

// create the data store
var store = new Ext.data.Store({
reader: new Ext.data.JsonReader(
{
idProperty: 'key',
root: 'daRoot',  
totalProperty: 'total'
},
Dude  // recordType
)
});

var myData = [
{ key: 1,
name: { first: 'Fat',    last:  'Albert' }
// notice no city, state provided in data object
},
{ key: 2,
name: { first: 'Barney', last:  'Rubble' },
city: 'Bedrock', state: 'Stoneridge'
},
{ key: 3,
name: { first: 'Cliff',  last:  'Claven' },
city: 'Boston',  state: 'MA'
}
];
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='defaultValue' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    (Optional) The default value used <b>when a Record is being created by a {@link Ext.data.Reader Reader}</b> when the item referenced by the <tt>{@link Ext.data.Field#mapping mapping}</tt> does not exist in the data object (i.e. undefined). (defaults to "")
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='sortType' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    (Optional) A function which converts a Field's value to a comparable value in order to ensure correct sort ordering. Predefined functions are provided in {@link Ext.data.SortTypes}. A custom sort example:<pre><code>// current sort     after sort we want
// +-+------+          +-+------+
// |1|First |          |1|First |
// |2|Last  |          |3|Second|
// |3|Second|          |2|Last  |
// +-+------+          +-+------+

sortType: function(value) {
switch (value.toLowerCase()) // native toLowerCase():
{
case 'first': return 1;
case 'second': return 2;
default: return 3;
}
}
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='name'>
          <xs:annotation>
            <xs:documentation>
The name by which the field is referenced within the Record. This is referenced by, for example, the <tt>dataIndex</tt> property in column definition objects passed to {@link Ext.grid.ColumnModel}. <p>Note: In the simplest case, if no properties other than <tt>name</tt> are required, a field definition may consist of just a String for the field name.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='type'>
          <xs:annotation>
            <xs:documentation>
(Optional) The data type for conversion to displayable value if <tt>{@link Ext.data.Field#convert convert}</tt> has not been specified. Possible values are <div class="mdetail-params"><ul><li>auto (Default, implies no conversion)</li><li>string</li><li>int</li><li>float</li><li>boolean</li><li>date</li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='convert'>
          <xs:annotation>
            <xs:documentation>
(Optional) A function which converts the value provided by the Reader into an object that will be stored in the Record. It is passed the following parameters:<div class="mdetail-params"><ul><li><b>v</b> : Mixed<div class="sub-desc">The data value as read by the Reader, if undefined will use the configured <tt>{@link Ext.data.Field#defaultValue defaultValue}</tt>.</div></li><li><b>rec</b> : Mixed<div class="sub-desc">The data object containing the row as read by the Reader. Depending on the Reader type, this could be an Array ({@link Ext.data.ArrayReader ArrayReader}), an object ({@link Ext.data.JsonReader JsonReader}), or an XML element ({@link Ext.data.XMLReader XMLReader}).</div></li></ul></div><pre><code>// example of convert function
function fullName(v, record){
return record.name.last + ', ' + record.name.first;
}

function location(v, record){
return !record.city ? '' : (record.city + ', ' + record.state);
}

var Dude = Ext.data.Record.create([
{name: 'fullname',  convert: fullName},
{name: 'firstname', mapping: 'name.first'},
{name: 'lastname',  mapping: 'name.last'},
{name: 'city', defaultValue: 'homeless'},
'state',
{name: 'location',  convert: location}
]);

// create the data store
var store = new Ext.data.Store({
reader: new Ext.data.JsonReader(
{
idProperty: 'key',
root: 'daRoot',  
totalProperty: 'total'
},
Dude  // recordType
)
});

var myData = [
{ key: 1,
name: { first: 'Fat',    last:  'Albert' }
// notice no city, state provided in data object
},
{ key: 2,
name: { first: 'Barney', last:  'Rubble' },
city: 'Bedrock', state: 'Stoneridge'
},
{ key: 3,
name: { first: 'Cliff',  last:  'Claven' },
city: 'Boston',  state: 'MA'
}
];
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='dateFormat'>
          <xs:annotation>
            <xs:documentation>
(Optional) A format string for the {@link Date#parseDate Date.parseDate} function, or "timestamp" if the value provided by the Reader is a UNIX timestamp, or "time" if the value provided by the Reader is a javascript millisecond timestamp.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultValue'>
          <xs:annotation>
            <xs:documentation>
(Optional) The default value used <b>when a Record is being created by a {@link Ext.data.Reader Reader}</b> when the item referenced by the <tt>{@link Ext.data.Field#mapping mapping}</tt> does not exist in the data object (i.e. undefined). (defaults to "")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='mapping'>
          <xs:annotation>
            <xs:documentation>
<p>(Optional) A path expression for use by the {@link Ext.data.DataReader} implementation that is creating the {@link Ext.data.Record Record} to extract the Field value from the data object. If the path expression is the same as the field name, the mapping may be omitted.</p><p>The form of the mapping expression depends on the Reader being used.</p><div class="mdetail-params"><ul><li>{@link Ext.data.JsonReader}<div class="sub-desc">The mapping is a string containing the javascript expression to reference the data from an element of the data item's {@link Ext.data.JsonReader#root root} Array. Defaults to the field name.</div></li><li>{@link Ext.data.XmlReader}<div class="sub-desc">The mapping is an {@link Ext.DomQuery} path to the data item relative to the DOM element that represents the {@link Ext.data.XmlReader#record record}. Defaults to the field name.</div></li><li>{@link Ext.data.ArrayReader}<div class="sub-desc">The mapping is a number indicating the Array index of the field's value. Defaults to the field specification's Array position.</div></li></ul></div><p>If a more complex value extraction strategy is required, then configure the Field with a {@link #convert} function. This is passed the whole row object, and may interrogate it in whatever way is necessary in order to return the desired data.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='sortType'>
          <xs:annotation>
            <xs:documentation>
(Optional) A function which converts a Field's value to a comparable value in order to ensure correct sort ordering. Predefined functions are provided in {@link Ext.data.SortTypes}. A custom sort example:<pre><code>// current sort     after sort we want
// +-+------+          +-+------+
// |1|First |          |1|First |
// |2|Last  |          |3|Second|
// |3|Second|          |2|Last  |
// +-+------+          +-+------+

sortType: function(value) {
switch (value.toLowerCase()) // native toLowerCase():
{
case 'first': return 1;
case 'second': return 2;
default: return 3;
}
}
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='sortDir'>
          <xs:annotation>
            <xs:documentation>
(Optional) Initial direction to sort (<tt>"ASC"</tt> or <tt>"DESC"</tt>). Defaults to <tt>"ASC"</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowBlank'>
          <xs:annotation>
            <xs:documentation>
(Optional) Used for validating a {@link Ext.data.Record record}, defaults to <tt>true</tt>. An empty value here will cause {@link Ext.data.Record}.{@link Ext.data.Record#isValid isValid} to evaluate to <tt>false</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
  </xs:complexType>
  <xs:element id='datafield' name='datafield' type='ext:ext.data.Field'>
    <xs:annotation>
      <xs:documentation>
<p>This class encapsulates the field definition information specified in the field definition objects passed to {@link Ext.data.Record#create}.</p><p>Developers do not need to instantiate this class. Instances are created by {@link Ext.data.Record.create} and cached in the {@link Ext.data.Record#fields fields} property of the created Record constructor's <b>prototype.</b></p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.DataView'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
            <xs:element name='tpl' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The HTML fragment or an array of fragments that will make up the template used by this DataView. This should be specified in the same format expected by the constructor of {@link Ext.XTemplate}.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='store' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The {@link Ext.data.Store} to bind this DataView to.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='tpl'>
          <xs:annotation>
            <xs:documentation>
The HTML fragment or an array of fragments that will make up the template used by this DataView. This should be specified in the same format expected by the constructor of {@link Ext.XTemplate}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='store'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.data.Store} to bind this DataView to.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='itemSelector'>
          <xs:annotation>
            <xs:documentation>
<b>This is a required setting</b>. A simple CSS selector (e.g. <tt>div.some-class</tt> or <tt>span:first-child</tt>) that will be used to determine what nodes this DataView will be working with.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='multiSelect'>
          <xs:annotation>
            <xs:documentation>
True to allow selection of more than one item at a time, false to allow selection of only a single item at a time or no selection at all, depending on the value of {@link #singleSelect} (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='singleSelect'>
          <xs:annotation>
            <xs:documentation>
True to allow selection of exactly one item at a time, false to allow no selection at all (defaults to false). Note that if {@link #multiSelect} = true, this value will be ignored.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='simpleSelect'>
          <xs:annotation>
            <xs:documentation>
True to enable multiselection by clicking on multiple items without requiring the user to hold Shift or Ctrl, false to force the user to hold Ctrl or Shift to select more than on item (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='overClass'>
          <xs:annotation>
            <xs:documentation>
A CSS class to apply to each item in the view on mouseover (defaults to undefined).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='loadingText'>
          <xs:annotation>
            <xs:documentation>
A string to display during data load operations (defaults to undefined). If specified, this text will be displayed in a loading div and the view's contents will be cleared while loading, otherwise the view's contents will continue to display normally until the new data is loaded and the contents are replaced.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='selectedClass'>
          <xs:annotation>
            <xs:documentation>
A CSS class to apply to each selected item in the view (defaults to 'x-view-selected').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='emptyText'>
          <xs:annotation>
            <xs:documentation>
The text to display in the view when there is no data to display (defaults to '').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='deferEmptyText'>
          <xs:annotation>
            <xs:documentation>
True to defer emptyText being applied until the store's first load
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='trackOver'>
          <xs:annotation>
            <xs:documentation>
True to enable mouseenter and mouseleave events
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='dataview' name='dataview' type='ext:ext.DataView' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
A mechanism for displaying data using custom layout templates and formatting. DataView uses an {@link Ext.XTemplate} as its internal templating mechanism, and is bound to an {@link Ext.data.Store} so that as the data in the store changes the view is automatically updated to reflect the changes. The view also provides built-in behavior for many common events that can occur for its contained items including click, doubleclick, mouseover, mouseout, etc. as well as a built-in selection model. <b>In order to use these features, an {@link #itemSelector} config must be provided for the DataView to determine what nodes it will be working with.</b> <p>The example below binds a DataView to a {@link Ext.data.Store} and renders it into an {@link Ext.Panel}.</p><pre><code>var store = new Ext.data.JsonStore({
url: 'get-images.php',
root: 'images',
fields: [
'name', 'url',
{name:'size', type: 'float'},
{name:'lastmod', type:'date', dateFormat:'timestamp'}
]
});
store.load();

var tpl = new Ext.XTemplate(
'&lt;tpl for="."&gt;',
'&lt;div class="thumb-wrap" id="{name}"&gt;',
'&lt;div class="thumb"&gt;&lt;img src="{url}" title="{name}"&gt;&lt;/div&gt;',
'&lt;span class="x-editable"&gt;{shortName}&lt;/span&gt;&lt;/div&gt;',
'&lt;/tpl&gt;',
'&lt;div class="x-clear"&gt;&lt;/div&gt;'
);

var panel = new Ext.Panel({
id:'images-view',
frame:true,
width:535,
autoHeight:true,
collapsible:true,
layout:'fit',
title:'Simple DataView',

items: new Ext.DataView({
store: store,
tpl: tpl,
autoHeight:true,
multiSelect: true,
overClass:'x-view-over',
itemSelector:'div.thumb-wrap',
emptyText: 'No images to display'
})
});
panel.render(document.body);
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.grid.DateColumn'>
    <xs:complexContent>
      <xs:extension base='ext:ext.grid.Column'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:string' name='format'>
          <xs:annotation>
            <xs:documentation>
A formatting string as used by {@link Date#format} to format a Date for this Column (defaults to <tt>'m/d/Y'</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='datecolumn' name='datecolumn' type='ext:ext.grid.DateColumn' substitutionGroup='ext:gridcolumn'>
    <xs:annotation>
      <xs:documentation>
<p>A Column definition class which renders a passed date according to the default locale, or a configured {@link #format}. See the {@link Ext.grid.Column#xtype xtype} config option of {@link Ext.grid.Column} for more details.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.DateField'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.TriggerField'>
        <xs:sequence>
            <xs:element name='disabledDays' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of days to disable, 0 based (defaults to null). Some examples:<pre><code>// disable Sunday and Saturday:
disabledDays:  [0, 6]
// disable weekdays:
disabledDays: [1,2,3,4,5]
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='disabledDates' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of "dates" to disable, as strings. These strings will be used to build a dynamic regular expression so they are very powerful. Some examples:<pre><code>// disable these exact dates:
disabledDates: ["03/08/2003", "09/16/2003"]
// disable these days for every year:
disabledDates: ["03/08", "09/16"]
// only match the beginning (useful if you are using short years):
disabledDates: ["^03/08"]
// disable every day in March 2006:
disabledDates: ["03/../2006"]
// disable every day in every March:
disabledDates: ["^03"]
</code></pre>Note that the format of the dates included in the array should exactly match the {@link #format} config. In order to support regular expressions, if you are using a {@link #format date format} that has "." in it, you will have to escape the dot when restricting dates. For example: <tt>["03\\.08\\.03"]</tt>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='format'>
          <xs:annotation>
            <xs:documentation>
The default date format string which can be overriden for localization support. The format must be valid according to {@link Date#parseDate} (defaults to <tt>'m/d/Y'</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='altFormats'>
          <xs:annotation>
            <xs:documentation>
Multiple date formats separated by "<tt>|</tt>" to try when parsing a user input value and it does not match the defined format (defaults to <tt>'m/d/Y|n/j/Y|n/j/y|m/j/y|n/d/y|m/j/Y|n/d/Y|m-d-y|m-d-Y|m/d|m-d|md|mdy|mdY|d|Y-m-d'</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDaysText'>
          <xs:annotation>
            <xs:documentation>
The tooltip to display when the date falls on a disabled day (defaults to <tt>'Disabled'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDatesText'>
          <xs:annotation>
            <xs:documentation>
The tooltip text to display when the date falls on a disabled date (defaults to <tt>'Disabled'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='minText'>
          <xs:annotation>
            <xs:documentation>
The error text to display when the date in the cell is before <tt>{@link #minValue}</tt> (defaults to <tt>'The date in this field must be after {minValue}'</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxText'>
          <xs:annotation>
            <xs:documentation>
The error text to display when the date in the cell is after <tt>{@link #maxValue}</tt> (defaults to <tt>'The date in this field must be before {maxValue}'</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='showToday'>
          <xs:annotation>
            <xs:documentation>
<tt>false</tt> to hide the footer area of the DatePicker containing the Today button and disable the keyboard handler for spacebar that selects the current date (defaults to <tt>true</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='minValue'>
          <xs:annotation>
            <xs:documentation>
The minimum allowed date. Can be either a Javascript date object or a string date in a valid format (defaults to null).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxValue'>
          <xs:annotation>
            <xs:documentation>
The maximum allowed date. Can be either a Javascript date object or a string date in a valid format (defaults to null).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDays'>
          <xs:annotation>
            <xs:documentation>
An array of days to disable, 0 based (defaults to null). Some examples:<pre><code>// disable Sunday and Saturday:
disabledDays:  [0, 6]
// disable weekdays:
disabledDays: [1,2,3,4,5]
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDates'>
          <xs:annotation>
            <xs:documentation>
An array of "dates" to disable, as strings. These strings will be used to build a dynamic regular expression so they are very powerful. Some examples:<pre><code>// disable these exact dates:
disabledDates: ["03/08/2003", "09/16/2003"]
// disable these days for every year:
disabledDates: ["03/08", "09/16"]
// only match the beginning (useful if you are using short years):
disabledDates: ["^03/08"]
// disable every day in March 2006:
disabledDates: ["03/../2006"]
// disable every day in every March:
disabledDates: ["^03"]
</code></pre>Note that the format of the dates included in the array should exactly match the {@link #format} config. In order to support regular expressions, if you are using a {@link #format date format} that has "." in it, you will have to escape the dot when restricting dates. For example: <tt>["03\\.08\\.03"]</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='datefield' name='datefield' type='ext:ext.form.DateField' substitutionGroup='ext:trigger'>
    <xs:annotation>
      <xs:documentation>
Provides a date input field with a {@link Ext.DatePicker} dropdown and automatic date validation.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.DateMenu'>
    <xs:complexContent>
      <xs:extension base='ext:ext.menu.Menu'>
        <xs:sequence>
            <xs:element name='handler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Optional. A function that will handle the select event of this menu. The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>picker</code> : DatePicker<div class="sub-desc">The Ext.DatePicker.</div></li><li><code>date</code> : Date<div class="sub-desc">The selected date.</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='scope' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> function will be called. Defaults to this DateMenu instance.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='handler'>
          <xs:annotation>
            <xs:documentation>
Optional. A function that will handle the select event of this menu. The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>picker</code> : DatePicker<div class="sub-desc">The Ext.DatePicker.</div></li><li><code>date</code> : Date<div class="sub-desc">The selected date.</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scope'>
          <xs:annotation>
            <xs:documentation>
The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> function will be called. Defaults to this DateMenu instance.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideOnClick'>
          <xs:annotation>
            <xs:documentation>
False to continue showing the menu after a date is selected, defaults to true.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='pickerId'>
          <xs:annotation>
            <xs:documentation>
An id to assign to the underlying date picker. Defaults to <tt>null</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='datemenu' name='datemenu' type='ext:ext.menu.DateMenu' substitutionGroup='ext:menu'>
    <xs:annotation>
      <xs:documentation>
<p>A menu containing an {@link Ext.DatePicker} Component.</p><p>Notes:</p><div class="mdetail-params"><ul><li>Although not listed here, the <b>constructor</b> for this class accepts all of the configuration options of <b>{@link Ext.DatePicker}</b>.</li><li>If subclassing DateMenu, any configuration options for the DatePicker must be applied to the <tt><b>initialConfig</b></tt> property of the DateMenu. Applying {@link Ext.DatePicker DatePicker} configuration settings to <b><tt>this</tt></b> will <b>not</b> affect the DatePicker's configuration.</li></ul></div>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.DatePicker'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Component'>
        <xs:sequence>
            <xs:element name='handler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Optional. A function that will handle the select event of this picker. The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>picker</code> : DatePicker<div class="sub-desc">The Ext.DatePicker.</div></li><li><code>date</code> : Date<div class="sub-desc">The selected date.</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='scope' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> function will be called. Defaults to this DatePicker instance.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='monthNames' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of textual month names which can be overriden for localization support (defaults to Date.monthNames)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='dayNames' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of textual day names which can be overriden for localization support (defaults to Date.dayNames)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='disabledDays' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of days to disable, 0-based. For example, [0, 6] disables Sunday and Saturday (defaults to null).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='disabledDatesRE' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    JavaScript regular expression used to disable a pattern of dates (defaults to null). The {@link #disabledDates} config will generate this regex internally, but if you specify disabledDatesRE it will take precedence over the disabledDates value.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='disabledDates' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of 'dates' to disable, as strings. These strings will be used to build a dynamic regular expression so they are very powerful. Some examples: <ul><li>['03/08/2003', '09/16/2003'] would disable those exact dates</li><li>['03/08', '09/16'] would disable those days for every year</li><li>['^03/08'] would only match the beginning (useful if you are using short years)</li><li>['03/../2006'] would disable every day in March 2006</li><li>['^03'] would disable every day in every March</li></ul>Note that the format of the dates included in the array should exactly match the {@link #format} config. In order to support regular expressions, if you are using a date format that has '.' in it, you will have to escape the dot when restricting dates. For example: ['03\\.08\\.03'].
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='todayText'>
          <xs:annotation>
            <xs:documentation>
The text to display on the button that selects the current date (defaults to <tt>'Today'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='okText'>
          <xs:annotation>
            <xs:documentation>
The text to display on the ok button (defaults to <tt>'Â OKÂ '</tt> to give the user extra clicking room)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='cancelText'>
          <xs:annotation>
            <xs:documentation>
The text to display on the cancel button (defaults to <tt>'Cancel'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='handler'>
          <xs:annotation>
            <xs:documentation>
Optional. A function that will handle the select event of this picker. The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>picker</code> : DatePicker<div class="sub-desc">The Ext.DatePicker.</div></li><li><code>date</code> : Date<div class="sub-desc">The selected date.</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scope'>
          <xs:annotation>
            <xs:documentation>
The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> function will be called. Defaults to this DatePicker instance.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='todayTip'>
          <xs:annotation>
            <xs:documentation>
The tooltip to display for the button that selects the current date (defaults to <tt>'{current date} (Spacebar)'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='minText'>
          <xs:annotation>
            <xs:documentation>
The error text to display if the minDate validation fails (defaults to <tt>'This date is before the minimum date'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxText'>
          <xs:annotation>
            <xs:documentation>
The error text to display if the maxDate validation fails (defaults to <tt>'This date is after the maximum date'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='format'>
          <xs:annotation>
            <xs:documentation>
The default date format string which can be overriden for localization support. The format must be valid according to {@link Date#parseDate} (defaults to <tt>'m/d/y'</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDaysText'>
          <xs:annotation>
            <xs:documentation>
The tooltip to display when the date falls on a disabled day (defaults to <tt>'Disabled'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDatesText'>
          <xs:annotation>
            <xs:documentation>
The tooltip text to display when the date falls on a disabled date (defaults to <tt>'Disabled'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='monthNames'>
          <xs:annotation>
            <xs:documentation>
An array of textual month names which can be overriden for localization support (defaults to Date.monthNames)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='dayNames'>
          <xs:annotation>
            <xs:documentation>
An array of textual day names which can be overriden for localization support (defaults to Date.dayNames)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='nextText'>
          <xs:annotation>
            <xs:documentation>
The next month navigation button tooltip (defaults to <tt>'Next Month (Control+Right)'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='prevText'>
          <xs:annotation>
            <xs:documentation>
The previous month navigation button tooltip (defaults to <tt>'Previous Month (Control+Left)'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='monthYearText'>
          <xs:annotation>
            <xs:documentation>
The header month selector tooltip (defaults to <tt>'Choose a month (Control+Up/Down to move years)'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='startDay'>
          <xs:annotation>
            <xs:documentation>
Day index at which the week should begin, 0-based (defaults to 0, which is Sunday)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='showToday'>
          <xs:annotation>
            <xs:documentation>
False to hide the footer area containing the Today button and disable the keyboard handler for spacebar that selects the current date (defaults to <tt>true</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:date' name='minDate'>
          <xs:annotation>
            <xs:documentation>
Minimum allowable date (JavaScript date object, defaults to null)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:date' name='maxDate'>
          <xs:annotation>
            <xs:documentation>
Maximum allowable date (JavaScript date object, defaults to null)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDays'>
          <xs:annotation>
            <xs:documentation>
An array of days to disable, 0-based. For example, [0, 6] disables Sunday and Saturday (defaults to null).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDatesRE'>
          <xs:annotation>
            <xs:documentation>
JavaScript regular expression used to disable a pattern of dates (defaults to null). The {@link #disabledDates} config will generate this regex internally, but if you specify disabledDatesRE it will take precedence over the disabledDates value.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDates'>
          <xs:annotation>
            <xs:documentation>
An array of 'dates' to disable, as strings. These strings will be used to build a dynamic regular expression so they are very powerful. Some examples: <ul><li>['03/08/2003', '09/16/2003'] would disable those exact dates</li><li>['03/08', '09/16'] would disable those days for every year</li><li>['^03/08'] would only match the beginning (useful if you are using short years)</li><li>['03/../2006'] would disable every day in March 2006</li><li>['^03'] would disable every day in every March</li></ul>Note that the format of the dates included in the array should exactly match the {@link #format} config. In order to support regular expressions, if you are using a date format that has '.' in it, you will have to escape the dot when restricting dates. For example: ['03\\.08\\.03'].
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='datepicker' name='datepicker' type='ext:ext.DatePicker' substitutionGroup='ext:component'>
    <xs:annotation>
      <xs:documentation>
Simple date picker class.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.data.DirectStore'>
    <xs:complexContent>
      <xs:extension base='ext:ext.data.Store'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='directstore' name='directstore' type='ext:ext.data.DirectStore' substitutionGroup='ext:store'>
    <xs:annotation>
      <xs:documentation>
<p>Small helper class to create an {@link Ext.data.Store} configured with an {@link Ext.data.DirectProxy} and {@link Ext.data.JsonReader} to make interacting with an {@link Ext.Direct} Server-side {@link Ext.direct.Provider Provider} easier. To create a different proxy/reader combination create a basic {@link Ext.data.Store} configured as needed.</p><p><b>*Note:</b> Although they are not listed, this class inherits all of the config options of:</p><div><ul class="mdetail-params"><li><b>{@link Ext.data.Store Store}</b></li><li><b>{@link Ext.data.JsonReader JsonReader}</b></li><li style="list-style: none"><div class="sub-desc"><ul class="mdetail-params"><li><tt><b>{@link Ext.data.JsonReader#root root}</b></tt></li><li><tt><b>{@link Ext.data.JsonReader#idProperty idProperty}</b></tt></li><li><tt><b>{@link Ext.data.JsonReader#totalProperty totalProperty}</b></tt></li></ul></div></li><li><b>{@link Ext.data.DirectProxy DirectProxy}</b></li><li style="list-style: none"><div class="sub-desc"><ul class="mdetail-params"><li><tt><b>{@link Ext.data.DirectProxy#directFn directFn}</b></tt></li><li><tt><b>{@link Ext.data.DirectProxy#paramOrder paramOrder}</b></tt></li><li><tt><b>{@link Ext.data.DirectProxy#paramsAsHash paramsAsHash}</b></tt></li></ul></div></li></ul></div>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.DisplayField'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Field'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='htmlEncode'>
          <xs:annotation>
            <xs:documentation>
<tt>false</tt> to skip HTML-encoding the text when rendering it (defaults to <tt>false</tt>). This might be useful if you want to include tags in the field's innerHTML rather than rendering them as string literals per the default logic.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='displayfield' name='displayfield' type='ext:ext.form.DisplayField' substitutionGroup='ext:field'>
    <xs:annotation>
      <xs:documentation>
A display-only text field which is not validated and not submitted.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Editor'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Component'>
        <xs:sequence>
            <xs:element name='field' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The Field object (or descendant) or config object for field
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='value' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The data value of the underlying field (defaults to "")
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='field'>
          <xs:annotation>
            <xs:documentation>
The Field object (or descendant) or config object for field
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowBlur'>
          <xs:annotation>
            <xs:documentation>
True to {@link #completeEdit complete the editing process} if in edit mode when the field is blurred. Defaults to <tt>false</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='autoSize'>
          <xs:annotation>
            <xs:documentation>
True for the editor to automatically adopt the size of the underlying field, "width" to adopt the width only, or "height" to adopt the height only, "none" to always use the field dimensions. (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='revertInvalid'>
          <xs:annotation>
            <xs:documentation>
True to automatically revert the field value and cancel the edit when the user completes an edit and the field validation fails (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='ignoreNoChange'>
          <xs:annotation>
            <xs:documentation>
True to skip the edit completion process (no save, no events fired) if the user completes an edit and the value has not changed (defaults to false). Applies only to string values - edits for other data types will never be ignored.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideEl'>
          <xs:annotation>
            <xs:documentation>
False to keep the bound element visible while the editor is displayed (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='value'>
          <xs:annotation>
            <xs:documentation>
The data value of the underlying field (defaults to "")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='alignment'>
          <xs:annotation>
            <xs:documentation>
The position to align to (see {@link Ext.Element#alignTo} for more details, defaults to "c-c?").
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='shadow'>
          <xs:annotation>
            <xs:documentation>
"sides" for sides/bottom only, "frame" for 4-way shadow, and "drop" for bottom-right shadow (defaults to "frame")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='constrain'>
          <xs:annotation>
            <xs:documentation>
True to constrain the editor to the viewport
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='swallowKeys'>
          <xs:annotation>
            <xs:documentation>
Handle the keydown/keypress events so they don't propagate (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='completeOnEnter'>
          <xs:annotation>
            <xs:documentation>
True to complete the edit when the enter key is pressed. Defaults to <tt>true</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='cancelOnEsc'>
          <xs:annotation>
            <xs:documentation>
True to cancel the edit when the escape key is pressed. Defaults to <tt>true</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='updateEl'>
          <xs:annotation>
            <xs:documentation>
True to update the innerHTML of the bound element when the update completes (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='editor' name='editor' type='ext:ext.Editor' substitutionGroup='ext:component'>
    <xs:annotation>
      <xs:documentation>
A base editor field that handles displaying/hiding on demand and has some built-in sizing and event handling logic.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.grid.EditorGridPanel'>
    <xs:complexContent>
      <xs:extension base='ext:ext.grid.GridPanel'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:int' name='clicksToEdit'>
          <xs:annotation>
            <xs:documentation>
<p>The number of clicks on a cell required to display the cell's editor (defaults to 2).</p><p>Setting this option to 'auto' means that mousedown <i>on the selected cell</i> starts editing that cell.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='forceValidation'>
          <xs:annotation>
            <xs:documentation>
True to force validation even if the value is unmodified (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoEncode'>
          <xs:annotation>
            <xs:documentation>
True to automatically HTML encode and decode values pre and post edit (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='editorgrid' name='editorgrid' type='ext:ext.grid.EditorGridPanel' substitutionGroup='ext:grid'>
    <xs:annotation>
      <xs:documentation>
<p>This class extends the {@link Ext.grid.GridPanel GridPanel Class} to provide cell editing on selected {@link Ext.grid.Column columns}. The editable columns are specified by providing an {@link Ext.grid.ColumnModel#editor editor} in the {@link Ext.grid.Column column configuration}.</p><p>Editability of columns may be controlled programatically by inserting an implementation of {@link Ext.grid.ColumnModel#isCellEditable isCellEditable} into the {@link Ext.grid.ColumnModel ColumnModel}.</p><p>Editing is performed on the value of the <i>field</i> specified by the column's <tt>{@link Ext.grid.ColumnModel#dataIndex dataIndex}</tt> in the backing {@link Ext.data.Store Store} (so if you are using a {@link Ext.grid.ColumnModel#setRenderer renderer} in order to display transformed data, this must be accounted for).</p><p>If a value-to-description mapping is used to render a column, then a {@link Ext.form.Field#ComboBox ComboBox} which uses the same {@link Ext.form.Field#valueField value}-to-{@link Ext.form.Field#displayFieldField description} mapping would be an appropriate editor.</p>If there is a more complex mismatch between the visible data in the grid, and the editable data in the {@link Edt.data.Store Store}, then code to transform the data both before and after editing can be injected using the {@link #beforeedit} and {@link #afteredit} events.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.Field'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
            <xs:element name='value' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A value to initialize this field with (defaults to undefined).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='autoCreate' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A {@link Ext.DomHelper DomHelper} element spec, or true for a default element spec. Used to create the {@link Ext.Component#getEl Element} which will encapsulate this Component. See <tt>{@link Ext.Component#autoEl autoEl}</tt> for details. Defaults to:</p><pre><code>{tag: 'input', type: 'text', size: '20', autocomplete: 'off'}</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='inputType'>
          <xs:annotation>
            <xs:documentation>
The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note that if you use <tt>inputType:'file'</tt>, {@link #emptyText} is not supported and should be avoided.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='tabIndex'>
          <xs:annotation>
            <xs:documentation>
The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo (defaults to undefined).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='value'>
          <xs:annotation>
            <xs:documentation>
A value to initialize this field with (defaults to undefined).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='name'>
          <xs:annotation>
            <xs:documentation>
The field's HTML name attribute (defaults to ''). <b>Note</b>: this property must be set if this field is to be automatically included with {@link Ext.form.BasicForm#submit form submit()}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='invalidClass'>
          <xs:annotation>
            <xs:documentation>
The CSS class to use when marking a field invalid (defaults to 'x-form-invalid')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='invalidText'>
          <xs:annotation>
            <xs:documentation>
The error text to use when marking a field invalid and no message is provided (defaults to 'The value in this field is invalid')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='focusClass'>
          <xs:annotation>
            <xs:documentation>
The CSS class to use when the field receives focus (defaults to 'x-form-focus')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='preventMark'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to disable {@link #markInvalid marking the field invalid}. Defaults to <tt>false</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='validationEvent'>
          <xs:annotation>
            <xs:documentation>
The event that should initiate field validation. Set to false to disable automatic validation (defaults to 'keyup').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='validateOnBlur'>
          <xs:annotation>
            <xs:documentation>
Whether the field should validate when it loses focus (defaults to true).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='validationDelay'>
          <xs:annotation>
            <xs:documentation>
The length of time in milliseconds after user input begins until validation is initiated (defaults to 250)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='autoCreate'>
          <xs:annotation>
            <xs:documentation>
<p>A {@link Ext.DomHelper DomHelper} element spec, or true for a default element spec. Used to create the {@link Ext.Component#getEl Element} which will encapsulate this Component. See <tt>{@link Ext.Component#autoEl autoEl}</tt> for details. Defaults to:</p><pre><code>{tag: 'input', type: 'text', size: '20', autocomplete: 'off'}</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='fieldClass'>
          <xs:annotation>
            <xs:documentation>
The default CSS class for the field (defaults to 'x-form-field')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='msgTarget'>
          <xs:annotation>
            <xs:documentation>
The location where error text should display. Should be one of the following values (defaults to 'qtip'): <pre>Value         Description
-----------   ----------------------------------------------------------------------
qtip          Display a quick tip when the user hovers over the field
title         Display a default browser title attribute popup
under         Add a block div beneath the field containing the error text
side          Add an error icon to the right of the field with a popup on hover
[element id]  Add the error text directly to the innerHTML of the specified element
</pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='msgFx'>
          <xs:annotation>
            <xs:documentation>
<b>Experimental</b> The effect used when displaying a validation message under the field (defaults to 'normal').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='readOnly'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to mark the field as readOnly in HTML (defaults to <tt>false</tt>). <br/><p><b>Note</b>: this only sets the element's readOnly DOM attribute. Setting <code>readOnly=true</code>, for example, will not disable triggering a ComboBox or DateField; it gives you the option of forcing the user to choose via the trigger without typing in the text box. To hide the trigger use <code>{@link Ext.form.TriggerField#hideTrigger hideTrigger}</code>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='field' name='field' type='ext:ext.form.Field' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
Base class for form fields that provides default event handling, sizing, value handling and other functionality.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.FieldSet'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:sequence>
            <xs:element name='checkboxToggle' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <tt>true</tt> to render a checkbox into the fieldset frame just in front of the legend to expand/collapse the fieldset when the checkbox is toggled. (defaults to <tt>false</tt>). <p>A {@link Ext.DomHelper DomHelper} element spec may also be specified to create the checkbox. If <tt>true</tt> is specified, the default DomHelper config object used to create the element is:</p><pre><code>{tag: 'input', type: 'checkbox', name: this.checkboxName || this.id+'-checkbox'}
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='checkboxToggle'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to render a checkbox into the fieldset frame just in front of the legend to expand/collapse the fieldset when the checkbox is toggled. (defaults to <tt>false</tt>). <p>A {@link Ext.DomHelper DomHelper} element spec may also be specified to create the checkbox. If <tt>true</tt> is specified, the default DomHelper config object used to create the element is:</p><pre><code>{tag: 'input', type: 'checkbox', name: this.checkboxName || this.id+'-checkbox'}
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='checkboxName'>
          <xs:annotation>
            <xs:documentation>
The name to assign to the fieldset's checkbox if <tt>{@link #checkboxToggle} = true</tt> (defaults to <tt>'[checkbox id]-checkbox'</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='labelWidth'>
          <xs:annotation>
            <xs:documentation>
The width of labels. This property cascades to child containers.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='fieldset' name='fieldset' type='ext:ext.form.FieldSet' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>
Standard container used for grouping items within a {@link Ext.form.FormPanel form}. <pre><code>var form = new Ext.FormPanel({
title: 'Simple Form with FieldSets',
labelWidth: 75, // label settings here cascade unless overridden
url: 'save-form.php',
frame:true,
bodyStyle:'padding:5px 5px 0',
width: 700,
renderTo: document.body,
layout:'column', // arrange items in columns
defaults: {      // defaults applied to items
layout: 'form',
border: false,
bodyStyle: 'padding:4px'
},
items: [{
// Fieldset in Column 1
xtype:'fieldset',
columnWidth: 0.5,
title: 'Fieldset 1',
collapsible: true,
autoHeight:true,
defaults: {
anchor: '-20' // leave room for error icon
},
defaultType: 'textfield',
items :[{
fieldLabel: 'Field 1'
}, {
fieldLabel: 'Field 2'
}, {
fieldLabel: 'Field 3'
}
]
},{
// Fieldset in Column 2 - Panel inside
xtype:'fieldset',
title: 'Show Panel', // title, header, or checkboxToggle creates fieldset header
autoHeight:true,
columnWidth: 0.5,
checkboxToggle: true,
collapsed: true, // fieldset initially collapsed
layout:'anchor',
items :[{
xtype: 'panel',
anchor: '100%',
title: 'Panel inside a fieldset',
frame: true,
height: 100
}]
}]
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.FlashComponent'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
            <xs:element name='flashVars' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A set of key value pairs to be passed to the flash object as flash variables. Defaults to <tt>undefined</tt>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='flashParams' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A set of key value pairs to be passed to the flash object as parameters. Possible parameters can be found here: http://kb2.adobe.com/cps/127/tn_12701.html Defaults to <tt>undefined</tt>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='flashVersion'>
          <xs:annotation>
            <xs:documentation>
Indicates the version the flash content was published for. Defaults to <tt>'9.0.45'</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='backgroundColor'>
          <xs:annotation>
            <xs:documentation>
The background color of the chart. Defaults to <tt>'#ffffff'</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='wmode'>
          <xs:annotation>
            <xs:documentation>
The wmode of the flash object. This can be used to control layering. Defaults to <tt>'opaque'</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='flashVars'>
          <xs:annotation>
            <xs:documentation>
A set of key value pairs to be passed to the flash object as flash variables. Defaults to <tt>undefined</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='flashParams'>
          <xs:annotation>
            <xs:documentation>
A set of key value pairs to be passed to the flash object as parameters. Possible parameters can be found here: http://kb2.adobe.com/cps/127/tn_12701.html Defaults to <tt>undefined</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='url'>
          <xs:annotation>
            <xs:documentation>
The URL of the chart to include. Defaults to <tt>undefined</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='expressInstall'>
          <xs:annotation>
            <xs:documentation>
True to prompt the user to install flash if not installed. Note that this uses Ext.FlashComponent.EXPRESS_INSTALL_URL, which should be set to the local resource. Defaults to <tt>false</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='flash' name='flash' type='ext:ext.FlashComponent' substitutionGroup='ext:box'>
  </xs:element>
  <xs:complexType name='ext.form.FormPanel'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:string' name='formId'>
          <xs:annotation>
            <xs:documentation>
(optional) The id of the FORM tag (defaults to an auto-generated id).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideLabels'>
          <xs:annotation>
            <xs:documentation>
<p><tt>true</tt> to hide field labels by default (sets <tt>display:none</tt>). Defaults to <tt>false</tt>.</p><p>Also see {@link Ext.Component}.<tt>{@link Ext.Component#hideLabel hideLabel}</tt>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='labelPad'>
          <xs:annotation>
            <xs:documentation>
The default padding in pixels for field labels (defaults to <tt>5</tt>). <tt>labelPad</tt> only applies if <tt>{@link #labelWidth}</tt> is also specified, otherwise it will be ignored.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='labelWidth'>
          <xs:annotation>
            <xs:documentation>
The width of labels in pixels. This property cascades to child containers and can be overridden on any child container (e.g., a fieldset can specify a different <tt>labelWidth</tt> for its fields) (defaults to <tt>100</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='labelAlign'>
          <xs:annotation>
            <xs:documentation>
The label alignment value used for the <tt>text-align</tt> specification for the <b>container</b>. Valid values are <tt>"left</tt>", <tt>"top"</tt> or <tt>"right"</tt> (defaults to <tt>"left"</tt>). This property cascades to child <b>containers</b> and can be overridden on any child <b>container</b> (e.g., a fieldset can specify a different <tt>labelAlign</tt> for its fields).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='monitorValid'>
          <xs:annotation>
            <xs:documentation>
If <tt>true</tt>, the form monitors its valid state <b>client-side</b> and regularly fires the {@link #clientvalidation} event passing that state.<br/><p>When monitoring valid state, the FormPanel enables/disables any of its configured {@link #buttons} which have been configured with <code>formBind: true</code> depending on whether the {@link Ext.form.BasicForm#isValid form is valid} or not. Defaults to <tt>false</tt></p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='monitorPoll'>
          <xs:annotation>
            <xs:documentation>
The milliseconds to poll valid state, ignored if monitorValid is not true (defaults to 200)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='form' name='form' type='ext:ext.form.FormPanel' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>
<p>Standard form container.</p><p style="font-weight: bold"><u>Layout</u></p><p>By default, FormPanel is configured with <tt>layout:'form'</tt> to use an {@link Ext.layout.FormLayout} layout manager, which styles and renders fields and labels correctly. When nesting additional Containers within a FormPanel, you should ensure that any descendant Containers which host input Fields use the {@link Ext.layout.FormLayout} layout manager.</p><p style="font-weight: bold"><u>BasicForm</u></p><p>Although <b>not listed</b> as configuration options of FormPanel, the FormPanel class accepts all of the config options required to configure its internal {@link Ext.form.BasicForm} for:</p><div class="mdetail-params"><ul><li>{@link Ext.form.BasicForm#fileUpload file uploads}</li><li>functionality for {@link Ext.form.BasicForm#doAction loading, validating and submitting} the form</li></ul></div><p><b>Note</b>: If subclassing FormPanel, any configuration options for the BasicForm must be applied to the <tt><b>initialConfig</b></tt> property of the FormPanel. Applying {@link Ext.form.BasicForm BasicForm} configuration settings to <b><tt>this</tt></b> will <b>not</b> affect the BasicForm's configuration.</p><p style="font-weight: bold"><u>Form Validation</u></p><p>For information on form validation see the following:</p><div class="mdetail-params"><ul><li>{@link Ext.form.TextField}</li><li>{@link Ext.form.VTypes}</li><li>{@link Ext.form.BasicForm#doAction BasicForm.doAction <b>clientValidation</b> notes}</li><li><tt>{@link Ext.form.FormPanel#monitorValid monitorValid}</tt></li></ul></div><p style="font-weight: bold"><u>Form Submission</u></p><p>By default, Ext Forms are submitted through Ajax, using {@link Ext.form.Action}. To enable normal browser submission of the {@link Ext.form.BasicForm BasicForm} contained in this FormPanel, see the <tt><b>{@link Ext.form.BasicForm#standardSubmit standardSubmit}</b></tt> option.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.grid.GridPanel'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:sequence>
            <xs:element name='cm' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Shorthand for <tt>{@link #colModel}</tt>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='colModel' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The {@link Ext.grid.ColumnModel} to use when rendering the grid (required).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='columns' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of {@link Ext.grid.Column columns} to auto create a {@link Ext.grid.ColumnModel}. The ColumnModel may be explicitly created via the <tt>{@link #colModel}</tt> configuration property.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='loadMask' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An {@link Ext.LoadMask} config or true to mask the grid while loading. Defaults to <code>false</code>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='sm' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Shorthand for <tt>{@link #selModel}</tt>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='selModel' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Any subclass of {@link Ext.grid.AbstractSelectionModel} that will provide the selection model for the grid (defaults to {@link Ext.grid.RowSelectionModel} if not specified).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='store' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The {@link Ext.data.Store} the grid should use as its data source (required).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='view' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The {@link Ext.grid.GridView} used by the grid. This can be set before a call to {@link Ext.Component#render render()}.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='viewConfig' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A config object that will be applied to the grid's UI view. Any of the config options available for {@link Ext.grid.GridView} can be specified here. This option is ignored if <tt>{@link #view}</tt> is specified.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='autoExpandColumn'>
          <xs:annotation>
            <xs:documentation>
<p>The <tt>{@link Ext.grid.Column#id id}</tt> of a {@link Ext.grid.Column column} in this grid that should expand to fill unused space. This value specified here can not be <tt>0</tt>.</p><br/><p><b>Note</b>: If the Grid's {@link Ext.grid.GridView view} is configured with <tt>{@link Ext.grid.GridView#forceFit forceFit}=true</tt> the <tt>autoExpandColumn</tt> is ignored. See {@link Ext.grid.Column}.<tt>{@link Ext.grid.Column#width width}</tt> for additional details.</p><p>See <tt>{@link #autoExpandMax}</tt> and <tt>{@link #autoExpandMin}</tt> also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='autoExpandMax'>
          <xs:annotation>
            <xs:documentation>
The maximum width the <tt>{@link #autoExpandColumn}</tt> can have (if enabled). Defaults to <tt>1000</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='autoExpandMin'>
          <xs:annotation>
            <xs:documentation>
The minimum width the <tt>{@link #autoExpandColumn}</tt> can have (if enabled). Defaults to <tt>50</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='columnLines'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to add css for column separation lines. Default is <tt>false</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='cm'>
          <xs:annotation>
            <xs:documentation>
Shorthand for <tt>{@link #colModel}</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='colModel'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.grid.ColumnModel} to use when rendering the grid (required).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='columns'>
          <xs:annotation>
            <xs:documentation>
An array of {@link Ext.grid.Column columns} to auto create a {@link Ext.grid.ColumnModel}. The ColumnModel may be explicitly created via the <tt>{@link #colModel}</tt> configuration property.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='ddGroup'>
          <xs:annotation>
            <xs:documentation>
The DD group this GridPanel belongs to. Defaults to <tt>'GridDD'</tt> if not specified.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='ddText'>
          <xs:annotation>
            <xs:documentation>
Configures the text in the drag proxy. Defaults to: <pre><code>ddText : '{0} selected row{1}'
</code></pre><tt>{0}</tt> is replaced with the number of selected rows.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='deferRowRender'>
          <xs:annotation>
            <xs:documentation>
<p>Defaults to <tt>true</tt> to enable deferred row rendering.</p><p>This allows the GridPanel to be initially rendered empty, with the expensive update of the row structure deferred so that layouts with GridPanels appear more quickly.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='disableSelection'>
          <xs:annotation>
            <xs:documentation>
<p><tt>true</tt> to disable selections in the grid. Defaults to <tt>false</tt>.</p><p>Ignored if a {@link #selModel SelectionModel} is specified.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableColumnResize'>
          <xs:annotation>
            <xs:documentation>
<tt>false</tt> to turn off column resizing for the whole grid. Defaults to <tt>true</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableColumnHide'>
          <xs:annotation>
            <xs:documentation>
Defaults to <tt>true</tt> to enable {@link Ext.grid.Column#hidden hiding of columns} with the {@link #enableHdMenu header menu}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableColumnMove'>
          <xs:annotation>
            <xs:documentation>
Defaults to <tt>true</tt> to enable drag and drop reorder of columns. <tt>false</tt> to turn off column reordering via drag drop.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableDragDrop'>
          <xs:annotation>
            <xs:documentation>
<p>Enables dragging of the selected rows of the GridPanel. Defaults to <tt>false</tt>.</p><p>Setting this to <b><tt>true</tt></b> causes this GridPanel's {@link #getView GridView} to create an instance of {@link Ext.grid.GridDragZone}. <b>Note</b>: this is available only <b>after</b> the Grid has been rendered as the GridView's <tt>{@link Ext.grid.GridView#dragZone dragZone}</tt> property.</p><p>A cooperating {@link Ext.dd.DropZone DropZone} must be created who's implementations of {@link Ext.dd.DropZone#onNodeEnter onNodeEnter}, {@link Ext.dd.DropZone#onNodeOver onNodeOver}, {@link Ext.dd.DropZone#onNodeOut onNodeOut} and {@link Ext.dd.DropZone#onNodeDrop onNodeDrop} are able to process the {@link Ext.grid.GridDragZone#getDragData data} which is provided.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableHdMenu'>
          <xs:annotation>
            <xs:documentation>
Defaults to <tt>true</tt> to enable the drop down button for menu in the headers.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideHeaders'>
          <xs:annotation>
            <xs:documentation>
True to hide the grid's header. Defaults to <code>false</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='loadMask'>
          <xs:annotation>
            <xs:documentation>
An {@link Ext.LoadMask} config or true to mask the grid while loading. Defaults to <code>false</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxHeight'>
          <xs:annotation>
            <xs:documentation>
Sets the maximum height of the grid - ignored if <tt>autoHeight</tt> is not on.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minColumnWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width a column can be resized to. Defaults to <tt>25</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='sm'>
          <xs:annotation>
            <xs:documentation>
Shorthand for <tt>{@link #selModel}</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='selModel'>
          <xs:annotation>
            <xs:documentation>
Any subclass of {@link Ext.grid.AbstractSelectionModel} that will provide the selection model for the grid (defaults to {@link Ext.grid.RowSelectionModel} if not specified).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='store'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.data.Store} the grid should use as its data source (required).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='stripeRows'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to stripe the rows. Default is <tt>false</tt>. <p>This causes the CSS class <tt><b>x-grid3-row-alt</b></tt> to be added to alternate rows of the grid. A default CSS rule is provided which sets a background colour, but you can override this with a rule which either overrides the <b>background-color</b> style using the '!important' modifier, or which uses a CSS selector of higher specificity.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='trackMouseOver'>
          <xs:annotation>
            <xs:documentation>
True to highlight rows when the mouse is over. Default is <tt>true</tt> for GridPanel, but <tt>false</tt> for EditorGridPanel.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='view'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.grid.GridView} used by the grid. This can be set before a call to {@link Ext.Component#render render()}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='viewConfig'>
          <xs:annotation>
            <xs:documentation>
A config object that will be applied to the grid's UI view. Any of the config options available for {@link Ext.grid.GridView} can be specified here. This option is ignored if <tt>{@link #view}</tt> is specified.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='grid' name='grid' type='ext:ext.grid.GridPanel' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>
<p>This class represents the primary interface of a component based grid control to represent data in a tabular format of rows and columns. The GridPanel is composed of the following:</p><div class="mdetail-params"><ul><li><b>{@link Ext.data.Store Store}</b> : The Model holding the data records (rows)</li><li><b>{@link Ext.grid.ColumnModel Column model}</b> : Column makeup</li><li><b>{@link Ext.grid.GridView View}</b> : Encapsulates the user interface</li><li><b>{@link Ext.grid.AbstractSelectionModel selection model}</b> : Selection behavior</li></ul></div><p>Example usage:</p><pre><code>var grid = new Ext.grid.GridPanel({
{@link #store}: new {@link Ext.data.Store}({
{@link Ext.data.Store#autoDestroy autoDestroy}: true,
{@link Ext.data.Store#reader reader}: reader,
{@link Ext.data.Store#data data}: xg.dummyData
}),
{@link #colModel}: new {@link Ext.grid.ColumnModel}({
{@link Ext.grid.ColumnModel#defaults defaults}: {
width: 120,
sortable: true
},
{@link Ext.grid.ColumnModel#columns columns}: [
{id: 'company', header: 'Company', width: 200, sortable: true, dataIndex: 'company'},
{header: 'Price', renderer: Ext.util.Format.usMoney, dataIndex: 'price'},
{header: 'Change', dataIndex: 'change'},
{header: '% Change', dataIndex: 'pctChange'},
// instead of specifying renderer: Ext.util.Format.dateRenderer('m/d/Y') use xtype
{
header: 'Last Updated', width: 135, dataIndex: 'lastChange',
xtype: 'datecolumn', format: 'M d, Y'
}
],
}),
{@link #viewConfig}: {
{@link Ext.grid.GridView#forceFit forceFit}: true,

//      Return CSS class to apply to rows depending upon data values
{@link Ext.grid.GridView#getRowClass getRowClass}: function(record, index) {
var c = record.{@link Ext.data.Record#get get}('change');
if (c &lt; 0) {
return 'price-fall';
} else if (c &gt; 0) {
return 'price-rise';
}
}
},
{@link #sm}: new Ext.grid.RowSelectionModel({singleSelect:true}),
width: 600,
height: 300,
frame: true,
title: 'Framed with Row Selection and Horizontal Scrolling',
iconCls: 'icon-grid'
});
</code></pre><p style="font-weight: bold"><u>Notes:</u></p><div class="mdetail-params"><ul><li>Although this class inherits many configuration options from base classes, some of them (such as autoScroll, autoWidth, layout, items, etc) are not used by this class, and will have no effect.</li><li>A grid <b>requires</b> a width in which to scroll its columns, and a height in which to scroll its rows. These dimensions can either be set explicitly through the <tt>{@link Ext.BoxComponent#height height}</tt> and <tt>{@link Ext.BoxComponent#width width}</tt> configuration options or implicitly set by using the grid as a child item of a {@link Ext.Container Container} which will have a {@link Ext.Container#layout layout manager} provide the sizing of its child items (for example the Container of the Grid may specify <tt>{@link Ext.Container#layout layout}:'fit'</tt>).</li><li>To access the data in a Grid, it is necessary to use the data model encapsulated by the {@link #store Store}. See the {@link #cellclick} event for more details.</li></ul></div>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.grid.Column'>
        <xs:sequence>
            <xs:element name='groupRenderer' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>Optional. If the grid is being rendered by an {@link Ext.grid.GroupingView}, this option may be used to specify the function used to format the grouping field value for display in the group {@link #groupName header}. If a <tt><b>groupRenderer</b></tt> is not specified, the configured <tt><b>{@link #renderer}</b></tt> will be called; if a <tt><b>{@link #renderer}</b></tt> is also not specified the new value of the group field will be used.</p><p>The called function (either the <tt><b>groupRenderer</b></tt> or <tt><b>{@link #renderer}</b></tt>) will be passed the following parameters:</p><div class="mdetail-params"><ul><li><b>v</b> : Object<p class="sub-desc">The new value of the group field.</p></li><li><b>unused</b> : undefined<p class="sub-desc">Unused parameter.</p></li><li><b>r</b> : Ext.data.Record<p class="sub-desc">The Record providing the data for the row which caused group change.</p></li><li><b>rowIndex</b> : Number<p class="sub-desc">The row index of the Record which caused group change.</p></li><li><b>colIndex</b> : Number<p class="sub-desc">The column index of the group field.</p></li><li><b>ds</b> : Ext.data.Store<p class="sub-desc">The Store which is providing the data Model.</p></li></ul></div><br/><br/> <p>The function should return a string value.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='renderer' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>For an alternative to specifying a renderer see <code>{@link #xtype}</code></p><p>Optional. A renderer is an 'interceptor' method which can be used transform data (value, appearance, etc.) before it is rendered). This may be specified in either of three ways:</p><div class="mdetail-params"><ul><li>A renderer function used to return HTML markup for a cell given the cell's data value.</li><li>A string which references a property name of the {@link Ext.util.Format} class which provides a renderer function.</li><li>An object specifying both the renderer function, and its execution scope (<tt><b>this</b></tt> reference) e.g.:<pre style="margin-left:1.2em"><code>{
fn: this.gridRenderer,
scope: this
}
</code></pre></li></ul></div>If not specified, the default renderer uses the raw data value.<br/><br/> <p>For information about the renderer function (passed parameters, etc.), see {@link Ext.grid.ColumnModel#setRenderer}. An example of specifying renderer function inline:</p><pre><code>var companyColumn = {
header: 'Company Name',
dataIndex: 'company',
renderer: function(value, metaData, record, rowIndex, colIndex, store) {
// provide the logic depending on business rules
// name of your own choosing to manipulate the cell depending upon
// the data in the underlying Record object.
if (value == 'whatever') {
//metaData.css : String : A CSS class name to add to the TD element of the cell.
//metaData.attr : String : An html attribute definition string to apply to
//                         the data container element within the table
//                         cell (e.g. 'style="color:red;"').
metaData.css = 'name-of-css-class-you-will-define';
}
return value;
}
}
</code></pre>See also {@link #scope}.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='scope' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Optional. The scope (<tt><b>this</b></tt> reference) in which to execute the renderer. Defaults to the Column configuration object.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='editor' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Optional. The {@link Ext.form.Field} to use when editing values in this column if editing is supported by the grid. See <tt>{@link #editable}</tt> also.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='editable'>
          <xs:annotation>
            <xs:documentation>
Optional. Defaults to <tt>true</tt>, enabling the configured <tt>{@link #editor}</tt>. Set to <tt>false</tt> to initially disable editing on this column. The initial configuration may be dynamically altered using {@link Ext.grid.ColumnModel}.{@link Ext.grid.ColumnModel#setEditable setEditable()}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='id'>
          <xs:annotation>
            <xs:documentation>
Optional. A name which identifies this column (defaults to the column's initial ordinal position.) The <tt>id</tt> is used to create a CSS <b>class</b> name which is applied to all table cells (including headers) in that column (in this context the <tt>id</tt> does not need to be unique). The class name takes the form of <pre>x-grid3-td-<b>id</b></pre>Header cells will also receive this class name, but will also have the class <pre>x-grid3-hd</pre>So, to target header cells, use CSS selectors such as:<pre>.x-grid3-hd-row .x-grid3-td-<b>id</b></pre>The {@link Ext.grid.GridPanel#autoExpandColumn} grid config option references the column via this unique identifier.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='header'>
          <xs:annotation>
            <xs:documentation>
Optional. The header text to be used as innerHTML (html tags are accepted) to display in the Grid view. <b>Note</b>: to have a clickable header with no text displayed use <tt>'Â '</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='groupable'>
          <xs:annotation>
            <xs:documentation>
Optional. If the grid is being rendered by an {@link Ext.grid.GroupingView}, this option may be used to disable the header menu item to group by the column selected. Defaults to <tt>true</tt>, which enables the header menu group option. Set to <tt>false</tt> to disable (but still show) the group option in the header menu for the column. See also <code>{@link #groupName}</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='groupName'>
          <xs:annotation>
            <xs:documentation>
Optional. If the grid is being rendered by an {@link Ext.grid.GroupingView}, this option may be used to specify the text with which to prefix the group field value in the group header line. See also {@link #groupRenderer} and {@link Ext.grid.GroupingView}.{@link Ext.grid.GroupingView#showGroupName showGroupName}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='groupRenderer'>
          <xs:annotation>
            <xs:documentation>
<p>Optional. If the grid is being rendered by an {@link Ext.grid.GroupingView}, this option may be used to specify the function used to format the grouping field value for display in the group {@link #groupName header}. If a <tt><b>groupRenderer</b></tt> is not specified, the configured <tt><b>{@link #renderer}</b></tt> will be called; if a <tt><b>{@link #renderer}</b></tt> is also not specified the new value of the group field will be used.</p><p>The called function (either the <tt><b>groupRenderer</b></tt> or <tt><b>{@link #renderer}</b></tt>) will be passed the following parameters:</p><div class="mdetail-params"><ul><li><b>v</b> : Object<p class="sub-desc">The new value of the group field.</p></li><li><b>unused</b> : undefined<p class="sub-desc">Unused parameter.</p></li><li><b>r</b> : Ext.data.Record<p class="sub-desc">The Record providing the data for the row which caused group change.</p></li><li><b>rowIndex</b> : Number<p class="sub-desc">The row index of the Record which caused group change.</p></li><li><b>colIndex</b> : Number<p class="sub-desc">The column index of the group field.</p></li><li><b>ds</b> : Ext.data.Store<p class="sub-desc">The Store which is providing the data Model.</p></li></ul></div><br/><br/> <p>The function should return a string value.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='emptyGroupText'>
          <xs:annotation>
            <xs:documentation>
Optional. If the grid is being rendered by an {@link Ext.grid.GroupingView}, this option may be used to specify the text to display when there is an empty group value. Defaults to the {@link Ext.grid.GroupingView}.{@link Ext.grid.GroupingView#emptyGroupText emptyGroupText}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='dataIndex'>
          <xs:annotation>
            <xs:documentation>
<p><b>Required</b>. The name of the field in the grid's {@link Ext.data.Store}'s {@link Ext.data.Record} definition from which to draw the column's value.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='width'>
          <xs:annotation>
            <xs:documentation>
Optional. The initial width in pixels of the column. The width of each column can also be affected if any of the following are configured: <div class="mdetail-params"><ul><li>{@link Ext.grid.GridPanel}.<tt>{@link Ext.grid.GridPanel#autoExpandColumn autoExpandColumn}</tt></li><li>{@link Ext.grid.GridView}.<tt>{@link Ext.grid.GridView#forceFit forceFit}</tt> <div class="sub-desc"><p>By specifying <tt>forceFit:true</tt>, {@link #fixed non-fixed width} columns will be re-proportioned (based on the relative initial widths) to fill the width of the grid so that no horizontal scrollbar is shown.</p></div></li><li>{@link Ext.grid.GridView}.<tt>{@link Ext.grid.GridView#autoFill autoFill}</tt></li><li>{@link Ext.grid.GridPanel}.<tt>{@link Ext.grid.GridPanel#minColumnWidth minColumnWidth}</tt></li><li style="list-style: none"><br/><p><b>Note</b>: when the width of each column is determined, a space on the right side is reserved for the vertical scrollbar. The {@link Ext.grid.GridView}.<tt>{@link Ext.grid.GridView#scrollOffset scrollOffset}</tt> can be modified to reduce or eliminate the reserved offset.</p></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='sortable'>
          <xs:annotation>
            <xs:documentation>
Optional. <tt>true</tt> if sorting is to be allowed on this column. Defaults to the value of the <code>{@link Ext.grid.ColumnModel#defaultSortable}</code> property. Whether local/remote sorting is used is specified in <code>{@link Ext.data.Store#remoteSort}</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='fixed'>
          <xs:annotation>
            <xs:documentation>
Optional. <tt>true</tt> if the column width cannot be changed. Defaults to <tt>false</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='resizable'>
          <xs:annotation>
            <xs:documentation>
Optional. <tt>false</tt> to disable column resizing. Defaults to <tt>true</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='menuDisabled'>
          <xs:annotation>
            <xs:documentation>
Optional. <tt>true</tt> to disable the column menu. Defaults to <tt>false</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hidden'>
          <xs:annotation>
            <xs:documentation>
Optional. <tt>true</tt> to initially hide this column. Defaults to <tt>false</tt>. A hidden column {@link Ext.grid.GridPanel#enableColumnHide may be shown via the header row menu}. If a column is never to be shown, simply do not include this column in the Column Model at all.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tooltip'>
          <xs:annotation>
            <xs:documentation>
Optional. A text string to use as the column header's tooltip. If Quicktips are enabled, this value will be used as the text of the quick tip, otherwise it will be set as the header's HTML title attribute. Defaults to ''.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='renderer'>
          <xs:annotation>
            <xs:documentation>
<p>For an alternative to specifying a renderer see <code>{@link #xtype}</code></p><p>Optional. A renderer is an 'interceptor' method which can be used transform data (value, appearance, etc.) before it is rendered). This may be specified in either of three ways:</p><div class="mdetail-params"><ul><li>A renderer function used to return HTML markup for a cell given the cell's data value.</li><li>A string which references a property name of the {@link Ext.util.Format} class which provides a renderer function.</li><li>An object specifying both the renderer function, and its execution scope (<tt><b>this</b></tt> reference) e.g.:<pre style="margin-left:1.2em"><code>{
fn: this.gridRenderer,
scope: this
}
</code></pre></li></ul></div>If not specified, the default renderer uses the raw data value.<br/><br/> <p>For information about the renderer function (passed parameters, etc.), see {@link Ext.grid.ColumnModel#setRenderer}. An example of specifying renderer function inline:</p><pre><code>var companyColumn = {
header: 'Company Name',
dataIndex: 'company',
renderer: function(value, metaData, record, rowIndex, colIndex, store) {
// provide the logic depending on business rules
// name of your own choosing to manipulate the cell depending upon
// the data in the underlying Record object.
if (value == 'whatever') {
//metaData.css : String : A CSS class name to add to the TD element of the cell.
//metaData.attr : String : An html attribute definition string to apply to
//                         the data container element within the table
//                         cell (e.g. 'style="color:red;"').
metaData.css = 'name-of-css-class-you-will-define';
}
return value;
}
}
</code></pre>See also {@link #scope}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='xtype'>
          <xs:annotation>
            <xs:documentation>
Optional. A String which references a predefined {@link Ext.grid.Column} subclass type which is preconfigured with an appropriate <code>{@link #renderer}</code> to be easily configured into a ColumnModel. The predefined {@link Ext.grid.Column} subclass types are: <div class="mdetail-params"><ul><li><b><tt>gridcolumn</tt></b> : {@link Ext.grid.Column} (<b>Default</b>)</li><li><b><tt>booleancolumn</tt></b> : {@link Ext.grid.BooleanColumn}</li><li><b><tt>numbercolumn</tt></b> : {@link Ext.grid.NumberColumn}</li><li><b><tt>datecolumn</tt></b> : {@link Ext.grid.DateColumn}</li><li><b><tt>templatecolumn</tt></b> : {@link Ext.grid.TemplateColumn}</li></ul></div><p>Configuration properties for the specified <code>xtype</code> may be specified with the Column configuration properties, for example:</p><pre><code>var grid = new Ext.grid.GridPanel({
...
columns: [{
header: 'Last Updated',
dataIndex: 'lastChange',
width: 85,
sortable: true,
//renderer: Ext.util.Format.dateRenderer('m/d/Y'),
xtype: 'datecolumn', // use xtype instead of renderer
format: 'M/d/Y' // configuration property for {@link Ext.grid.DateColumn}
}, {
...
}]
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scope'>
          <xs:annotation>
            <xs:documentation>
Optional. The scope (<tt><b>this</b></tt> reference) in which to execute the renderer. Defaults to the Column configuration object.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='align'>
          <xs:annotation>
            <xs:documentation>
Optional. Set the CSS text-align property of the column. Defaults to undefined.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='css'>
          <xs:annotation>
            <xs:documentation>
Optional. An inline style definition string which is applied to all table cells in the column (excluding headers). Defaults to undefined.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideable'>
          <xs:annotation>
            <xs:documentation>
Optional. Specify as <tt>false</tt> to prevent the user from hiding this column (defaults to true). To disallow column hiding globally for all columns in the grid, use {@link Ext.grid.GridPanel#enableColumnHide} instead.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='editor'>
          <xs:annotation>
            <xs:documentation>
Optional. The {@link Ext.form.Field} to use when editing values in this column if editing is supported by the grid. See <tt>{@link #editable}</tt> also.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='isColumn'>
          <xs:annotation>
            <xs:documentation>
Used by ColumnModel setConfig method to avoid reprocessing a Column if <code>isColumn</code> is not set ColumnModel will recreate a new Ext.grid.Column Defaults to true.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
  </xs:complexType>
  <xs:element id='gridcolumn' name='gridcolumn' type='ext:ext.grid.Column'>
    <xs:annotation>
      <xs:documentation>
<p>This class encapsulates column configuration data to be used in the initialization of a {@link Ext.grid.ColumnModel ColumnModel}.</p><p>While subclasses are provided to render data in different ways, this class renders a passed data field unchanged and is usually used for textual columns.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.data.GroupingStore'>
    <xs:complexContent>
      <xs:extension base='ext:ext.data.Store'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:string' name='groupField'>
          <xs:annotation>
            <xs:documentation>
The field name by which to sort the store's data (defaults to '').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='remoteGroup'>
          <xs:annotation>
            <xs:documentation>
True if the grouping should apply on the server side, false if it is local only (defaults to false). If the grouping is local, it can be applied immediately to the data. If it is remote, then it will simply act as a helper, automatically sending the grouping field name as the 'groupBy' param with each XHR call.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='groupOnSort'>
          <xs:annotation>
            <xs:documentation>
True to sort the data on the grouping field when a grouping operation occurs, false to sort based on the existing sort info (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='groupingstore' name='groupingstore' type='ext:ext.data.GroupingStore' substitutionGroup='ext:store'>
    <xs:annotation>
      <xs:documentation>
A specialized store implementation that provides for grouping records by one of the available fields. This is usually used in conjunction with an {@link Ext.grid.GroupingView} to proved the data model for a grouped GridPanel.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.Hidden'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Field'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='hidden' name='hidden' type='ext:ext.form.Hidden' substitutionGroup='ext:field'>
    <xs:annotation>
      <xs:documentation>
A basic hidden field for storing hidden values in forms that need to be passed in the form submit.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.HtmlEditor'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Field'>
        <xs:sequence>
            <xs:element name='fontFamilies' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of available font families
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='enableFormat'>
          <xs:annotation>
            <xs:documentation>
Enable the bold, italic and underline buttons (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableFontSize'>
          <xs:annotation>
            <xs:documentation>
Enable the increase/decrease font size buttons (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableColors'>
          <xs:annotation>
            <xs:documentation>
Enable the fore/highlight color buttons (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableAlignments'>
          <xs:annotation>
            <xs:documentation>
Enable the left, center, right alignment buttons (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableLists'>
          <xs:annotation>
            <xs:documentation>
Enable the bullet and numbered list buttons. Not available in Safari. (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableSourceEdit'>
          <xs:annotation>
            <xs:documentation>
Enable the switch to source edit button. Not available in Safari. (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableLinks'>
          <xs:annotation>
            <xs:documentation>
Enable the create link button. Not available in Safari. (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableFont'>
          <xs:annotation>
            <xs:documentation>
Enable font selection. Not available in Safari. (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='createLinkText'>
          <xs:annotation>
            <xs:documentation>
The default text for the create link prompt
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultLinkValue'>
          <xs:annotation>
            <xs:documentation>
The default value for the create link prompt (defaults to http:/ /)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='fontFamilies'>
          <xs:annotation>
            <xs:documentation>
An array of available font families
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultValue'>
          <xs:annotation>
            <xs:documentation>
A default value to be put into the editor to resolve focus issues (defaults to â (Zero-width space), Â  (Non-breaking space) in Opera and IE6).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='htmleditor' name='htmleditor' type='ext:ext.form.HtmlEditor' substitutionGroup='ext:field'>
    <xs:annotation>
      <xs:documentation>
Provides a lightweight HTML Editor component. Some toolbar features are not supported by Safari and will be automatically hidden when needed. These are noted in the config options where appropriate. <br/><br/>The editor's toolbar buttons have tooltips defined in the {@link #buttonTips} property, but they are not enabled by default unless the global {@link Ext.QuickTips} singleton is {@link Ext.QuickTips#init initialized}. <br/><br/><b>Note: The focus/blur and validation marking functionality inherited from Ext.form.Field is NOT supported by this editor.</b> <br/><br/>An Editor is a sensitive component that can't be used in all spots standard fields can be used. Putting an Editor within any element that has display set to 'none' can cause problems in Safari and Firefox due to their default iframe reloading bugs. <br/><br/>Example usage: <pre><code>// Simple example rendered with default options:
Ext.QuickTips.init();  // enable tooltips
new Ext.form.HtmlEditor({
renderTo: Ext.getBody(),
width: 800,
height: 300
});

// Passed via xtype into a container and with custom options:
Ext.QuickTips.init();  // enable tooltips
new Ext.Panel({
title: 'HTML Editor',
renderTo: Ext.getBody(),
width: 600,
height: 300,
frame: true,
layout: 'fit',
items: {
xtype: 'htmleditor',
enableColors: false,
enableAlignments: false
}
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.data.JsonStore'>
    <xs:complexContent>
      <xs:extension base='ext:ext.data.Store'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='jsonstore' name='jsonstore' type='ext:ext.data.JsonStore' substitutionGroup='ext:store'>
    <xs:annotation>
      <xs:documentation>
<p>Small helper class to make creating {@link Ext.data.Store}s from JSON data easier. A JsonStore will be automatically configured with a {@link Ext.data.JsonReader}.</p><p>A store configuration would be something like:</p><pre><code>var store = new Ext.data.JsonStore({
// store configs
autoDestroy: true,
url: 'get-images.php',
storeId: 'myStore',
// reader configs
root: 'images',
idProperty: 'name',
fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
});
</code></pre><br/><br/> <p>This store is configured to consume a returned object of the form:</p><pre><code>{
images: [
{name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
{name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
]
}
</code></pre>An object literal of this form could also be used as the {@link #data} config option.<br/><br/> <p><b>*Note:</b> Although not listed here, this class accepts all of the configuration options of <b>{@link Ext.data.JsonReader JsonReader}</b>.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.Label'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:string' name='text'>
          <xs:annotation>
            <xs:documentation>
The plain text to display within the label (defaults to ''). If you need to include HTML tags within the label's innerHTML, use the {@link #html} config instead.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='forId'>
          <xs:annotation>
            <xs:documentation>
The id of the input element to which this label will be bound via the standard HTML 'for' attribute. If not specified, the attribute will not be added to the label.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='html'>
          <xs:annotation>
            <xs:documentation>
An HTML fragment that will be used as the label's innerHTML (defaults to ''). Note that if {@link #text} is specified it will take precedence and this value will be ignored.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='label' name='label' type='ext:ext.form.Label' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
Basic Label field.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.chart.LineChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.CartesianChart'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='linechart' name='linechart' type='ext:ext.chart.LineChart' substitutionGroup='ext:cartesianchart'>
  </xs:element>
  <xs:complexType name='ext.ListView'>
    <xs:complexContent>
      <xs:extension base='ext:ext.DataView'>
        <xs:sequence>
            <xs:element name='columnResize' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Specify <tt>true</tt> or specify a configuration object for {@link Ext.ListView.ColumnResizer} to enable the columns to be resizable (defaults to <tt>true</tt>).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='columns' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of column configuration objects, for example: <pre><code>{
align: 'right',
dataIndex: 'size',
header: 'Size',
tpl: '{size:fileSize}',
width: .35
}
</code></pre>Acceptable properties for each column configuration object are: <div class="mdetail-params"><ul><li><b><tt>align</tt></b> : String<div class="sub-desc">Set the CSS text-align property of the column. Defaults to <tt>'left'</tt>.</div></li><li><b><tt>dataIndex</tt></b> : String<div class="sub-desc">See {@link Ext.grid.Column}. {@link Ext.grid.Column#dataIndex dataIndex} for details.</div></li><li><b><tt>header</tt></b> : String<div class="sub-desc">See {@link Ext.grid.Column}. {@link Ext.grid.Column#header header} for details.</div></li><li><b><tt>tpl</tt></b> : String<div class="sub-desc">Specify a string to pass as the configuration string for {@link Ext.XTemplate}. By default an {@link Ext.XTemplate} will be implicitly created using the <tt>dataIndex</tt>.</div></li><li><b><tt>width</tt></b> : Number<div class="sub-desc">Percentage of the container width this column should be allocated. Columns that have no width specified will be allocated with an equal percentage to fill 100% of the container width. To easily take advantage of the full container width, leave the width of at least one column undefined. Note that if you do not want to take up the full width of the container, the width of every column needs to be explicitly defined.</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='columnSort' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Specify <tt>true</tt> or specify a configuration object for {@link Ext.ListView.Sorter} to enable the columns to be sortable (defaults to <tt>true</tt>).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='internalTpl' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The template to be used for the header row. See {@link #tpl} for more details.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='hideHeaders'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to hide the {@link #internalTpl header row} (defaults to <tt>false</tt> so the {@link #internalTpl header row} will be shown).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='reserveScrollOffset'>
          <xs:annotation>
            <xs:documentation>
By default will defer accounting for the configured <b><tt>{@link #scrollOffset}</tt></b> for 10 milliseconds. Specify <tt>true</tt> to account for the configured <b><tt>{@link #scrollOffset}</tt></b> immediately.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='scrollOffset'>
          <xs:annotation>
            <xs:documentation>
The amount of space to reserve for the scrollbar (defaults to <tt>undefined</tt>). If an explicit value isn't specified, this will be automatically calculated.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='columnResize'>
          <xs:annotation>
            <xs:documentation>
Specify <tt>true</tt> or specify a configuration object for {@link Ext.ListView.ColumnResizer} to enable the columns to be resizable (defaults to <tt>true</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='columns'>
          <xs:annotation>
            <xs:documentation>
An array of column configuration objects, for example: <pre><code>{
align: 'right',
dataIndex: 'size',
header: 'Size',
tpl: '{size:fileSize}',
width: .35
}
</code></pre>Acceptable properties for each column configuration object are: <div class="mdetail-params"><ul><li><b><tt>align</tt></b> : String<div class="sub-desc">Set the CSS text-align property of the column. Defaults to <tt>'left'</tt>.</div></li><li><b><tt>dataIndex</tt></b> : String<div class="sub-desc">See {@link Ext.grid.Column}. {@link Ext.grid.Column#dataIndex dataIndex} for details.</div></li><li><b><tt>header</tt></b> : String<div class="sub-desc">See {@link Ext.grid.Column}. {@link Ext.grid.Column#header header} for details.</div></li><li><b><tt>tpl</tt></b> : String<div class="sub-desc">Specify a string to pass as the configuration string for {@link Ext.XTemplate}. By default an {@link Ext.XTemplate} will be implicitly created using the <tt>dataIndex</tt>.</div></li><li><b><tt>width</tt></b> : Number<div class="sub-desc">Percentage of the container width this column should be allocated. Columns that have no width specified will be allocated with an equal percentage to fill 100% of the container width. To easily take advantage of the full container width, leave the width of at least one column undefined. Note that if you do not want to take up the full width of the container, the width of every column needs to be explicitly defined.</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='columnSort'>
          <xs:annotation>
            <xs:documentation>
Specify <tt>true</tt> or specify a configuration object for {@link Ext.ListView.Sorter} to enable the columns to be sortable (defaults to <tt>true</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='internalTpl'>
          <xs:annotation>
            <xs:documentation>
The template to be used for the header row. See {@link #tpl} for more details.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='listview' name='listview' type='ext:ext.ListView' substitutionGroup='ext:dataview'>
    <xs:annotation>
      <xs:documentation>
<p>Ext.ListView is a fast and light-weight implentation of a {@link Ext.grid.GridPanel Grid} like view with the following characteristics:</p><div class="mdetail-params"><ul><li>resizable columns</li><li>selectable</li><li>column widths are initially proportioned by percentage based on the container width and number of columns</li><li>uses templates to render the data in any required format</li><li>no horizontal scrolling</li><li>no editing</li></ul></div><p>Example usage:</p><pre><code>// consume JSON of this form:
{
"images":[
{
"name":"dance_fever.jpg",
"size":2067,
"lastmod":1236974993000,
"url":"images\/thumbs\/dance_fever.jpg"
},
{
"name":"zack_sink.jpg",
"size":2303,
"lastmod":1236974993000,
"url":"images\/thumbs\/zack_sink.jpg"
}
]
} 
var store = new Ext.data.JsonStore({
url: 'get-images.php',
root: 'images',
fields: [
'name', 'url',
{name:'size', type: 'float'},
{name:'lastmod', type:'date', dateFormat:'timestamp'}
]
});
store.load();

var listView = new Ext.ListView({
store: store,
multiSelect: true,
emptyText: 'No images to display',
reserveScrollOffset: true,
columns: [{
header: 'File',
width: .5,
dataIndex: 'name'
},{
header: 'Last Modified',
width: .35, 
dataIndex: 'lastmod',
tpl: '{lastmod:date("m-d h:i a")}'
},{
header: 'Size',
dataIndex: 'size',
tpl: '{size:fileSize}', // format using Ext.util.Format.fileSize()
align: 'right'
}]
});

// put it in a Panel so it looks pretty
var panel = new Ext.Panel({
id:'images-view',
width:425,
height:250,
collapsible:true,
layout:'fit',
title:'Simple ListView <i>(0 items selected)</i>',
items: listView
});
panel.render(document.body);

// little bit of feedback
listView.on('selectionchange', function(view, nodes){
var l = nodes.length;
var s = l != 1 ? 's' : '';
panel.setTitle('Simple ListView <i>('+l+' item'+s+' selected)</i>');
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.Menu'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Container'>
        <xs:sequence>
            <xs:element name='defaultOffsets' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array specifying the [x, y] offset in pixels by which to change the default Menu popup position after aligning according to the {@link #defaultAlign} configuration. Defaults to <tt>[0, 0]</tt>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:int' name='minWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width of the menu in pixels (defaults to 120)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='shadow'>
          <xs:annotation>
            <xs:documentation>
True or 'sides' for the default effect, 'frame' for 4-way shadow, and 'drop' for bottom-right shadow (defaults to 'sides')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='subMenuAlign'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.Element#alignTo} anchor position value to use for submenus of this menu (defaults to 'tl-tr?')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultAlign'>
          <xs:annotation>
            <xs:documentation>
The default {@link Ext.Element#alignTo} anchor position value for this menu relative to its element of origin (defaults to 'tl-bl?')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowOtherMenus'>
          <xs:annotation>
            <xs:documentation>
True to allow multiple menus to be displayed at the same time (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='ignoreParentClicks'>
          <xs:annotation>
            <xs:documentation>
True to ignore clicks on any item in this menu that is a parent item (displays a submenu) so that the submenu is not dismissed when clicking the parent item (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableScrolling'>
          <xs:annotation>
            <xs:documentation>
True to allow the menu container to have scroller controls if the menu is too long (defaults to true).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxHeight'>
          <xs:annotation>
            <xs:documentation>
The maximum height of the menu. Only applies when enableScrolling is set to True (defaults to null).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='scrollIncrement'>
          <xs:annotation>
            <xs:documentation>
The amount to scroll the menu. Only applies when enableScrolling is set to True (defaults to 24).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='showSeparator'>
          <xs:annotation>
            <xs:documentation>
True to show the icon separator. (defaults to true).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultOffsets'>
          <xs:annotation>
            <xs:documentation>
An array specifying the [x, y] offset in pixels by which to change the default Menu popup position after aligning according to the {@link #defaultAlign} configuration. Defaults to <tt>[0, 0]</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='plain'>
          <xs:annotation>
            <xs:documentation>
True to remove the incised line down the left side of the menu. Defaults to <tt>false</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='floating'>
          <xs:annotation>
            <xs:documentation>
<p>By default, a Menu configured as <b><code>floating:true</code></b> will be rendered as an {@link Ext.Layer} (an absolutely positioned, floating Component with zindex=15000). If configured as <b><code>floating:false</code></b>, the Menu may be used as child item of another Container instead of a free-floating {@link Ext.Layer Layer}.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='menu' name='menu' type='ext:ext.menu.Menu' substitutionGroup='ext:container'>
    <xs:annotation>
      <xs:documentation>
<p>A menu object. This is the container to which you may add menu items. Menu can also serve as a base class when you want a specialized menu based off of another component (like {@link Ext.menu.DateMenu} for example).</p><p>Menus may contain either {@link Ext.menu.Item menu items}, or general {@link Ext.Component Component}s.</p><p>To make a contained general {@link Ext.Component Component} line up with other {@link Ext.menu.Item menu items} specify <tt>iconCls: 'no-icon'</tt>. This reserves a space for an icon, and indents the Component in line with the other menu items. See {@link Ext.form.ComboBox}.{@link Ext.form.ComboBox#getListParent getListParent} for an example.</p><p>By default, Menus are absolutely positioned, floating Components. By configuring a Menu with <b><tt>{@link #floating}:false</tt></b>, a Menu may be used as child of a Container.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.BaseItem'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Component'>
        <xs:sequence>
            <xs:element name='handler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A function that will handle the click event of this menu item (optional). The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>b</code> : Item<div class="sub-desc">This menu Item.</div></li><li><code>e</code> : EventObject<div class="sub-desc">The click event.</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='scope' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The scope (<tt><b>this</b></tt> reference) in which the handler function will be called.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='handler'>
          <xs:annotation>
            <xs:documentation>
A function that will handle the click event of this menu item (optional). The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>b</code> : Item<div class="sub-desc">This menu Item.</div></li><li><code>e</code> : EventObject<div class="sub-desc">The click event.</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scope'>
          <xs:annotation>
            <xs:documentation>
The scope (<tt><b>this</b></tt> reference) in which the handler function will be called.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='canActivate'>
          <xs:annotation>
            <xs:documentation>
True if this item can be visually activated (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='activeClass'>
          <xs:annotation>
            <xs:documentation>
The CSS class to use when the item becomes activated (defaults to "x-menu-item-active")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideOnClick'>
          <xs:annotation>
            <xs:documentation>
True to hide the containing menu after this item is clicked (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='clickHideDelay'>
          <xs:annotation>
            <xs:documentation>
Length of time in milliseconds to wait before hiding after a click (defaults to 100)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='menubaseitem' name='menubaseitem' type='ext:ext.menu.BaseItem' substitutionGroup='ext:component'>
    <xs:annotation>
      <xs:documentation>
The base class for all items that render into menus. BaseItem provides default rendering, activated state management and base configuration options shared by all menu components.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.CheckItem'>
    <xs:complexContent>
      <xs:extension base='ext:ext.menu.Item'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:string' name='group'>
          <xs:annotation>
            <xs:documentation>
All check items with the same group name will automatically be grouped into a single-select radio button group (defaults to '')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='groupClass'>
          <xs:annotation>
            <xs:documentation>
The default CSS class to use for radio group check items (defaults to "x-menu-group-item")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='checked'>
          <xs:annotation>
            <xs:documentation>
True to initialize this checkbox as checked (defaults to false). Note that if this checkbox is part of a radio group (group = true) only the last item in the group that is initialized with checked = true will be rendered as checked.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='menucheckitem' name='menucheckitem' type='ext:ext.menu.CheckItem' substitutionGroup='ext:menuitem'>
    <xs:annotation>
      <xs:documentation>
Adds a menu item that contains a checkbox by default, but can also be part of a radio group.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.Item'>
    <xs:complexContent>
      <xs:extension base='ext:ext.menu.BaseItem'>
        <xs:sequence>
            <xs:element name='menu' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    (optional) Either an instance of {@link Ext.menu.Menu} or the config object for an {@link Ext.menu.Menu} which acts as the submenu when this item is activated.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='menu'>
          <xs:annotation>
            <xs:documentation>
(optional) Either an instance of {@link Ext.menu.Menu} or the config object for an {@link Ext.menu.Menu} which acts as the submenu when this item is activated.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='icon'>
          <xs:annotation>
            <xs:documentation>
The path to an icon to display in this item (defaults to Ext.BLANK_IMAGE_URL). If icon is specified {@link #iconCls} should not be.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='iconCls'>
          <xs:annotation>
            <xs:documentation>
A CSS class that specifies a background image that will be used as the icon for this item (defaults to ''). If iconCls is specified {@link #icon} should not be.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='text'>
          <xs:annotation>
            <xs:documentation>
The text to display in this item (defaults to '').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='href'>
          <xs:annotation>
            <xs:documentation>
The href attribute to use for the underlying anchor link (defaults to '#').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='hrefTarget'>
          <xs:annotation>
            <xs:documentation>
The target attribute to use for the underlying anchor link (defaults to '').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='showDelay'>
          <xs:annotation>
            <xs:documentation>
Length of time in milliseconds to wait before showing this item (defaults to 200)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='menuitem' name='menuitem' type='ext:ext.menu.Item' substitutionGroup='ext:menubaseitem'>
    <xs:annotation>
      <xs:documentation>
A base class for all menu items that require menu-related functionality (like sub-menus) and are not static display items. Item extends the base functionality of {@link Ext.menu.BaseItem} by adding menu-specific activation and click handling.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.Separator'>
    <xs:complexContent>
      <xs:extension base='ext:ext.menu.BaseItem'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='menuseparator' name='menuseparator' type='ext:ext.menu.Separator' substitutionGroup='ext:menubaseitem'>
    <xs:annotation>
      <xs:documentation>
Adds a separator bar to a menu, used to divide logical groups of menu items. Generally you will add one of these by using "-" in you call to add() or in your items config rather than creating one directly.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.TextItem'>
    <xs:complexContent>
      <xs:extension base='ext:ext.menu.BaseItem'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:string' name='text'>
          <xs:annotation>
            <xs:documentation>
The text to display for this item (defaults to '')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='menutextitem' name='menutextitem' type='ext:ext.menu.TextItem' substitutionGroup='ext:menubaseitem'>
    <xs:annotation>
      <xs:documentation>
Adds a static text string to a menu, usually used as either a heading or group separator.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.grid.NumberColumn'>
    <xs:complexContent>
      <xs:extension base='ext:ext.grid.Column'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:string' name='format'>
          <xs:annotation>
            <xs:documentation>
A formatting string as used by {@link Ext.util.Format#number} to format a numeric value for this Column (defaults to <tt>'0,000.00'</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='numbercolumn' name='numbercolumn' type='ext:ext.grid.NumberColumn' substitutionGroup='ext:gridcolumn'>
    <xs:annotation>
      <xs:documentation>
<p>A Column definition class which renders a numeric data field according to a {@link #format} string. See the {@link Ext.grid.Column#xtype xtype} config option of {@link Ext.grid.Column} for more details.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.NumberField'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.TextField'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='allowDecimals'>
          <xs:annotation>
            <xs:documentation>
False to disallow decimal values (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='decimalSeparator'>
          <xs:annotation>
            <xs:documentation>
Character(s) to allow as the decimal separator (defaults to '.')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='decimalPrecision'>
          <xs:annotation>
            <xs:documentation>
The maximum precision to display after the decimal separator (defaults to 2)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowNegative'>
          <xs:annotation>
            <xs:documentation>
False to prevent entering a negative sign (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minValue'>
          <xs:annotation>
            <xs:documentation>
The minimum allowed value (defaults to Number.NEGATIVE_INFINITY)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxValue'>
          <xs:annotation>
            <xs:documentation>
The maximum allowed value (defaults to Number.MAX_VALUE)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='minText'>
          <xs:annotation>
            <xs:documentation>
Error text to display if the minimum value validation fails (defaults to "The minimum value for this field is {minValue}")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxText'>
          <xs:annotation>
            <xs:documentation>
Error text to display if the maximum value validation fails (defaults to "The maximum value for this field is {maxValue}")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='nanText'>
          <xs:annotation>
            <xs:documentation>
Error text to display if the value is not a valid number. For example, this can happen if a valid character like '.' or '-' is left in the field with no number (defaults to "{value} is not a valid number")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='baseChars'>
          <xs:annotation>
            <xs:documentation>
The base set of characters to evaluate as valid numbers (defaults to '0123456789').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='numberfield' name='numberfield' type='ext:ext.form.NumberField' substitutionGroup='ext:textfield'>
    <xs:annotation>
      <xs:documentation>
Numeric text field that provides automatic keystroke filtering and numeric validation.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.util.Observable'>
        <xs:sequence>
            <xs:element name='listeners' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    (optional) <p>A config object containing one or more event handlers to be added to this object during initialization. This should be a valid listeners config object as specified in the {@link #addListener} example for attaching multiple handlers at once.</p><br/><p style="font-weight: bold"><u>DOM events from ExtJs {@link Ext.Component Components}</u></p><br/><p>While <i>some</i> ExtJs Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually only done when extra value can be added. For example the {@link Ext.DataView DataView}'s <b><code>{@link Ext.DataView#click click}</code></b> event passing the node clicked on. To access DOM events directly from a Component's HTMLElement, listeners must be added to the <i>{@link Ext.Component#getEl Element}</i> after the Component has been rendered. A plugin can simplify this step:</p><pre><code>// Plugin is configured with a listeners config object.
// The Component is appended to the argument list of all handler functions.
Ext.DomObserver = Ext.extend(Object, {
constructor: function(config) {
this.listeners = config.listeners ? config.listeners : config;
},

// Component passes itself into plugin's init method
init: function(c) {
var p, l = this.listeners;
for (p in l) {
if (Ext.isFunction(l[p])) {
l[p] = this.createHandler(l[p], c);
} else {
l[p].fn = this.createHandler(l[p].fn, c);
}
}

// Add the listeners to the Element immediately following the render call
c.render = c.render.{@link Function#createSequence createSequence}(function() {
var e = c.getEl();
if (e) {
e.on(l);
}
});
},

createHandler: function(fn, c) {
return function(e) {
fn.call(this, e, c);
};
}
});

var combo = new Ext.form.ComboBox({

// Collapse combo when its element is clicked on
plugins: [ new Ext.DomObserver({
click: function(evt, comp) {
comp.collapse();
}
})],
store: myStore,
typeAhead: true,
mode: 'local',
triggerAction: 'all'
});
</code></pre><br/><br/>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='listeners'>
          <xs:annotation>
            <xs:documentation>
(optional) <p>A config object containing one or more event handlers to be added to this object during initialization. This should be a valid listeners config object as specified in the {@link #addListener} example for attaching multiple handlers at once.</p><br/><p style="font-weight: bold"><u>DOM events from ExtJs {@link Ext.Component Components}</u></p><br/><p>While <i>some</i> ExtJs Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually only done when extra value can be added. For example the {@link Ext.DataView DataView}'s <b><code>{@link Ext.DataView#click click}</code></b> event passing the node clicked on. To access DOM events directly from a Component's HTMLElement, listeners must be added to the <i>{@link Ext.Component#getEl Element}</i> after the Component has been rendered. A plugin can simplify this step:</p><pre><code>// Plugin is configured with a listeners config object.
// The Component is appended to the argument list of all handler functions.
Ext.DomObserver = Ext.extend(Object, {
constructor: function(config) {
this.listeners = config.listeners ? config.listeners : config;
},

// Component passes itself into plugin's init method
init: function(c) {
var p, l = this.listeners;
for (p in l) {
if (Ext.isFunction(l[p])) {
l[p] = this.createHandler(l[p], c);
} else {
l[p].fn = this.createHandler(l[p].fn, c);
}
}

// Add the listeners to the Element immediately following the render call
c.render = c.render.{@link Function#createSequence createSequence}(function() {
var e = c.getEl();
if (e) {
e.on(l);
}
});
},

createHandler: function(fn, c) {
return function(e) {
fn.call(this, e, c);
};
}
});

var combo = new Ext.form.ComboBox({

// Collapse combo when its element is clicked on
plugins: [ new Ext.DomObserver({
click: function(evt, comp) {
comp.collapse();
}
})],
store: myStore,
typeAhead: true,
mode: 'local',
triggerAction: 'all'
});
</code></pre><br/><br/>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
  </xs:complexType>
  <xs:element id='observable' name='observable' type='ext:ext.util.Observable'>
    <xs:annotation>
      <xs:documentation>
Base class that provides a common interface for publishing events. Subclasses are expected to to have a property "events" with all the events defined, and, optionally, a property "listeners" with configured listeners defined.<br/>For example: <pre><code>Employee = Ext.extend(Ext.util.Observable, {
constructor: function(config){
this.name = config.name;
this.addEvents({
"fired" : true,
"quit" : true
});

// Copy configured listeners into *this* object so that the base class's
// constructor will add them.
this.listeners = config.listeners;

// Call our superclass constructor to complete construction process.
Employee.superclass.constructor.call(config)
}
});
</code></pre>This could then be used like this:<pre><code>var newEmployee = new Employee({
name: employeeName,
listeners: {
quit: function() {
// By default, "this" will be the object that fired the event.
alert(this.name + " has quit!");
}
}
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.PagingToolbar'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Toolbar'>
        <xs:sequence>
            <xs:element name='store' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The {@link Ext.data.Store} the paging toolbar should use as its data source (required).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='store'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.data.Store} the paging toolbar should use as its data source (required).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='displayInfo'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to display the displayMsg (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='pageSize'>
          <xs:annotation>
            <xs:documentation>
The number of records to display per page (defaults to <tt>20</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='prependButtons'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to insert any configured <tt>items</tt> <i>before</i> the paging buttons. Defaults to <tt>false</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='displayMsg'>
          <xs:annotation>
            <xs:documentation>
The paging status message to display (defaults to <tt>'Displaying {0} - {1} of {2}'</tt>). Note that this string is formatted using the braced numbers <tt>{0}-{2}</tt> as tokens that are replaced by the values for start, end and total respectively. These tokens should be preserved when overriding this string if showing those values is desired.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='emptyMsg'>
          <xs:annotation>
            <xs:documentation>
The message to display when no records are found (defaults to 'No data to display')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='beforePageText'>
          <xs:annotation>
            <xs:documentation>
The text displayed before the input item (defaults to <tt>'Page'</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='afterPageText'>
          <xs:annotation>
            <xs:documentation>
Customizable piece of the default paging text (defaults to <tt>'of {0}'</tt>). Note that this string is formatted using <tt>{0}</tt> as a token that is replaced by the number of total pages. This token should be preserved when overriding this string if showing the total page count is desired.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='firstText'>
          <xs:annotation>
            <xs:documentation>
The quicktip text displayed for the first page button (defaults to <tt>'First Page'</tt>). <b>Note</b>: quick tips must be initialized for the quicktip to show.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='prevText'>
          <xs:annotation>
            <xs:documentation>
The quicktip text displayed for the previous page button (defaults to <tt>'Previous Page'</tt>). <b>Note</b>: quick tips must be initialized for the quicktip to show.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='nextText'>
          <xs:annotation>
            <xs:documentation>
The quicktip text displayed for the next page button (defaults to <tt>'Next Page'</tt>). <b>Note</b>: quick tips must be initialized for the quicktip to show.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='lastText'>
          <xs:annotation>
            <xs:documentation>
The quicktip text displayed for the last page button (defaults to <tt>'Last Page'</tt>). <b>Note</b>: quick tips must be initialized for the quicktip to show.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='refreshText'>
          <xs:annotation>
            <xs:documentation>
The quicktip text displayed for the Refresh button (defaults to <tt>'Refresh'</tt>). <b>Note</b>: quick tips must be initialized for the quicktip to show.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='paging' name='paging' type='ext:ext.PagingToolbar' substitutionGroup='ext:toolbar'>
    <xs:annotation>
      <xs:documentation>
<p>As the amount of records increases, the time required for the browser to render them increases. Paging is used to reduce the amount of data exchanged with the client. Note: if there are more records/rows than can be viewed in the available screen area, vertical scrollbars will be added.</p><p>Paging is typically handled on the server side (see exception below). The client sends parameters to the server side, which the server needs to interpret and then respond with the approprate data.</p><p><b>Ext.PagingToolbar</b> is a specialized toolbar that is bound to a {@link Ext.data.Store} and provides automatic paging control. This Component {@link Ext.data.Store#load load}s blocks of data into the <tt>{@link #store}</tt> by passing {@link Ext.data.Store#paramNames paramNames} used for paging criteria.</p><p>PagingToolbar is typically used as one of the Grid's toolbars:</p><pre><code>Ext.QuickTips.init(); // to display button quicktips

var myStore = new Ext.data.Store({
reader: new Ext.data.JsonReader({
{@link Ext.data.JsonReader#totalProperty totalProperty}: 'results', 
...
}),
...
});

var myPageSize = 25;  // server script should only send back 25 items at a time

var grid = new Ext.grid.GridPanel({
...
store: myStore,
bbar: new Ext.PagingToolbar({
{@link #store}: myStore,       // grid and PagingToolbar using same store
{@link #displayInfo}: true,
{@link #pageSize}: myPageSize,
{@link #prependButtons}: true,
items: [
'text 1'
]
})
});
</code></pre><p>To use paging, pass the paging requirements to the server when the store is first loaded.</p><pre><code>store.load({
params: {
// specify params for the first page load if using paging
start: 0,          
limit: myPageSize,
// other params
foo:   'bar'
}
});
</code></pre><p>If using {@link Ext.data.Store#autoLoad store's autoLoad} configuration:</p><pre><code>var myStore = new Ext.data.Store({
{@link Ext.data.Store#autoLoad autoLoad}: {params:{start: 0, limit: 25}},
...
});
</code></pre><p>The packet sent back from the server would have this form:</p><pre><code>{
"success": true,
"results": 2000, 
"rows": [ // <b>*Note:</b> this must be an Array 
{ "id":  1, "name": "Bill", "occupation": "Gardener" },
{ "id":  2, "name":  "Ben", "occupation": "Horticulturalist" },
...
{ "id": 25, "name":  "Sue", "occupation": "Botanist" }
]
}
</code></pre><p><u>Paging with Local Data</u></p><p>Paging can also be accomplished with local data using extensions:</p><div class="mdetail-params"><ul><li><a href="http://extjs.com/forum/showthread.php?t=71532">Ext.ux.data.PagingStore</a></li><li>Paging Memory Proxy (examples/ux/PagingMemoryProxy.js)</li></ul></div>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Panel'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Container'>
        <xs:sequence>
            <xs:element name='bodyCfg' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A {@link Ext.DomHelper DomHelper} element specification object may be specified for any Panel Element.</p><p>By default, the Default element in the table below will be used for the html markup to create a child element with the commensurate Default class name (<code>baseCls</code> will be replaced by <code>{@link #baseCls}</code>):</p><pre>Panel      Default  Default             Custom      Additional       Additional
Element    element  class               element     class            style
========   ==========================   =========   ==============   ===========
{@link #header}     div      {@link #baseCls}+'-header'   {@link #headerCfg}   headerCssClass   headerStyle
{@link #bwrap}      div      {@link #baseCls}+'-bwrap'     {@link #bwrapCfg}    bwrapCssClass    bwrapStyle
+ tbar     div      {@link #baseCls}+'-tbar'       {@link #tbarCfg}     tbarCssClass     tbarStyle
+ {@link #body}     div      {@link #baseCls}+'-body'       {@link #bodyCfg}     {@link #bodyCssClass}     {@link #bodyStyle}
+ bbar     div      {@link #baseCls}+'-bbar'       {@link #bbarCfg}     bbarCssClass     bbarStyle
+ {@link #footer}   div      {@link #baseCls}+'-footer'   {@link #footerCfg}   footerCssClass   footerStyle
</pre><p>Configuring a Custom element may be used, for example, to force the {@link #body} Element to use a different form of markup than is created by default. An example of this might be to {@link Ext.Element#createChild create a child} Panel containing a custom content, such as a header, or forcing centering of all Panel content by having the body be a &lt;center&gt; element:</p><pre><code>new Ext.Panel({
title: 'Message Title',
renderTo: Ext.getBody(),
width: 200, height: 130,
<b>bodyCfg</b>: {
tag: 'center',
cls: 'x-panel-body',  // Default class not applied if Custom element specified
html: 'Message'
},
footerCfg: {
tag: 'h2',
cls: 'x-panel-footer'        // same as the Default class
html: 'footer html'
},
footerCssClass: 'custom-footer', // additional css class, see {@link Ext.element#addClass addClass}
footerStyle:    'background-color:red' // see {@link #bodyStyle}
});
</code></pre><p>The example above also explicitly creates a <code>{@link #footer}</code> with custom markup and styling applied.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='headerCfg' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #header} Element. See <code>{@link #bodyCfg}</code> also.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='bwrapCfg' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #bwrap} Element. See <code>{@link #bodyCfg}</code> also.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='tbarCfg' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #tbar} Element. See <code>{@link #bodyCfg}</code> also.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='bbarCfg' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #bbar} Element. See <code>{@link #bodyCfg}</code> also.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='footerCfg' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #footer} Element. See <code>{@link #bodyCfg}</code> also.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='tbar' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>The top toolbar of the panel. This can be a {@link Ext.Toolbar} object, a toolbar config, or an array of buttons/button configs to be added to the toolbar. Note that this is not available as a property after render. To access the top toolbar after render, use {@link #getTopToolbar}.</p><p><b>Note:</b> Although a Toolbar may contain Field components, these will <b>not</b> be updated by a load of an ancestor FormPanel. A Panel's toolbars are not part of the standard Container-&gt;Component hierarchy, and so are not scanned to collect form items. However, the values <b>will</b> be submitted because form submission parameters are collected from the DOM tree.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='bbar' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>The bottom toolbar of the panel. This can be a {@link Ext.Toolbar} object, a toolbar config, or an array of buttons/button configs to be added to the toolbar. Note that this is not available as a property after render. To access the bottom toolbar after render, use {@link #getBottomToolbar}.</p><p><b>Note:</b> Although a Toolbar may contain Field components, these will <b>not</b> be updated by a load of an ancestor FormPanel. A Panel's toolbars are not part of the standard Container-&gt;Component hierarchy, and so are not scanned to collect form items. However, the values <b>will</b> be submitted because form submission parameters are collected from the DOM tree.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='fbar' minOccurs="0" maxOccurs="1">
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='buttons' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <code>buttons</code> will be used as <code>{@link Ext.Container#items items}</code> for the toolbar in the footer (<code>{@link #fbar}</code>). Typically the value of this configuration property will be an array of {@link Ext.Button}s or {@link Ext.Button} configuration objects. If an item is configured with <code>minWidth</code> or the Panel is configured with <code>minButtonWidth</code>, that width will be applied to the item.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='autoLoad' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A valid url spec according to the Updater {@link Ext.Updater#update} method. If autoLoad is not null, the panel will attempt to load its contents immediately upon render.<p>The URL will become the default URL for this panel's {@link #body} element, so it may be {@link Ext.Element#refresh refresh}ed at any time.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='bodyCssClass' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Additional css class selector to be applied to the {@link #body} element in the format expected by {@link Ext.Element#addClass} (defaults to null). See {@link #bodyCfg}.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='bodyStyle' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Custom CSS styles to be applied to the {@link #body} element in the format expected by {@link Ext.Element#applyStyles} (defaults to null). See {@link #bodyCfg}.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='tools' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an {@link Ext.Element Element} referenced by a public property called <code>tools.<i>&lt;tool-type&gt;</i></code> <p>Each tool config may contain the following properties:</p><div class="mdetail-params"><ul><li><b>id</b> : String<div class="sub-desc"><b>Required.</b> The type of tool to create. By default, this assigns a CSS class of the form <code>x-tool-<i>&lt;tool-type&gt;</i></code> to the resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below. The developer may implement custom tools by supplying alternate CSS rules and background images: <div style="margin-left: 2em"><div><code>toggle</code> (Created by default when {@link #collapsible} is <code>true</code>)</div><div><code>close</code></div><div><code>minimize</code></div><div><code>maximize</code></div><div><code>restore</code></div><div><code>gear</code></div><div><code>pin</code></div><div><code>unpin</code></div><div><code>right</code></div><div><code>left</code></div><div><code>up</code></div><div><code>down</code></div><div><code>refresh</code></div><div><code>minus</code></div><div><code>plus</code></div><div><code>help</code></div><div><code>search</code></div><div><code>save</code></div><div><code>print</code></div></div></div></li><li><b>handler</b> : Function<div class="sub-desc"><b>Required.</b> The function to call when clicked. Arguments passed are:<ul><li><b>event</b> : Ext.EventObject<div class="sub-desc">The click event.</div></li><li><b>toolEl</b> : Ext.Element<div class="sub-desc">The tool Element.</div></li><li><b>panel</b> : Ext.Panel<div class="sub-desc">The host Panel</div></li><li><b>tc</b> : Ext.Panel<div class="sub-desc">The tool configuration object</div></li></ul></div></li><li><b>stopEvent</b> : Boolean<div class="sub-desc">Defaults to true. Specify as false to allow click event to propagate.</div></li><li><b>scope</b> : Object<div class="sub-desc">The scope in which to call the handler.</div></li><li><b>qtip</b> : String/Object<div class="sub-desc">A tip string, or a config argument to {@link Ext.QuickTip#register}</div></li><li><b>hidden</b> : Boolean<div class="sub-desc">True to initially render hidden.</div></li><li><b>on</b> : Object<div class="sub-desc">A listener config object specifiying event listeners in the format of an argument to {@link #addListener}</div></li></ul></div><p>Note that, apart from the toggle tool which is provided when a panel is collapsible, these tools only provide the visual button. Any required functionality must be provided by adding handlers that implement the necessary behavior.</p><p>Example usage:</p><pre><code>tools:[{
id:'refresh',
qtip: 'Refresh form Data',
// hidden:true,
handler: function(event, toolEl, panel){
// refresh logic
}
},
{
id:'help',
qtip: 'Get Help',
handler: function(event, toolEl, panel){
// whatever
}
}]
</code></pre><p>For the custom id of <code>'help'</code> define two relevant css classes with a link to a 15x15 image:</p><pre><code>.x-tool-help {background-image: url(images/help.png);}
.x-tool-help-over {background-image: url(images/help_over.png);}
// if using an image sprite:
.x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
.x-tool-help-over {background-position:-15px 0;}
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='toolTemplate' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A Template used to create {@link #tools} in the {@link #header} Element. Defaults to:</p><pre><code>new Ext.Template('&lt;div class="x-tool x-tool-{id}"&gt;&amp;#160;&lt;/div&gt;')</code></pre><p>This may may be overridden to provide a custom DOM structure for tools based upon a more complex XTemplate. The template's data is a single tool configuration object (Not the entire Array) as specified in {@link #tools}. In the following example an &lt;a&gt; tag is used to provide a visual indication when hovering over the tool:</p><pre><code>var win = new Ext.Window({
tools: [{
id: 'download',
href: '/MyPdfDoc.pdf'
}],
toolTemplate: new Ext.XTemplate(
'&lt;tpl if="id==\'download\'"&gt;',
'&lt;a class="x-tool x-tool-pdf" href="{href}"&gt;&lt;/a&gt;',
'&lt;/tpl&gt;',
'&lt;tpl if="id!=\'download\'"&gt;',
'&lt;div class="x-tool x-tool-{id}"&gt;&amp;#160;&lt;/div&gt;',
'&lt;/tpl&gt;'
),
width:500,
height:300,
closeAction:'hide'
});</code></pre><p>Note that the CSS class 'x-tool-pdf' should have an associated style rule which provides an appropriate background image, something like:</p><pre><code>a.x-tool-pdf {background-image: url(../shared/extjs/images/pdf.gif)!important;}
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='floating' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>This property is used to configure the underlying {@link Ext.Layer}. Acceptable values for this configuration property are:</p><div class="mdetail-params"><ul><li><b><code>false</code></b> : <b>Default.</b><div class="sub-desc">Display the panel inline where it is rendered.</div></li><li><b><code>true</code></b> : <div class="sub-desc">Float the panel (absolute position it with automatic shimming and shadow).<div style="margin-left: 2em"><div class="sub-desc">Setting floating to true will create an Ext.Layer for this panel and display the panel at negative offsets so that it is hidden.</div><div class="sub-desc">Since the panel will be absolute positioned, the position must be set explicitly <i>after</i> render (e.g., <code>myPanel.setPosition(100,100);</code>).</div><div class="sub-desc"><b>Note</b>: when floating a panel you should always assign a fixed width, otherwise it will be auto width and will expand to fill to the right edge of the viewport.</div></div></div></li><li><b><code>{@link Ext.Layer object}</code></b> : <div class="sub-desc">The specified object will be used as the configuration object for the {@link Ext.Layer} that will be created.</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='html' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An HTML fragment, or a {@link Ext.DomHelper DomHelper} specification to use as the panel's body content (defaults to ''). The HTML content is added by the Panel's {@link #afterRender} method, and so the document will not contain this HTML at the time the {@link #render} event is fired. This content is inserted into the body <i>before</i> any configured {@link #contentEl} is appended.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='keys' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A {@link Ext.KeyMap} config object (in the format expected by {@link Ext.KeyMap#addBinding} used to assign custom key handling to this panel (defaults to <code>null</code>).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='draggable' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p><code>true</code> to enable dragging of this Panel (defaults to <code>false</code>).</p><p>For custom drag/drop implementations, an <b>Ext.Panel.DD</b> config could also be passed in this config instead of <code>true</code>. Ext.Panel.DD is an internal, undocumented class which moves a proxy Element around in place of the Panel's element, but provides no other behaviour during dragging or on drop. It is a subclass of {@link Ext.dd.DragSource}, so behaviour may be added by implementing the interface methods of {@link Ext.dd.DragDrop} e.g.:</p><pre><code>new Ext.Panel({
title: 'Drag me',
x: 100,
y: 100,
renderTo: Ext.getBody(),
floating: true,
frame: true,
width: 400,
height: 200,
draggable: {
//      Config option of Ext.Panel.DD class.
//      It's a floating Panel, so do not show a placeholder proxy in the original position.
insertProxy: false,

//      Called for each mousemove event while dragging the DD object.
onDrag : function(e){
//          Record the x,y position of the drag proxy so that we can
//          position the Panel at end of drag.
var pel = this.proxy.getEl();
this.x = pel.getLeft(true);
this.y = pel.getTop(true);

//          Keep the Shadow aligned if there is one.
var s = this.panel.getEl().shadow;
if (s) {
s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
}
},

//      Called on the mouseup event.
endDrag : function(e){
this.panel.setPosition(this.x, this.y);
}
}
}).show();
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='bodyCfg'>
          <xs:annotation>
            <xs:documentation>
<p>A {@link Ext.DomHelper DomHelper} element specification object may be specified for any Panel Element.</p><p>By default, the Default element in the table below will be used for the html markup to create a child element with the commensurate Default class name (<code>baseCls</code> will be replaced by <code>{@link #baseCls}</code>):</p><pre>Panel      Default  Default             Custom      Additional       Additional
Element    element  class               element     class            style
========   ==========================   =========   ==============   ===========
{@link #header}     div      {@link #baseCls}+'-header'   {@link #headerCfg}   headerCssClass   headerStyle
{@link #bwrap}      div      {@link #baseCls}+'-bwrap'     {@link #bwrapCfg}    bwrapCssClass    bwrapStyle
+ tbar     div      {@link #baseCls}+'-tbar'       {@link #tbarCfg}     tbarCssClass     tbarStyle
+ {@link #body}     div      {@link #baseCls}+'-body'       {@link #bodyCfg}     {@link #bodyCssClass}     {@link #bodyStyle}
+ bbar     div      {@link #baseCls}+'-bbar'       {@link #bbarCfg}     bbarCssClass     bbarStyle
+ {@link #footer}   div      {@link #baseCls}+'-footer'   {@link #footerCfg}   footerCssClass   footerStyle
</pre><p>Configuring a Custom element may be used, for example, to force the {@link #body} Element to use a different form of markup than is created by default. An example of this might be to {@link Ext.Element#createChild create a child} Panel containing a custom content, such as a header, or forcing centering of all Panel content by having the body be a &lt;center&gt; element:</p><pre><code>new Ext.Panel({
title: 'Message Title',
renderTo: Ext.getBody(),
width: 200, height: 130,
<b>bodyCfg</b>: {
tag: 'center',
cls: 'x-panel-body',  // Default class not applied if Custom element specified
html: 'Message'
},
footerCfg: {
tag: 'h2',
cls: 'x-panel-footer'        // same as the Default class
html: 'footer html'
},
footerCssClass: 'custom-footer', // additional css class, see {@link Ext.element#addClass addClass}
footerStyle:    'background-color:red' // see {@link #bodyStyle}
});
</code></pre><p>The example above also explicitly creates a <code>{@link #footer}</code> with custom markup and styling applied.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='headerCfg'>
          <xs:annotation>
            <xs:documentation>
<p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #header} Element. See <code>{@link #bodyCfg}</code> also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bwrapCfg'>
          <xs:annotation>
            <xs:documentation>
<p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #bwrap} Element. See <code>{@link #bodyCfg}</code> also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tbarCfg'>
          <xs:annotation>
            <xs:documentation>
<p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #tbar} Element. See <code>{@link #bodyCfg}</code> also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bbarCfg'>
          <xs:annotation>
            <xs:documentation>
<p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #bbar} Element. See <code>{@link #bodyCfg}</code> also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='footerCfg'>
          <xs:annotation>
            <xs:documentation>
<p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #footer} Element. See <code>{@link #bodyCfg}</code> also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='closable'>
          <xs:annotation>
            <xs:documentation>
Panels themselves do not directly support being closed, but some Panel subclasses do (like {@link Ext.Window}) or a Panel Class within an {@link Ext.TabPanel}. Specify <code>true</code> to enable closing in such situations. Defaults to <code>false</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tbar'>
          <xs:annotation>
            <xs:documentation>
<p>The top toolbar of the panel. This can be a {@link Ext.Toolbar} object, a toolbar config, or an array of buttons/button configs to be added to the toolbar. Note that this is not available as a property after render. To access the top toolbar after render, use {@link #getTopToolbar}.</p><p><b>Note:</b> Although a Toolbar may contain Field components, these will <b>not</b> be updated by a load of an ancestor FormPanel. A Panel's toolbars are not part of the standard Container-&gt;Component hierarchy, and so are not scanned to collect form items. However, the values <b>will</b> be submitted because form submission parameters are collected from the DOM tree.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bbar'>
          <xs:annotation>
            <xs:documentation>
<p>The bottom toolbar of the panel. This can be a {@link Ext.Toolbar} object, a toolbar config, or an array of buttons/button configs to be added to the toolbar. Note that this is not available as a property after render. To access the bottom toolbar after render, use {@link #getBottomToolbar}.</p><p><b>Note:</b> Although a Toolbar may contain Field components, these will <b>not</b> be updated by a load of an ancestor FormPanel. A Panel's toolbars are not part of the standard Container-&gt;Component hierarchy, and so are not scanned to collect form items. However, the values <b>will</b> be submitted because form submission parameters are collected from the DOM tree.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='fbar'>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='header'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to create the Panel's header element explicitly, <code>false</code> to skip creating it. If a <code>{@link #title}</code> is set the header will be created automatically, otherwise it will not. If a <code>{@link #title}</code> is set but <code>header</code> is explicitly set to <code>false</code>, the header will not be rendered.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='footer'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to create the footer element explicitly, false to skip creating it. The footer will be created automatically if <code>{@link #buttons}</code> or a <code>{@link #fbar}</code> have been configured. See <code>{@link #bodyCfg}</code> for an example.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='title'>
          <xs:annotation>
            <xs:documentation>
The title text to be used as innerHTML (html tags are accepted) to display in the panel <code>{@link #header}</code> (defaults to ''). When a <code>title</code> is specified the <code>{@link #header}</code> element will automatically be created and displayed unless {@link #header} is explicitly set to <code>false</code>. If you do not want to specify a <code>title</code> at config time, but you may want one later, you must either specify a non-empty <code>title</code> (a blank space ' ' will do) or <code>header:true</code> so that the container element will get created.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='buttons'>
          <xs:annotation>
            <xs:documentation>
<code>buttons</code> will be used as <code>{@link Ext.Container#items items}</code> for the toolbar in the footer (<code>{@link #fbar}</code>). Typically the value of this configuration property will be an array of {@link Ext.Button}s or {@link Ext.Button} configuration objects. If an item is configured with <code>minWidth</code> or the Panel is configured with <code>minButtonWidth</code>, that width will be applied to the item.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='autoLoad'>
          <xs:annotation>
            <xs:documentation>
A valid url spec according to the Updater {@link Ext.Updater#update} method. If autoLoad is not null, the panel will attempt to load its contents immediately upon render.<p>The URL will become the default URL for this panel's {@link #body} element, so it may be {@link Ext.Element#refresh refresh}ed at any time.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='frame'>
          <xs:annotation>
            <xs:documentation>
<code>false</code> by default to render with plain 1px square borders. <code>true</code> to render with 9 elements, complete with custom rounded corners (also see {@link Ext.Element#boxWrap}). <p>The template generated for each condition is depicted below:</p><pre><code>
// frame = false
&lt;div id="developer-specified-id-goes-here" class="x-panel"&gt;

&lt;div class="x-panel-header"&gt;&lt;span class="x-panel-header-text"&gt;Title: (frame:false)&lt;/span&gt;&lt;/div&gt;

&lt;div class="x-panel-bwrap"&gt;
&lt;div class="x-panel-body"&gt;&lt;p&gt;html value goes here&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

// frame = true (create 9 elements)
&lt;div id="developer-specified-id-goes-here" class="x-panel"&gt;
&lt;div class="x-panel-tl"&gt;&lt;div class="x-panel-tr"&gt;&lt;div class="x-panel-tc"&gt;
&lt;div class="x-panel-header"&gt;&lt;span class="x-panel-header-text"&gt;Title: (frame:true)&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class="x-panel-bwrap"&gt;
&lt;div class="x-panel-ml"&gt;&lt;div class="x-panel-mr"&gt;&lt;div class="x-panel-mc"&gt;
&lt;div class="x-panel-body"&gt;&lt;p&gt;html value goes here&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class="x-panel-bl"&gt;&lt;div class="x-panel-br"&gt;&lt;div class="x-panel-bc"/&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='border'>
          <xs:annotation>
            <xs:documentation>
True to display the borders of the panel's body element, false to hide them (defaults to true). By default, the border is a 2px wide inset border, but this can be further altered by setting {@link #bodyBorder} to false.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='bodyBorder'>
          <xs:annotation>
            <xs:documentation>
True to display an interior border on the body element of the panel, false to hide it (defaults to true). This only applies when {@link #border} == true. If border == true and bodyBorder == false, the border will display as a 1px wide inset border, giving the entire body element an inset appearance.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bodyCssClass'>
          <xs:annotation>
            <xs:documentation>
Additional css class selector to be applied to the {@link #body} element in the format expected by {@link Ext.Element#addClass} (defaults to null). See {@link #bodyCfg}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bodyStyle'>
          <xs:annotation>
            <xs:documentation>
Custom CSS styles to be applied to the {@link #body} element in the format expected by {@link Ext.Element#applyStyles} (defaults to null). See {@link #bodyCfg}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='iconCls'>
          <xs:annotation>
            <xs:documentation>
The CSS class selector that specifies a background image to be used as the header icon (defaults to ''). <p>An example of specifying a custom icon class would be something like:</p><pre><code>// specify the property in the config for the class:
...
iconCls: 'my-icon'

// css class that specifies background image to be used as the icon image:
.my-icon { background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='collapsible'>
          <xs:annotation>
            <xs:documentation>
True to make the panel collapsible and have the expand/collapse toggle button automatically rendered into the header tool button area, false to keep the panel statically sized with no button (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tools'>
          <xs:annotation>
            <xs:documentation>
An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an {@link Ext.Element Element} referenced by a public property called <code>tools.<i>&lt;tool-type&gt;</i></code> <p>Each tool config may contain the following properties:</p><div class="mdetail-params"><ul><li><b>id</b> : String<div class="sub-desc"><b>Required.</b> The type of tool to create. By default, this assigns a CSS class of the form <code>x-tool-<i>&lt;tool-type&gt;</i></code> to the resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below. The developer may implement custom tools by supplying alternate CSS rules and background images: <div style="margin-left: 2em"><div><code>toggle</code> (Created by default when {@link #collapsible} is <code>true</code>)</div><div><code>close</code></div><div><code>minimize</code></div><div><code>maximize</code></div><div><code>restore</code></div><div><code>gear</code></div><div><code>pin</code></div><div><code>unpin</code></div><div><code>right</code></div><div><code>left</code></div><div><code>up</code></div><div><code>down</code></div><div><code>refresh</code></div><div><code>minus</code></div><div><code>plus</code></div><div><code>help</code></div><div><code>search</code></div><div><code>save</code></div><div><code>print</code></div></div></div></li><li><b>handler</b> : Function<div class="sub-desc"><b>Required.</b> The function to call when clicked. Arguments passed are:<ul><li><b>event</b> : Ext.EventObject<div class="sub-desc">The click event.</div></li><li><b>toolEl</b> : Ext.Element<div class="sub-desc">The tool Element.</div></li><li><b>panel</b> : Ext.Panel<div class="sub-desc">The host Panel</div></li><li><b>tc</b> : Ext.Panel<div class="sub-desc">The tool configuration object</div></li></ul></div></li><li><b>stopEvent</b> : Boolean<div class="sub-desc">Defaults to true. Specify as false to allow click event to propagate.</div></li><li><b>scope</b> : Object<div class="sub-desc">The scope in which to call the handler.</div></li><li><b>qtip</b> : String/Object<div class="sub-desc">A tip string, or a config argument to {@link Ext.QuickTip#register}</div></li><li><b>hidden</b> : Boolean<div class="sub-desc">True to initially render hidden.</div></li><li><b>on</b> : Object<div class="sub-desc">A listener config object specifiying event listeners in the format of an argument to {@link #addListener}</div></li></ul></div><p>Note that, apart from the toggle tool which is provided when a panel is collapsible, these tools only provide the visual button. Any required functionality must be provided by adding handlers that implement the necessary behavior.</p><p>Example usage:</p><pre><code>tools:[{
id:'refresh',
qtip: 'Refresh form Data',
// hidden:true,
handler: function(event, toolEl, panel){
// refresh logic
}
},
{
id:'help',
qtip: 'Get Help',
handler: function(event, toolEl, panel){
// whatever
}
}]
</code></pre><p>For the custom id of <code>'help'</code> define two relevant css classes with a link to a 15x15 image:</p><pre><code>.x-tool-help {background-image: url(images/help.png);}
.x-tool-help-over {background-image: url(images/help_over.png);}
// if using an image sprite:
.x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
.x-tool-help-over {background-position:-15px 0;}
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='toolTemplate'>
          <xs:annotation>
            <xs:documentation>
<p>A Template used to create {@link #tools} in the {@link #header} Element. Defaults to:</p><pre><code>new Ext.Template('&lt;div class="x-tool x-tool-{id}"&gt;&amp;#160;&lt;/div&gt;')</code></pre><p>This may may be overridden to provide a custom DOM structure for tools based upon a more complex XTemplate. The template's data is a single tool configuration object (Not the entire Array) as specified in {@link #tools}. In the following example an &lt;a&gt; tag is used to provide a visual indication when hovering over the tool:</p><pre><code>var win = new Ext.Window({
tools: [{
id: 'download',
href: '/MyPdfDoc.pdf'
}],
toolTemplate: new Ext.XTemplate(
'&lt;tpl if="id==\'download\'"&gt;',
'&lt;a class="x-tool x-tool-pdf" href="{href}"&gt;&lt;/a&gt;',
'&lt;/tpl&gt;',
'&lt;tpl if="id!=\'download\'"&gt;',
'&lt;div class="x-tool x-tool-{id}"&gt;&amp;#160;&lt;/div&gt;',
'&lt;/tpl&gt;'
),
width:500,
height:300,
closeAction:'hide'
});</code></pre><p>Note that the CSS class 'x-tool-pdf' should have an associated style rule which provides an appropriate background image, something like:</p><pre><code>a.x-tool-pdf {background-image: url(../shared/extjs/images/pdf.gif)!important;}
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideCollapseTool'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to hide the expand/collapse toggle button when <code>{@link #collapsible} == true</code>, <code>false</code> to display it (defaults to <code>false</code>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='titleCollapse'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to allow expanding and collapsing the panel (when <code>{@link #collapsible} = true</code>) by clicking anywhere in the header bar, <code>false</code>) to allow it only by clicking to tool button (defaults to <code>false</code>)). If this panel is a child item of a border layout also see the {@link Ext.layout.BorderLayout.Region BorderLayout.Region} <code>{@link Ext.layout.BorderLayout.Region#floatable floatable}</code> config option.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoScroll'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to use overflow:'auto' on the panel's body element and show scroll bars automatically when necessary, <code>false</code> to clip any overflowing content (defaults to <code>false</code>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='floating'>
          <xs:annotation>
            <xs:documentation>
<p>This property is used to configure the underlying {@link Ext.Layer}. Acceptable values for this configuration property are:</p><div class="mdetail-params"><ul><li><b><code>false</code></b> : <b>Default.</b><div class="sub-desc">Display the panel inline where it is rendered.</div></li><li><b><code>true</code></b> : <div class="sub-desc">Float the panel (absolute position it with automatic shimming and shadow).<div style="margin-left: 2em"><div class="sub-desc">Setting floating to true will create an Ext.Layer for this panel and display the panel at negative offsets so that it is hidden.</div><div class="sub-desc">Since the panel will be absolute positioned, the position must be set explicitly <i>after</i> render (e.g., <code>myPanel.setPosition(100,100);</code>).</div><div class="sub-desc"><b>Note</b>: when floating a panel you should always assign a fixed width, otherwise it will be auto width and will expand to fill to the right edge of the viewport.</div></div></div></li><li><b><code>{@link Ext.Layer object}</code></b> : <div class="sub-desc">The specified object will be used as the configuration object for the {@link Ext.Layer} that will be created.</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='shadow'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> (or a valid Ext.Shadow {@link Ext.Shadow#mode} value) to display a shadow behind the panel, <code>false</code> to display no shadow (defaults to <code>'sides'</code>). Note that this option only applies when <code>{@link #floating} = true</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='shadowOffset'>
          <xs:annotation>
            <xs:documentation>
The number of pixels to offset the shadow if displayed (defaults to <code>4</code>). Note that this option only applies when <code>{@link #floating} = true</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='shim'>
          <xs:annotation>
            <xs:documentation>
<code>false</code> to disable the iframe shim in browsers which need one (defaults to <code>true</code>). Note that this option only applies when <code>{@link #floating} = true</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='html'>
          <xs:annotation>
            <xs:documentation>
An HTML fragment, or a {@link Ext.DomHelper DomHelper} specification to use as the panel's body content (defaults to ''). The HTML content is added by the Panel's {@link #afterRender} method, and so the document will not contain this HTML at the time the {@link #render} event is fired. This content is inserted into the body <i>before</i> any configured {@link #contentEl} is appended.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='contentEl'>
          <xs:annotation>
            <xs:documentation>
<p>Optional. Specify an existing HTML element, or the <code>id</code> of an existing HTML element to use as this Panel's <code><b>{@link #body}</b></code> content.</p><ul><li><b>Description</b> : <div class="sub-desc">This config option is used to take an existing HTML element and place it in the body of a new panel (it simply moves the specified DOM element into the body element of the Panel <i>after the Panel is rendered</i> to use as the content (it is not going to be the actual panel itself).</div></li><li><b>Notes</b> : <div class="sub-desc">The specified HTML element is appended to the Panel's {@link #body} Element by the Panel's <code>afterRender</code> method <i>after any configured {@link #html HTML} has been inserted</i>, and so the document will not contain this element at the time the {@link #render} event is fired.</div><div class="sub-desc">The specified HTML element used will not participate in any <code><b>{@link Ext.Container#layout layout}</b></code> scheme that the Panel may use. It is just HTML. Layouts operate on child <code><b>{@link Ext.Container#items items}</b></code>.</div><div class="sub-desc">Add either the <code>x-hidden</code> or the <code>x-hide-display</code> CSS class to prevent a brief flicker of the content before it is rendered to the panel.</div></li></ul>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='keys'>
          <xs:annotation>
            <xs:documentation>
A {@link Ext.KeyMap} config object (in the format expected by {@link Ext.KeyMap#addBinding} used to assign custom key handling to this panel (defaults to <code>null</code>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='draggable'>
          <xs:annotation>
            <xs:documentation>
<p><code>true</code> to enable dragging of this Panel (defaults to <code>false</code>).</p><p>For custom drag/drop implementations, an <b>Ext.Panel.DD</b> config could also be passed in this config instead of <code>true</code>. Ext.Panel.DD is an internal, undocumented class which moves a proxy Element around in place of the Panel's element, but provides no other behaviour during dragging or on drop. It is a subclass of {@link Ext.dd.DragSource}, so behaviour may be added by implementing the interface methods of {@link Ext.dd.DragDrop} e.g.:</p><pre><code>new Ext.Panel({
title: 'Drag me',
x: 100,
y: 100,
renderTo: Ext.getBody(),
floating: true,
frame: true,
width: 400,
height: 200,
draggable: {
//      Config option of Ext.Panel.DD class.
//      It's a floating Panel, so do not show a placeholder proxy in the original position.
insertProxy: false,

//      Called for each mousemove event while dragging the DD object.
onDrag : function(e){
//          Record the x,y position of the drag proxy so that we can
//          position the Panel at end of drag.
var pel = this.proxy.getEl();
this.x = pel.getLeft(true);
this.y = pel.getTop(true);

//          Keep the Shadow aligned if there is one.
var s = this.panel.getEl().shadow;
if (s) {
s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
}
},

//      Called on the mouseup event.
endDrag : function(e){
this.panel.setPosition(this.x, this.y);
}
}
}).show();
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='baseCls'>
          <xs:annotation>
            <xs:documentation>
The base CSS class to apply to this panel's element (defaults to <code>'x-panel'</code>). <p>Another option available by default is to specify <code>'x-plain'</code> which strips all styling except for required attributes for Ext layouts to function (e.g. overflow:hidden). See <code>{@link #unstyled}</code> also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='collapsedCls'>
          <xs:annotation>
            <xs:documentation>
A CSS class to add to the panel's element after it has been collapsed (defaults to <code>'x-panel-collapsed'</code>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='maskDisabled'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to mask the panel when it is {@link #disabled}, <code>false</code> to not mask it (defaults to <code>true</code>). Either way, the panel will always tell its contained elements to disable themselves when it is disabled, but masking the panel can provide an additional visual cue that the panel is disabled.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='animCollapse'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to animate the transition when the panel is collapsed, <code>false</code> to skip the animation (defaults to <code>true</code> if the {@link Ext.Fx} class is available, otherwise <code>false</code>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='headerAsText'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to display the panel <code>{@link #title}</code> in the <code>{@link #header}</code>, <code>false</code> to hide it (defaults to <code>true</code>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='buttonAlign'>
          <xs:annotation>
            <xs:documentation>
The alignment of any {@link #buttons} added to this panel. Valid values are <code>'right'</code>, <code>'left'</code> and <code>'center'</code> (defaults to <code>'right'</code>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='collapsed'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to render the panel collapsed, <code>false</code> to render it expanded (defaults to <code>false</code>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='collapseFirst'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in the panel's title bar, <code>false</code> to render it last (defaults to <code>true</code>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minButtonWidth'>
          <xs:annotation>
            <xs:documentation>
Minimum width in pixels of all {@link #buttons} in this panel (defaults to <code>75</code>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='unstyled'>
          <xs:annotation>
            <xs:documentation>
Overrides the <code>{@link #baseCls}</code> setting to <code>{@link #baseCls} = 'x-plain'</code> which renders the panel unstyled except for required attributes for Ext layouts to function (e.g. overflow:hidden).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='elements'>
          <xs:annotation>
            <xs:documentation>
A comma-delimited list of panel elements to initialize when the panel is rendered. Normally, this list will be generated automatically based on the items added to the panel at config time, but sometimes it might be useful to make sure a structural element is rendered even if not specified at config time (for example, you may want to add a button or toolbar dynamically after the panel has been rendered). Adding those elements to this list will allocate the required placeholders in the panel when it is rendered. Valid values are<div class="mdetail-params"><ul><li><code>header</code></li><li><code>tbar</code> (top bar)</li><li><code>body</code></li><li><code>bbar</code> (bottom bar)</li><li><code>footer</code></li></ul></div>Defaults to '<code>body</code>'.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='preventBodyReset'>
          <xs:annotation>
            <xs:documentation>
Defaults to <code>false</code>. When set to <code>true</code>, an extra css class <code>'x-panel-normal'</code> will be added to the panel's element, effectively applying css styles suggested by the W3C (see http://www.w3.org/TR/CSS21/sample.html) to the Panel's <b>body</b> element (not the header, footer, etc.).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='panel' name='panel' type='ext:ext.Panel' substitutionGroup='ext:container'>
    <xs:annotation>
      <xs:documentation>
<p>Panel is a container that has specific functionality and structural components that make it the perfect building block for application-oriented user interfaces.</p><p>Panels are, by virtue of their inheritance from {@link Ext.Container}, capable of being configured with a {@link Ext.Container#layout layout}, and containing child Components.</p><p>When either specifying child {@link Ext.Component#items items} of a Panel, or dynamically {@link Ext.Container#add adding} Components to a Panel, remember to consider how you wish the Panel to arrange those child elements, and whether those child elements need to be sized using one of Ext's built-in <code><b>{@link Ext.Container#layout layout}</b></code> schemes. By default, Panels use the {@link Ext.layout.ContainerLayout ContainerLayout} scheme. This simply renders child components, appending them one after the other inside the Container, and <b>does not apply any sizing</b> at all.</p><p>A Panel may also contain {@link #bbar bottom} and {@link #tbar top} toolbars, along with separate {@link #header}, {@link #footer} and {@link #body} sections (see {@link #frame} for additional information).</p><p>Panel also provides built-in {@link #collapsible expandable and collapsible behavior}, along with a variety of {@link #tools prebuilt tool buttons} that can be wired up to provide other customized behavior. Panels can be easily dropped into any {@link Ext.Container Container} or layout, and the layout and rendering pipeline is {@link Ext.Container#add completely managed by the framework}.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.chart.PieChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.Chart'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='piechart' name='piechart' type='ext:ext.chart.PieChart' substitutionGroup='ext:chart'>
  </xs:element>
  <xs:complexType name='ext.ProgressBar'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
            <xs:element name='textEl' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The element to render the progress text to (defaults to the progress bar's internal text element)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:float' name='value'>
          <xs:annotation>
            <xs:documentation>
A floating point value between 0 and 1 (e.g., .5, defaults to 0)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='text'>
          <xs:annotation>
            <xs:documentation>
The progress bar text (defaults to '')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='textEl'>
          <xs:annotation>
            <xs:documentation>
The element to render the progress text to (defaults to the progress bar's internal text element)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='baseCls'>
          <xs:annotation>
            <xs:documentation>
The base CSS class to apply to the progress bar's wrapper element (defaults to 'x-progress')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='animate'>
          <xs:annotation>
            <xs:documentation>
True to animate the progress bar during transitions (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='progress' name='progress' type='ext:ext.ProgressBar' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
<p>An updateable progress bar component. The progress bar supports two different modes: manual and automatic.</p><p>In manual mode, you are responsible for showing, updating (via {@link #updateProgress}) and clearing the progress bar as needed from your own code. This method is most appropriate when you want to show progress throughout an operation that has predictable points of interest at which you can update the control.</p><p>In automatic mode, you simply call {@link #wait} and let the progress bar run indefinitely, only clearing it once the operation is complete. You can optionally have the progress bar wait for a specific amount of time and then clear itself. Automatic mode is most appropriate for timed operations or asynchronous operations in which you have no need for indicating intermediate progress.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.QuickTip'>
    <xs:complexContent>
      <xs:extension base='ext:ext.ToolTip'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='interceptTitles'>
          <xs:annotation>
            <xs:documentation>
True to automatically use the element's DOM title value if available (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='quicktip' name='quicktip' type='ext:ext.QuickTip' substitutionGroup='ext:tooltip'>
    <xs:annotation>
      <xs:documentation>
A specialized tooltip class for tooltips that can be specified in markup and automatically managed by the global {@link Ext.QuickTips} instance. See the QuickTips class header for additional usage details and examples.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.Radio'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Checkbox'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='radio' name='radio' type='ext:ext.form.Radio' substitutionGroup='ext:checkbox'>
    <xs:annotation>
      <xs:documentation>
Single radio field. Same as Checkbox, but provided as a convenience for automatically setting the input type. Radio grouping is handled automatically by the browser if you give each radio in a group the same name.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.RadioGroup'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.CheckboxGroup'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='radiogroup' name='radiogroup' type='ext:ext.form.RadioGroup' substitutionGroup='ext:checkboxgroup'>
    <xs:annotation>
      <xs:documentation>
A grouping container for {@link Ext.form.Radio} controls.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Slider'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:int' name='value'>
          <xs:annotation>
            <xs:documentation>
The value to initialize the slider with. Defaults to minValue.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='vertical'>
          <xs:annotation>
            <xs:documentation>
Orient the Slider vertically rather than horizontally, defaults to false.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minValue'>
          <xs:annotation>
            <xs:documentation>
The minimum value for the Slider. Defaults to 0.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxValue'>
          <xs:annotation>
            <xs:documentation>
The maximum value for the Slider. Defaults to 100.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='decimalPrecision'>
          <xs:annotation>
            <xs:documentation>
. <p>The number of decimal places to which to round the Slider's value. Defaults to 0.</p><p>To disable rounding, configure as <tt><b>false</b></tt>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='keyIncrement'>
          <xs:annotation>
            <xs:documentation>
How many units to change the Slider when adjusting with keyboard navigation. Defaults to 1. If the increment config is larger, it will be used instead.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='increment'>
          <xs:annotation>
            <xs:documentation>
How many units to change the slider when adjusting by drag and drop. Use this option to enable 'snapping'.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='clickToChange'>
          <xs:annotation>
            <xs:documentation>
Determines whether or not clicking on the Slider axis will change the slider. Defaults to true
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='animate'>
          <xs:annotation>
            <xs:documentation>
Turn on or off animation. Defaults to true
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='slider' name='slider' type='ext:ext.Slider' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
Slider which supports vertical or horizontal orientation, keyboard adjustments, configurable snapping, axis clicking and animation. Can be added as an item to any container. Example usage: <pre><code>new Ext.Slider({
renderTo: Ext.getBody(),
width: 200,
value: 50,
increment: 10,
minValue: 0,
maxValue: 100
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Spacer'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='spacer' name='spacer' type='ext:ext.Spacer' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
<p>Used to provide a sizable space in a layout.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.SplitButton'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Button'>
        <xs:sequence>
            <xs:element name='arrowHandler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A function called when the arrow button is clicked (can be used instead of click event)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='arrowHandler'>
          <xs:annotation>
            <xs:documentation>
A function called when the arrow button is clicked (can be used instead of click event)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='arrowTooltip'>
          <xs:annotation>
            <xs:documentation>
The title attribute of the arrow
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='splitbutton' name='splitbutton' type='ext:ext.SplitButton' substitutionGroup='ext:button'>
    <xs:annotation>
      <xs:documentation>
A split button that provides a built-in dropdown arrow that can fire an event separately from the default click event of the button. Typically this would be used to display a dropdown menu that provides additional options to the primary button action, but any custom handler can provide the arrowclick implementation. Example usage: <pre><code>// display a dropdown menu:
new Ext.SplitButton({
renderTo: 'button-ct', // the container id
text: 'Options',
handler: optionsHandler, // handle a click on the button itself
menu: new Ext.menu.Menu({
items: [
// these items will render as dropdown menu items when the arrow is clicked:
{text: 'Item 1', handler: item1Handler},
{text: 'Item 2', handler: item2Handler}
]
})
});

// Instead of showing a menu, you provide any type of custom
// functionality you want when the dropdown arrow is clicked:
new Ext.SplitButton({
renderTo: 'button-ct',
text: 'Options',
handler: optionsHandler,
arrowHandler: myCustomHandler
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.chart.StackedBarChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.CartesianChart'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='stackedbarchart' name='stackedbarchart' type='ext:ext.chart.StackedBarChart' substitutionGroup='ext:cartesianchart'>
  </xs:element>
  <xs:complexType name='ext.chart.StackedColumnChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.CartesianChart'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='stackedcolumnchart' name='stackedcolumnchart' type='ext:ext.chart.StackedColumnChart' substitutionGroup='ext:cartesianchart'>
  </xs:element>
  <xs:complexType name='ext.data.Store'>
    <xs:complexContent>
      <xs:extension base='ext:ext.util.Observable'>
        <xs:sequence>
            <xs:element name='autoLoad' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    If <tt>{@link #data}</tt> is not specified, and if <tt>autoLoad</tt> is <tt>true</tt> or an <tt>Object</tt>, this store's {@link #load} method is automatically called after creation. If the value of <tt>autoLoad</tt> is an <tt>Object</tt>, this <tt>Object</tt> will be passed to the store's {@link #load} method.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='proxy' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The {@link Ext.data.DataProxy DataProxy} object which provides access to a data object. See <code>{@link #url}</code>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='data' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An inline data object readable by the <code>{@link #reader}</code>. Typically this option, or the <code>{@link #url}</code> option will be specified.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='reader' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The {@link Ext.data.DataReader Reader} object which processes the data object and returns an Array of {@link Ext.data.Record} objects which are cached keyed by their <b><tt>{@link Ext.data.Record#id id}</tt></b> property.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='writer' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>The {@link Ext.data.DataWriter Writer} object which processes a record object for being written to the server-side database.</p><br/><p>When a writer is installed into a Store the {@link #add}, {@link #remove}, and {@link #update} events on the store are monitored in order to remotely {@link #createRecords create records}, {@link #destroyRecord destroy records}, or {@link #updateRecord update records}.</p><br/><p>The proxy for this store will relay any {@link #writexception} events to this store.</p><br/><p>Sample implementation:</p><pre><code>var writer = new {@link Ext.data.JsonWriter}({
encode: true,
writeAllFields: true // write all fields, not just those that changed
});

// Typical Store collecting the Proxy, Reader and Writer together.
var store = new Ext.data.Store({
storeId: 'user',
root: 'records',
proxy: proxy,
reader: reader,
writer: writer,     // &lt;-- plug a DataWriter into the store just as you would a Reader
paramsAsHash: true,
autoSave: false    // &lt;-- false to delay executing create, update, destroy requests
//     until specifically told to do so.
});
</code></pre><br/><br/>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='baseParams' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>An object containing properties which are to be sent as parameters for <i>every</i> HTTP request.</p><p>Parameters are encoded as standard HTTP parameters using {@link Ext#urlEncode}.</p><p><b>Note</b>: <code>baseParams</code> may be superseded by any <code>params</code> specified in a <code>{@link #load}</code> request, see <code>{@link #load}</code> for more details.</p>This property may be modified after creation using the <code>{@link #setBaseParam}</code> method. @property
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='sortInfo' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A config object to specify the sort order in the request of a Store's {@link #load} operation. Note that for local sorting, the <tt>direction</tt> property is case-sensitive. See also {@link #remoteSort} and {@link #paramNames}. For example:<pre><code>sortInfo: {
field: 'fieldName',
direction: 'ASC' // or 'DESC' (case sensitive for local sorting)
}
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='remoteSort' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <tt>true</tt> if sorting is to be handled by requesting the <tt>{@link #proxy Proxy}</tt> to provide a refreshed version of the data object in sorted order, as opposed to sorting the Record cache in place (defaults to <tt>false</tt>). <p>If <tt>remoteSort</tt> is <tt>true</tt>, then clicking on a {@link Ext.grid.Column Grid Column}'s {@link Ext.grid.Column#header header} causes the current page to be requested from the server appending the following two parameters to the <b><tt>{@link #load params}</tt></b>:</p><div class="mdetail-params"><ul><li><b><tt>sort</tt></b> : String<p class="sub-desc">The <tt>name</tt> (as specified in the Record's {@link Ext.data.Field Field definition}) of the field to sort on.</p></li><li><b><tt>dir</tt></b> : String<p class="sub-desc">The direction of the sort, 'ASC' or 'DESC' (case-sensitive).</p></li></ul></div><br/><br/>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='paramNames' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>An object containing properties which specify the names of the paging and sorting parameters passed to remote servers when loading blocks of data. By default, this object takes the following form:</p><pre><code>{
start : 'start',  // The parameter name which specifies the start row
limit : 'limit',  // The parameter name which specifies number of rows to return
sort : 'sort',    // The parameter name which specifies the column to sort on
dir : 'dir'       // The parameter name which specifies the sort direction
}
</code></pre><p>The server must produce the requested data block upon receipt of these parameter names. If different parameter names are required, this property can be overriden using a configuration property.</p><p>A {@link Ext.PagingToolbar PagingToolbar} bound to this Store uses this property to determine the parameter names to use in its {@link #load requests}.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='defaultParamNames' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Provides the default values for the {@link #paramNames} property. To globally modify the parameters for all stores, this object should be changed on the store prototype.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='defined' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    . Should be easy now. Saves all pending changes to the store. If the commensurate Ext.data.Api.actions action is not configured, then the configured <code>{@link #url}</code> will be used. <pre>change            url
---------------   --------------------
removed records   Ext.data.Api.actions.destroy
phantom records   Ext.data.Api.actions.create
{@link #getModifiedRecords modified records}  Ext.data.Api.actions.update
</pre>@TODO: Create extensions of Error class and send associated Record with thrown exceptions. e.g.: Ext.data.DataReader.Error or Ext.data.Error or Ext.data.DataProxy.Error, etc.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='storeId'>
          <xs:annotation>
            <xs:documentation>
If passed, the id to use to register with the <b>{@link Ext.StoreMgr StoreMgr}</b>. <p><b>Note</b>: if a (deprecated) <tt>{@link #id}</tt> is specified it will supersede the <tt>storeId</tt> assignment.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='url'>
          <xs:annotation>
            <xs:documentation>
If a <tt>{@link #proxy}</tt> is not specified the <tt>url</tt> will be used to implicitly configure a {@link Ext.data.HttpProxy HttpProxy} if an <tt>url</tt> is specified. Typically this option, or the <code>{@link #data}</code> option will be specified.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='autoLoad'>
          <xs:annotation>
            <xs:documentation>
If <tt>{@link #data}</tt> is not specified, and if <tt>autoLoad</tt> is <tt>true</tt> or an <tt>Object</tt>, this store's {@link #load} method is automatically called after creation. If the value of <tt>autoLoad</tt> is an <tt>Object</tt>, this <tt>Object</tt> will be passed to the store's {@link #load} method.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='proxy'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.data.DataProxy DataProxy} object which provides access to a data object. See <code>{@link #url}</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='data'>
          <xs:annotation>
            <xs:documentation>
An inline data object readable by the <code>{@link #reader}</code>. Typically this option, or the <code>{@link #url}</code> option will be specified.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='reader'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.data.DataReader Reader} object which processes the data object and returns an Array of {@link Ext.data.Record} objects which are cached keyed by their <b><tt>{@link Ext.data.Record#id id}</tt></b> property.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='writer'>
          <xs:annotation>
            <xs:documentation>
<p>The {@link Ext.data.DataWriter Writer} object which processes a record object for being written to the server-side database.</p><br/><p>When a writer is installed into a Store the {@link #add}, {@link #remove}, and {@link #update} events on the store are monitored in order to remotely {@link #createRecords create records}, {@link #destroyRecord destroy records}, or {@link #updateRecord update records}.</p><br/><p>The proxy for this store will relay any {@link #writexception} events to this store.</p><br/><p>Sample implementation:</p><pre><code>var writer = new {@link Ext.data.JsonWriter}({
encode: true,
writeAllFields: true // write all fields, not just those that changed
});

// Typical Store collecting the Proxy, Reader and Writer together.
var store = new Ext.data.Store({
storeId: 'user',
root: 'records',
proxy: proxy,
reader: reader,
writer: writer,     // &lt;-- plug a DataWriter into the store just as you would a Reader
paramsAsHash: true,
autoSave: false    // &lt;-- false to delay executing create, update, destroy requests
//     until specifically told to do so.
});
</code></pre><br/><br/>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='baseParams'>
          <xs:annotation>
            <xs:documentation>
<p>An object containing properties which are to be sent as parameters for <i>every</i> HTTP request.</p><p>Parameters are encoded as standard HTTP parameters using {@link Ext#urlEncode}.</p><p><b>Note</b>: <code>baseParams</code> may be superseded by any <code>params</code> specified in a <code>{@link #load}</code> request, see <code>{@link #load}</code> for more details.</p>This property may be modified after creation using the <code>{@link #setBaseParam}</code> method. @property
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='sortInfo'>
          <xs:annotation>
            <xs:documentation>
A config object to specify the sort order in the request of a Store's {@link #load} operation. Note that for local sorting, the <tt>direction</tt> property is case-sensitive. See also {@link #remoteSort} and {@link #paramNames}. For example:<pre><code>sortInfo: {
field: 'fieldName',
direction: 'ASC' // or 'DESC' (case sensitive for local sorting)
}
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='remoteSort'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> if sorting is to be handled by requesting the <tt>{@link #proxy Proxy}</tt> to provide a refreshed version of the data object in sorted order, as opposed to sorting the Record cache in place (defaults to <tt>false</tt>). <p>If <tt>remoteSort</tt> is <tt>true</tt>, then clicking on a {@link Ext.grid.Column Grid Column}'s {@link Ext.grid.Column#header header} causes the current page to be requested from the server appending the following two parameters to the <b><tt>{@link #load params}</tt></b>:</p><div class="mdetail-params"><ul><li><b><tt>sort</tt></b> : String<p class="sub-desc">The <tt>name</tt> (as specified in the Record's {@link Ext.data.Field Field definition}) of the field to sort on.</p></li><li><b><tt>dir</tt></b> : String<p class="sub-desc">The direction of the sort, 'ASC' or 'DESC' (case-sensitive).</p></li></ul></div><br/><br/>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoDestroy'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to destroy the store when the component the store is bound to is destroyed (defaults to <tt>false</tt>). <p><b>Note</b>: this should be set to true when using stores that are bound to only 1 component.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='pruneModifiedRecords'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to clear all modified record information each time the store is loaded or when a record is removed (defaults to <tt>false</tt>). See {@link #getModifiedRecords} for the accessor method to retrieve the modified records.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoSave'>
          <xs:annotation>
            <xs:documentation>
<p>Defaults to <tt>true</tt> causing the store to automatically {@link #save} records to the server when a record is modified (ie: becomes 'dirty'). Specify <tt>false</tt> to manually call {@link #save} to send all modifiedRecords to the server.</p><br/><p><b>Note</b>: each CRUD action will be sent as a separate request.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='batch'>
          <xs:annotation>
            <xs:documentation>
<p>Defaults to <tt>true</tt> (unless <code>{@link #restful}:true</code>). Multiple requests for each CRUD action (CREATE, READ, UPDATE and DESTROY) will be combined and sent as one transaction. Only applies when <code>{@link #autoSave}</code> is set to <tt>false</tt>.</p><br/><p>If Store is RESTful, the DataProxy is also RESTful, and a unique transaction is generated for each record.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='restful'>
          <xs:annotation>
            <xs:documentation>
Defaults to <tt>false</tt>. Set to <tt>true</tt> to have the Store and the set Proxy operate in a RESTful manner. The store will automatically generate GET, POST, PUT and DELETE requests to the server. The HTTP method used for any given CRUD action is described in {@link Ext.data.Api#restActions}. For additional information see {@link Ext.data.DataProxy#restful}. <p><b>Note</b>: if <code>{@link #restful}:true</code> <code>batch</code> will internally be set to <tt>false</tt>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='paramNames'>
          <xs:annotation>
            <xs:documentation>
<p>An object containing properties which specify the names of the paging and sorting parameters passed to remote servers when loading blocks of data. By default, this object takes the following form:</p><pre><code>{
start : 'start',  // The parameter name which specifies the start row
limit : 'limit',  // The parameter name which specifies number of rows to return
sort : 'sort',    // The parameter name which specifies the column to sort on
dir : 'dir'       // The parameter name which specifies the sort direction
}
</code></pre><p>The server must produce the requested data block upon receipt of these parameter names. If different parameter names are required, this property can be overriden using a configuration property.</p><p>A {@link Ext.PagingToolbar PagingToolbar} bound to this Store uses this property to determine the parameter names to use in its {@link #load requests}.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultParamNames'>
          <xs:annotation>
            <xs:documentation>
Provides the default values for the {@link #paramNames} property. To globally modify the parameters for all stores, this object should be changed on the store prototype.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defined'>
          <xs:annotation>
            <xs:documentation>
. Should be easy now. Saves all pending changes to the store. If the commensurate Ext.data.Api.actions action is not configured, then the configured <code>{@link #url}</code> will be used. <pre>change            url
---------------   --------------------
removed records   Ext.data.Api.actions.destroy
phantom records   Ext.data.Api.actions.create
{@link #getModifiedRecords modified records}  Ext.data.Api.actions.update
</pre>@TODO: Create extensions of Error class and send associated Record with thrown exceptions. e.g.: Ext.data.DataReader.Error or Ext.data.Error or Ext.data.DataProxy.Error, etc.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='store' name='store' type='ext:ext.data.Store' substitutionGroup='ext:observable'>
    <xs:annotation>
      <xs:documentation>
<p>The Store class encapsulates a client side cache of {@link Ext.data.Record Record} objects which provide input data for Components such as the {@link Ext.grid.GridPanel GridPanel}, the {@link Ext.form.ComboBox ComboBox}, or the {@link Ext.DataView DataView}.</p><p><u>Retrieving Data</u></p><p>A Store object may access a data object using:</p><div class="mdetail-params"><ul><li>{@link #proxy configured implementation} of {@link Ext.data.DataProxy DataProxy}</li><li>{@link #data} to automatically pass in data</li><li>{@link #loadData} to manually pass in data</li></ul></div><br/><br/> <p><u>Reading Data</u></p><p>A Store object has no inherent knowledge of the format of the data object (it could be an Array, XML, or JSON). A Store object uses an appropriate {@link #reader configured implementation} of a {@link Ext.data.DataReader DataReader} to create {@link Ext.data.Record Record} instances from the data object.</p><p><u>Store Types</u></p><p>There are several implementations of Store available which are customized for use with a specific DataReader implementation. Here is an example using an ArrayStore which implicitly creates a reader commensurate to an Array data object.</p><pre><code>var myStore = new Ext.data.ArrayStore({
fields: ['fullname', 'first'],
idIndex: 0 // id for each record will be the first element
});
</code></pre><p>For custom implementations create a basic {@link Ext.data.Store} configured as needed:</p><pre><code>// create a {@link Ext.data.Record Record} constructor:
var rt = Ext.data.Record.create([
{name: 'fullname'},
{name: 'first'}
]);
var myStore = new Ext.data.Store({
// explicitly create reader
reader: new Ext.data.ArrayReader(
{
idIndex: 0  // id for each record will be the first element
},
rt // recordType
)
});
</code></pre><p>Load some data into store (note the data object is an array which corresponds to the reader):</p><pre><code>var myData = [
[1, 'Fred Flintstone', 'Fred'],  // note that id for the record is the first element
[2, 'Barney Rubble', 'Barney']
];
myStore.loadData(myData);
</code></pre><p>Records are cached and made available through accessor functions. An example of adding a record to the store:</p><pre><code>var defaultData = {
fullname: 'Full Name',
first: 'First Name'
};
var recId = 100; // provide unique id for the record
var r = new myStore.recordType(defaultData, ++recId); // create new record
myStore.{@link #insert}(0, r); // insert a new record into the store (also see {@link #add})
</code></pre><p><u>Writing Data</u></p><p>And <b>new in Ext version 3</b>, use the new {@link Ext.data.DataWriter DataWriter} to create an automated, <a href="http://extjs.com/deploy/dev/examples/writer/writer.html">Writable Store</a> along with <a href="http://extjs.com/deploy/dev/examples/restful/restful.html">RESTful features.</a></p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.TabPanel'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:sequence>
            <xs:element name='itemTpl' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>(Optional) A {@link Ext.Template Template} or {@link Ext.XTemplate XTemplate} which may be provided to process the data object returned from <tt>{@link #getTemplateArgs}</tt> to produce a clickable selector element in the tab strip.</p><p>The main element created should be a <tt>&lt;li&gt;</tt> element. In order for a click event on a selector element to be connected to its item, it must take its <i>id</i> from the TabPanel's native <tt>{@link #getTemplateArgs}</tt>.</p><p>The child element which contains the title text must be marked by the CSS class <tt>x-tab-strip-inner</tt>.</p><p>To enable closability, the created element should contain an element marked by the CSS class <tt>x-tab-strip-close</tt>.</p><p>If a custom <tt>itemTpl</tt> is supplied, it is the developer's responsibility to create CSS style rules to create the desired appearance.</p>Below is an example of how to create customized tab selector items:<pre><code>new Ext.TabPanel({
renderTo: document.body,
minTabWidth: 115,
tabWidth: 135,
enableTabScroll: true,
width: 600,
height: 250,
defaults: {autoScroll:true},
itemTpl: new Ext.XTemplate(
'&lt;li class="{cls}" id="{id}" style="overflow:hidden"&gt;',
'&lt;tpl if="closable"&gt;',
'&lt;a class="x-tab-strip-close" onclick="return false;"&gt;&lt;/a&gt;',
'&lt;/tpl&gt;',
'&lt;a class="x-tab-right" href="#" onclick="return false;" style="padding-left:6px"&gt;',
'&lt;em class="x-tab-left"&gt;',
'&lt;span class="x-tab-strip-inner"&gt;',
'&lt;img src="{src}" style="float:left;margin:3px 3px 0 0"&gt;',
'&lt;span style="margin-left:20px" class="x-tab-strip-text {iconCls}"&gt;{text} {extra}&lt;/span&gt;',
'&lt;/span&gt;',
'&lt;/em&gt;',
'&lt;/a&gt;',
'&lt;/li&gt;'
),
getTemplateArgs: function(item) {
//      Call the native method to collect the base data. Like the ID!
var result = Ext.TabPanel.prototype.getTemplateArgs.call(this, item);

//      Add stuff used in our template
return Ext.apply(result, {
closable: item.closable,
src: item.iconSrc,
extra: item.extraText || ''
});
},
items: [{
title: 'New Tab 1',
iconSrc: '../shared/icons/fam/grid.png',
html: 'Tab Body 1',
closable: true
}, {
title: 'New Tab 2',
iconSrc: '../shared/icons/fam/grid.png',
html: 'Tab Body 2',
extraText: 'Extra stuff in the tab button'
}]
});
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='layoutOnTabChange'>
          <xs:annotation>
            <xs:documentation>
Set to true to force a layout of the active tab when the tab is changed. Defaults to false. See {@link Ext.layout.CardLayout}.<code>{@link Ext.layout.CardLayout#layoutOnCardChange layoutOnCardChange}</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tabCls'>
          <xs:annotation>
            <xs:documentation>
<b>This config option is used on <u>child Components</u> of ths TabPanel.</b> A CSS class name applied to the tab strip item representing the child Component, allowing special styling to be applied.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='deferredRender'>
          <xs:annotation>
            <xs:documentation>
<p><tt>true</tt> by default to defer the rendering of child <tt>{@link Ext.Container#items items}</tt> to the browsers DOM until a tab is activated. <tt>false</tt> will render all contained <tt>{@link Ext.Container#items items}</tt> as soon as the {@link Ext.layout.CardLayout layout} is rendered. If there is a significant amount of content or a lot of heavy controls being rendered into panels that are not displayed by default, setting this to <tt>true</tt> might improve performance.</p><br/><p>The <tt>deferredRender</tt> property is internally passed to the layout manager for TabPanels ({@link Ext.layout.CardLayout}) as its {@link Ext.layout.CardLayout#deferredRender} configuration value.</p><br/><p><b>Note</b>: leaving <tt>deferredRender</tt> as <tt>true</tt> means that the content within an unactivated tab will not be available. For example, this means that if the TabPanel is within a {@link Ext.form.FormPanel form}, then until a tab is activated, any Fields within unactivated tabs will not be rendered, and will therefore not be submitted and will not be available to either {@link Ext.form.BasicForm#getValues getValues} or {@link Ext.form.BasicForm#setValues setValues}.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='tabWidth'>
          <xs:annotation>
            <xs:documentation>
The initial width in pixels of each new tab (defaults to 120).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minTabWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width in pixels for each tab when {@link #resizeTabs} = true (defaults to 30).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='resizeTabs'>
          <xs:annotation>
            <xs:documentation>
True to automatically resize each tab so that the tabs will completely fill the tab strip (defaults to false). Setting this to true may cause specific widths that might be set per tab to be overridden in order to fit them all into view (although {@link #minTabWidth} will always be honored).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableTabScroll'>
          <xs:annotation>
            <xs:documentation>
True to enable scrolling to tabs that may be invisible due to overflowing the overall TabPanel width. Only available with tabPosition:'top' (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='scrollIncrement'>
          <xs:annotation>
            <xs:documentation>
The number of pixels to scroll each time a tab scroll button is pressed (defaults to <tt>100</tt>, or if <tt>{@link #resizeTabs} = true</tt>, the calculated tab width). Only applies when <tt>{@link #enableTabScroll} = true</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='scrollRepeatInterval'>
          <xs:annotation>
            <xs:documentation>
Number of milliseconds between each scroll while a tab scroll button is continuously pressed (defaults to <tt>400</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:float' name='scrollDuration'>
          <xs:annotation>
            <xs:documentation>
The number of milliseconds that each scroll animation should last (defaults to <tt>.35</tt>). Only applies when <tt>{@link #animScroll} = true</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='animScroll'>
          <xs:annotation>
            <xs:documentation>
True to animate tab scrolling so that hidden tabs slide smoothly into view (defaults to <tt>true</tt>). Only applies when <tt>{@link #enableTabScroll} = true</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tabPosition'>
          <xs:annotation>
            <xs:documentation>
The position where the tab strip should be rendered (defaults to <tt>'top'</tt>). The only other supported value is <tt>'bottom'</tt>. <b>Note</b>: tab scrolling is only supported for <tt>tabPosition: 'top'</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoTabs'>
          <xs:annotation>
            <xs:documentation>
<p><tt>true</tt> to query the DOM for any divs with a class of 'x-tab' to be automatically converted to tabs and added to this panel (defaults to <tt>false</tt>). Note that the query will be executed within the scope of the container element only (so that multiple tab panels from markup can be supported via this method).</p><p>This method is only possible when the markup is structured correctly as a container with nested divs containing the class <tt>'x-tab'</tt>. To create TabPanels without these limitations, or to pull tab content from other elements on the page, see the example at the top of the class for generating tabs from markup.</p><p>There are a couple of things to note when using this method:</p><ul><li>When using the <tt>autoTabs</tt> config (as opposed to passing individual tab configs in the TabPanel's {@link #items} collection), you must use <tt>{@link #applyTo}</tt> to correctly use the specified <tt>id</tt> as the tab container. The <tt>autoTabs</tt> method <em>replaces</em> existing content with the TabPanel components.</li><li>Make sure that you set <tt>{@link #deferredRender}: false</tt> so that the content elements for each tab will be rendered into the TabPanel immediately upon page load, otherwise they will not be transformed until each tab is activated and will be visible outside the TabPanel.</li></ul>Example usage:<br/><br/> <pre><code>var tabs = new Ext.TabPanel({
applyTo: 'my-tabs',
activeTab: 0,
deferredRender: false,
autoTabs: true
});

// This markup will be converted to a TabPanel from the code above
&lt;div id="my-tabs"&gt;
&lt;div class="x-tab" title="Tab 1"&gt;A simple tab&lt;/div&gt;
&lt;div class="x-tab" title="Tab 2"&gt;Another one&lt;/div&gt;
&lt;/div&gt;
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='autoTabSelector'>
          <xs:annotation>
            <xs:documentation>
The CSS selector used to search for tabs in existing markup when <tt>{@link #autoTabs} = true</tt> (defaults to <tt>'div.x-tab'</tt>). This can be any valid selector supported by {@link Ext.DomQuery#select}. Note that the query will be executed within the scope of this tab panel only (so that multiple tab panels from markup can be supported on a page).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='activeTab'>
          <xs:annotation>
            <xs:documentation>
A string id or the numeric index of the tab that should be initially activated on render (defaults to none).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='tabMargin'>
          <xs:annotation>
            <xs:documentation>
The number of pixels of space to calculate into the sizing and scrolling of tabs. If you change the margin in CSS, you will need to update this value so calculations are correct with either <tt>{@link #resizeTabs}</tt> or scrolling tabs. (defaults to <tt>2</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='plain'>
          <xs:annotation>
            <xs:documentation>
true to render the tab strip without a background container image (defaults to <tt>false</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='wheelIncrement'>
          <xs:annotation>
            <xs:documentation>
For scrolling tabs, the number of pixels to increment on mouse wheel scrolling (defaults to <tt>20</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='itemTpl'>
          <xs:annotation>
            <xs:documentation>
<p>(Optional) A {@link Ext.Template Template} or {@link Ext.XTemplate XTemplate} which may be provided to process the data object returned from <tt>{@link #getTemplateArgs}</tt> to produce a clickable selector element in the tab strip.</p><p>The main element created should be a <tt>&lt;li&gt;</tt> element. In order for a click event on a selector element to be connected to its item, it must take its <i>id</i> from the TabPanel's native <tt>{@link #getTemplateArgs}</tt>.</p><p>The child element which contains the title text must be marked by the CSS class <tt>x-tab-strip-inner</tt>.</p><p>To enable closability, the created element should contain an element marked by the CSS class <tt>x-tab-strip-close</tt>.</p><p>If a custom <tt>itemTpl</tt> is supplied, it is the developer's responsibility to create CSS style rules to create the desired appearance.</p>Below is an example of how to create customized tab selector items:<pre><code>new Ext.TabPanel({
renderTo: document.body,
minTabWidth: 115,
tabWidth: 135,
enableTabScroll: true,
width: 600,
height: 250,
defaults: {autoScroll:true},
itemTpl: new Ext.XTemplate(
'&lt;li class="{cls}" id="{id}" style="overflow:hidden"&gt;',
'&lt;tpl if="closable"&gt;',
'&lt;a class="x-tab-strip-close" onclick="return false;"&gt;&lt;/a&gt;',
'&lt;/tpl&gt;',
'&lt;a class="x-tab-right" href="#" onclick="return false;" style="padding-left:6px"&gt;',
'&lt;em class="x-tab-left"&gt;',
'&lt;span class="x-tab-strip-inner"&gt;',
'&lt;img src="{src}" style="float:left;margin:3px 3px 0 0"&gt;',
'&lt;span style="margin-left:20px" class="x-tab-strip-text {iconCls}"&gt;{text} {extra}&lt;/span&gt;',
'&lt;/span&gt;',
'&lt;/em&gt;',
'&lt;/a&gt;',
'&lt;/li&gt;'
),
getTemplateArgs: function(item) {
//      Call the native method to collect the base data. Like the ID!
var result = Ext.TabPanel.prototype.getTemplateArgs.call(this, item);

//      Add stuff used in our template
return Ext.apply(result, {
closable: item.closable,
src: item.iconSrc,
extra: item.extraText || ''
});
},
items: [{
title: 'New Tab 1',
iconSrc: '../shared/icons/fam/grid.png',
html: 'Tab Body 1',
closable: true
}, {
title: 'New Tab 2',
iconSrc: '../shared/icons/fam/grid.png',
html: 'Tab Body 2',
extraText: 'Extra stuff in the tab button'
}]
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='tabpanel' name='tabpanel' type='ext:ext.TabPanel' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>
<p>A basic tab container. TabPanels can be used exactly like a standard {@link Ext.Panel} for layout purposes, but also have special support for containing child Components (<tt>{@link Ext.Container#items items}</tt>) that are managed using a {@link Ext.layout.CardLayout CardLayout layout manager}, and displayed as separate tabs.</p><b>Note:</b> By default, a tab's close tool <i>destroys</i> the child tab Component and all its descendants. This makes the child tab Component, and all its descendants <b>unusable</b>. To enable re-use of a tab, configure the TabPanel with <b><code>{@link #autoDestroy autoDestroy: false}</code></b>. <p style="font-weight: bold"><u>TabPanel header/footer elements</u></p><p>TabPanels use their {@link Ext.Panel#header header} or {@link Ext.Panel#footer footer} element (depending on the {@link #tabPosition} configuration) to accommodate the tab selector buttons. This means that a TabPanel will not display any configured title, and will not display any configured header {@link Ext.Panel#tools tools}.</p><p>To display a header, embed the TabPanel in a {@link Ext.Panel Panel} which uses <b><tt>{@link Ext.Container#layout layout:'fit'}</tt></b>.</p><p style="font-weight: bold"><u>Tab Events</u></p><p>There is no actual tab class â each tab is simply a {@link Ext.BoxComponent Component} such as a {@link Ext.Panel Panel}. However, when rendered in a TabPanel, each child Component can fire additional events that only exist for tabs and are not available from other Components. These events are:</p><div><ul class="mdetail-params"><li><tt><b>{@link Ext.Panel#activate activate}</b></tt> : Fires when this Component becomes the active tab.</li><li><tt><b>{@link Ext.Panel#deactivate deactivate}</b></tt> : Fires when the Component that was the active tab becomes deactivated.</li></ul></div><p style="font-weight: bold"><u>Creating TabPanels from Code</u></p><p>TabPanels can be created and rendered completely in code, as in this example:</p><pre><code>var tabs = new Ext.TabPanel({
renderTo: Ext.getBody(),
activeTab: 0,
items: [{
title: 'Tab 1',
html: 'A simple tab'
},{
title: 'Tab 2',
html: 'Another one'
}]
});
</code></pre><p style="font-weight: bold"><u>Creating TabPanels from Existing Markup</u></p><p>TabPanels can also be rendered from pre-existing markup in a couple of ways.</p><div><ul class="mdetail-params"><li>Pre-Structured Markup</li><li style="list-style: none"><div class="sub-desc"><p>A container div with one or more nested tab divs with class <tt>'x-tab'</tt> can be rendered entirely from existing markup (See the {@link #autoTabs} example).</p></div></li><li>Un-Structured Markup</li><li style="list-style: none"><div class="sub-desc"><p>A TabPanel can also be rendered from markup that is not strictly structured by simply specifying by id which elements should be the container and the tabs. Using this method tab content can be pulled from different elements within the page by id regardless of page structure. For example:</p><pre><code>var tabs = new Ext.TabPanel({
renderTo: 'my-tabs',
activeTab: 0,
items:[
{contentEl:'tab1', title:'Tab 1'},
{contentEl:'tab2', title:'Tab 2'}
]
});

// Note that the tabs do not have to be nested within the container (although they can be)
&lt;div id="my-tabs"&gt;&lt;/div&gt;
&lt;div id="tab1" class="x-hide-display"&gt;A simple tab&lt;/div&gt;
&lt;div id="tab2" class="x-hide-display"&gt;Another one&lt;/div&gt;
</code></pre>Note that the tab divs in this example contain the class <tt>'x-hide-display'</tt> so that they can be rendered deferred without displaying outside the tabs. You could alternately set <tt>{@link #deferredRender} = false</tt> to render all content tabs on page load.</div></li></ul></div>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.toolbar.Fill'>
    <xs:complexContent>
      <xs:extension base='ext:ext.toolbar.Spacer'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='tbfill' name='tbfill' type='ext:ext.toolbar.Fill' substitutionGroup='ext:tbspacer'>
    <xs:annotation>
      <xs:documentation>
A non-rendering placeholder item which instructs the Toolbar's Layout to begin using the right-justified button container. <pre><code>new Ext.Panel({
tbar : [
'Item 1',
{xtype: 'tbfill'}, // or '-&gt;'
'Item 2'
]
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.toolbar.Item'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:string' name='overflowText'>
          <xs:annotation>
            <xs:documentation>
Text to be used for the menu if the item is overflowed.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='tbitem' name='tbitem' type='ext:ext.toolbar.Item' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
The base class that other non-interacting Toolbar Item classes should extend in order to get some basic common toolbar item functionality.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.toolbar.Separator'>
    <xs:complexContent>
      <xs:extension base='ext:ext.toolbar.Item'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='tbseparator' name='tbseparator' type='ext:ext.toolbar.Separator' substitutionGroup='ext:tbitem'>
    <xs:annotation>
      <xs:documentation>
A simple class that adds a vertical separator bar between toolbar items (css class:<tt>'xtb-sep'</tt>). Example usage: <pre><code>new Ext.Panel({
tbar : [
'Item 1',
{xtype: 'tbseparator'}, // or '-'
'Item 2'
]
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.toolbar.Spacer'>
    <xs:complexContent>
      <xs:extension base='ext:ext.toolbar.Item'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='tbspacer' name='tbspacer' type='ext:ext.toolbar.Spacer' substitutionGroup='ext:tbitem'>
    <xs:annotation>
      <xs:documentation>
A simple element that adds extra horizontal space between items in a toolbar. By default a 2px wide space is added via css specification:<pre><code>.x-toolbar .xtb-spacer {
width:2px;
}
</code></pre><p>Example usage:</p><pre><code>new Ext.Panel({
tbar : [
'Item 1',
{xtype: 'tbspacer'}, // or ' '
'Item 2',
// space width is also configurable via javascript
{xtype: 'tbspacer', width: 50}, // add a 50px space
'Item 3'
]
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.toolbar.TextItem'>
    <xs:complexContent>
      <xs:extension base='ext:ext.toolbar.Item'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:string' name='text'>
          <xs:annotation>
            <xs:documentation>
The text to be used as innerHTML (html tags are accepted)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='tbtext' name='tbtext' type='ext:ext.toolbar.TextItem' substitutionGroup='ext:tbitem'>
    <xs:annotation>
      <xs:documentation>
A simple class that renders text directly into a toolbar (with css class:<tt>'xtb-text'</tt>). Example usage: <pre><code>new Ext.Panel({
tbar : [
{xtype: 'tbtext', text: 'Item 1'} // or simply 'Item 1'
]
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.grid.TemplateColumn'>
    <xs:complexContent>
      <xs:extension base='ext:ext.grid.Column'>
        <xs:sequence>
            <xs:element name='tpl' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An {@link Ext.XTemplate XTemplate}, or an XTemplate <i>definition string</i> to use to process a {@link Ext.data.Record Record}'s {@link Ext.data.Record#data data} to produce a column's rendered value.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='tpl'>
          <xs:annotation>
            <xs:documentation>
An {@link Ext.XTemplate XTemplate}, or an XTemplate <i>definition string</i> to use to process a {@link Ext.data.Record Record}'s {@link Ext.data.Record#data data} to produce a column's rendered value.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='templatecolumn' name='templatecolumn' type='ext:ext.grid.TemplateColumn' substitutionGroup='ext:gridcolumn'>
    <xs:annotation>
      <xs:documentation>
<p>A Column definition class which renders a value by processing a {@link Ext.data.Record Record}'s {@link Ext.data.Record#data data} using a {@link #tpl configured} {@link Ext.XTemplate XTemplate}. See the {@link Ext.grid.Column#xtype xtype} config option of {@link Ext.grid.Column} for more details.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.TextArea'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.TextField'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='preventScrollbars'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to prevent scrollbars from appearing regardless of how much text is in the field. This option is only relevant when {@link #grow} is <tt>true</tt>. Equivalent to setting overflow: hidden, defaults to <tt>false</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='textarea' name='textarea' type='ext:ext.form.TextArea' substitutionGroup='ext:textfield'>
    <xs:annotation>
      <xs:documentation>
Multiline text field. Can be used as a direct replacement for traditional textarea fields, plus adds support for auto-sizing.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.TextField'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Field'>
        <xs:sequence>
            <xs:element name='stripCharsRe' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A JavaScript RegExp object used to strip unwanted content from the value before validation (defaults to <tt>null</tt>).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='maskRe' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An input mask regular expression that will be used to filter keystrokes that do not match (defaults to <tt>null</tt>)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='validator' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A custom validation function to be called during field validation ({@link #validateValue}) (defaults to <tt>null</tt>). If specified, this function will be called first, allowing the developer to override the default validation process.</p><br/><p>This function will be passed the following Parameters:</p><div class="mdetail-params"><ul><li><code>value</code>: <i>Mixed</i> <div class="sub-desc">The current field value</div></li></ul></div><br/><p>This function is to Return:</p><div class="mdetail-params"><ul><li><code>true</code>: <i>Boolean</i> <div class="sub-desc"><code>true</code> if the value is valid</div></li><li><code>msg</code>: <i>String</i> <div class="sub-desc">An error message if the value is invalid</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='regex' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A JavaScript RegExp object to be tested against the field value during validation (defaults to <tt>null</tt>). If the test fails, the field will be marked invalid using <b><tt>{@link #regexText}</tt></b>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='vtypeText'>
          <xs:annotation>
            <xs:documentation>
A custom error message to display in place of the default message provided for the <b><code>{@link #vtype}</code></b> currently set for this field (defaults to <tt>''</tt>). <b>Note</b>: only applies if <b><code>{@link #vtype}</code></b> is set, else ignored.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='stripCharsRe'>
          <xs:annotation>
            <xs:documentation>
A JavaScript RegExp object used to strip unwanted content from the value before validation (defaults to <tt>null</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='grow'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> if this field should automatically grow and shrink to its content (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='growMin'>
          <xs:annotation>
            <xs:documentation>
The minimum width to allow when <code><b>{@link #grow}</b> = true</code> (defaults to <tt>30</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='growMax'>
          <xs:annotation>
            <xs:documentation>
The maximum width to allow when <code><b>{@link #grow}</b> = true</code> (defaults to <tt>800</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='vtype'>
          <xs:annotation>
            <xs:documentation>
A validation type name as defined in {@link Ext.form.VTypes} (defaults to <tt>null</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maskRe'>
          <xs:annotation>
            <xs:documentation>
An input mask regular expression that will be used to filter keystrokes that do not match (defaults to <tt>null</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='disableKeyFilter'>
          <xs:annotation>
            <xs:documentation>
Specify <tt>true</tt> to disable input keystroke filtering (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowBlank'>
          <xs:annotation>
            <xs:documentation>
Specify <tt>false</tt> to validate that the value's length is &gt; 0 (defaults to <tt>true</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minLength'>
          <xs:annotation>
            <xs:documentation>
Minimum input field length required (defaults to <tt>0</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxLength'>
          <xs:annotation>
            <xs:documentation>
Maximum input field length allowed by validation (defaults to Number.MAX_VALUE). This behavior is intended to provide instant feedback to the user by improving usability to allow pasting and editing or overtyping and back tracking. To restrict the maximum number of characters that can be entered into the field use <tt><b>{@link Ext.form.Field#autoCreate autoCreate}</b></tt> to add any attributes you want to a field, for example:<pre><code>var myField = new Ext.form.NumberField({
id: 'mobile',
anchor:'90%',
fieldLabel: 'Mobile',
maxLength: 16, // for validation
autoCreate: {tag: 'input', type: 'text', size: '20', autocomplete: 'off', maxlength: '10'}
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='minLengthText'>
          <xs:annotation>
            <xs:documentation>
Error text to display if the <b><tt>{@link #minLength minimum length}</tt></b> validation fails (defaults to <tt>'The minimum length for this field is {minLength}'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxLengthText'>
          <xs:annotation>
            <xs:documentation>
Error text to display if the <b><tt>{@link #maxLength maximum length}</tt></b> validation fails (defaults to <tt>'The maximum length for this field is {maxLength}'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='selectOnFocus'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to automatically select any existing field text when the field receives input focus (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='blankText'>
          <xs:annotation>
            <xs:documentation>
The error text to display if the <b><tt>{@link #allowBlank}</tt></b> validation fails (defaults to <tt>'This field is required'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='validator'>
          <xs:annotation>
            <xs:documentation>
<p>A custom validation function to be called during field validation ({@link #validateValue}) (defaults to <tt>null</tt>). If specified, this function will be called first, allowing the developer to override the default validation process.</p><br/><p>This function will be passed the following Parameters:</p><div class="mdetail-params"><ul><li><code>value</code>: <i>Mixed</i> <div class="sub-desc">The current field value</div></li></ul></div><br/><p>This function is to Return:</p><div class="mdetail-params"><ul><li><code>true</code>: <i>Boolean</i> <div class="sub-desc"><code>true</code> if the value is valid</div></li><li><code>msg</code>: <i>String</i> <div class="sub-desc">An error message if the value is invalid</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='regex'>
          <xs:annotation>
            <xs:documentation>
A JavaScript RegExp object to be tested against the field value during validation (defaults to <tt>null</tt>). If the test fails, the field will be marked invalid using <b><tt>{@link #regexText}</tt></b>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='regexText'>
          <xs:annotation>
            <xs:documentation>
The error text to display if <b><tt>{@link #regex}</tt></b> is used and the test fails during validation (defaults to <tt>''</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='emptyText'>
          <xs:annotation>
            <xs:documentation>
The default text to place into an empty field (defaults to <tt>null</tt>). <b>Note</b>: that this value will be submitted to the server if this field is enabled and configured with a {@link #name}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='emptyClass'>
          <xs:annotation>
            <xs:documentation>
The CSS class to apply to an empty field to style the <b><tt>{@link #emptyText}</tt></b> (defaults to <tt>'x-form-empty-field'</tt>). This class is automatically added and removed as needed depending on the current field value.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableKeyEvents'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to enable the proxying of key events for the HTML input field (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='textfield' name='textfield' type='ext:ext.form.TextField' substitutionGroup='ext:field'>
    <xs:annotation>
      <xs:documentation>
<p>Basic text field. Can be used as a direct replacement for traditional text inputs, or as the base class for more sophisticated input controls (like {@link Ext.form.TextArea} and {@link Ext.form.ComboBox}).</p><p style="font-weight: bold"><u>Validation</u></p><p>The validation procedure is described in the documentation for {@link #validateValue}.</p><p style="font-weight: bold"><u>Alter Validation Behavior</u></p><p>Validation behavior for each field can be configured:</p><div class="mdetail-params"><ul><li><code>{@link Ext.form.TextField#invalidText invalidText}</code> : the default validation message to show if any validation step above does not provide a message when invalid</li><li><code>{@link Ext.form.TextField#maskRe maskRe}</code> : filter out keystrokes before any validation occurs</li><li><code>{@link Ext.form.TextField#stripCharsRe stripCharsRe}</code> : filter characters after being typed in, but before being validated</li><li><code>{@link Ext.form.Field#invalidClass invalidClass}</code> : alternate style when invalid</li><li><code>{@link Ext.form.Field#validateOnBlur validateOnBlur}</code>, <code>{@link Ext.form.Field#validationDelay validationDelay}</code>, and <code>{@link Ext.form.Field#validationEvent validationEvent}</code> : modify how/when validation is triggered</li></ul></div>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.TimeField'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.ComboBox'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:string' name='minValue'>
          <xs:annotation>
            <xs:documentation>
The minimum allowed time. Can be either a Javascript date object with a valid time value or a string time in a valid format -- see {@link #format} and {@link #altFormats} (defaults to null).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxValue'>
          <xs:annotation>
            <xs:documentation>
The maximum allowed time. Can be either a Javascript date object with a valid time value or a string time in a valid format -- see {@link #format} and {@link #altFormats} (defaults to null).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='minText'>
          <xs:annotation>
            <xs:documentation>
The error text to display when the date in the cell is before minValue (defaults to 'The time in this field must be equal to or after {0}').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxText'>
          <xs:annotation>
            <xs:documentation>
The error text to display when the time is after maxValue (defaults to 'The time in this field must be equal to or before {0}').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='format'>
          <xs:annotation>
            <xs:documentation>
The default time format string which can be overriden for localization support. The format must be valid according to {@link Date#parseDate} (defaults to 'g:i A', e.g., '3:15 PM'). For 24-hour time format try 'H:i' instead.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='altFormats'>
          <xs:annotation>
            <xs:documentation>
Multiple date formats separated by "|" to try when parsing a user input value and it doesn't match the defined format (defaults to 'g:ia|g:iA|g:i a|g:i A|h:i|g:i|H:i|ga|ha|gA|h a|g a|g A|gi|hi|gia|hia|g|H').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='increment'>
          <xs:annotation>
            <xs:documentation>
The number of minutes between each time value in the list (defaults to 15).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='timefield' name='timefield' type='ext:ext.form.TimeField' substitutionGroup='ext:combo'>
    <xs:annotation>
      <xs:documentation>
Provides a time input field with a time dropdown and automatic time validation. Example usage: <pre><code>new Ext.form.TimeField({
minValue: '9:00 AM',
maxValue: '6:00 PM',
increment: 30
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Tip'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:int' name='minWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width of the tip in pixels (defaults to 40).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxWidth'>
          <xs:annotation>
            <xs:documentation>
The maximum width of the tip in pixels (defaults to 300). The maximum supported value is 500.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultAlign'>
          <xs:annotation>
            <xs:documentation>
<b>Experimental</b>. The default {@link Ext.Element#alignTo} anchor position value for this tip relative to its element of origin (defaults to "tl-bl?").
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='tip' name='tip' type='ext:ext.Tip' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>
This is the base class for {@link Ext.QuickTip} and {@link Ext.Tooltip} that provides the basic layout and positioning that all tip-based classes require. This class can be used directly for simple, statically-positioned tips that are displayed programmatically, or it can be extended to provide custom tip implementations.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Toolbar'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Container'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='toolbar' name='toolbar' type='ext:ext.Toolbar' substitutionGroup='ext:container'>
    <xs:annotation>
      <xs:documentation>
<p>Basic Toolbar class. Although the <tt>{@link Ext.Container#defaultType defaultType}</tt> for Toolbar is <tt>{@link Ext.Button button}</tt>, Toolbar elements (child items for the Toolbar container) may be virtually any type of Component. Toolbar elements can be created explicitly via their constructors, or implicitly via their xtypes, and can be <tt>{@link #add}</tt>ed dynamically.</p><p>Some items have shortcut strings for creation:</p><pre><u>Shortcut</u>  <u>xtype</u>          <u>Class</u>                  <u>Description</u>
'-&gt;'      'tbfill'       {@link Ext.Toolbar.Fill}       begin using the right-justified button container
'-'       'tbseparator'  {@link Ext.Toolbar.Separator}  add a vertical separator bar between toolbar items
' '       'tbspacer'     {@link Ext.Toolbar.Spacer}     add horiztonal space between elements
</pre>Example usage of various elements: <pre><code>var tb = new Ext.Toolbar({
renderTo: document.body,
width: 600,
height: 100,
items: [
{
// xtype: 'button', // default for Toolbars, same as 'tbbutton'
text: 'Button'
},
{
xtype: 'splitbutton', // same as 'tbsplitbutton'
text: 'Split Button'
},
// begin using the right-justified button container
'-&gt;', // same as {xtype: 'tbfill'}, // Ext.Toolbar.Fill
{
xtype: 'textfield',
name: 'field1',
emptyText: 'enter search term'
},
// add a vertical separator bar between toolbar items
'-', // same as {xtype: 'tbseparator'} to create Ext.Toolbar.Separator
'text 1', // same as {xtype: 'tbtext', text: 'text1'} to create Ext.Toolbar.TextItem
{xtype: 'tbspacer'},// same as ' ' to create Ext.Toolbar.Spacer
'text 2',
{xtype: 'tbspacer', width: 50}, // add a 50px space
'text 3'
]
});
</code></pre>Example adding a ComboBox within a menu of a button: <pre><code>// ComboBox creation
var combo = new Ext.form.ComboBox({
store: new Ext.data.ArrayStore({
autoDestroy: true,
fields: ['initials', 'fullname'],
data : [
['FF', 'Fred Flintstone'],
['BR', 'Barney Rubble']
]
}),
displayField: 'fullname',
typeAhead: true,
mode: 'local',
forceSelection: true,
triggerAction: 'all',
emptyText: 'Select a name...',
selectOnFocus: true,
width: 135,
getListParent: function() {
return this.el.up('.x-menu');
},
iconCls: 'no-icon' //use iconCls if placing within menu to shift to right side of menu
});

// put ComboBox in a Menu
var menu = new Ext.menu.Menu({
id: 'mainMenu',
items: [
combo // A Field in a Menu
]
});

// add a Button with the menu
tb.add({
text:'Button w/ Menu',
menu: menu  // assign menu by instance
});
tb.doLayout();
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.ToolTip'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Tip'>
        <xs:sequence>
            <xs:element name='target' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The target HTMLElement, Ext.Element or id to monitor for mouseover events to trigger showing this ToolTip.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='mouseOffset' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An XY offset from the mouse position where the tooltip should be shown (defaults to [15,18]).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='target'>
          <xs:annotation>
            <xs:documentation>
The target HTMLElement, Ext.Element or id to monitor for mouseover events to trigger showing this ToolTip.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoHide'>
          <xs:annotation>
            <xs:documentation>
True to automatically hide the tooltip after the mouse exits the target element or after the <code>{@link #dismissDelay}</code> has expired if set (defaults to true). If <code>{@link closable} = true</code> a close tool button will be rendered into the tooltip header.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='showDelay'>
          <xs:annotation>
            <xs:documentation>
Delay in milliseconds before the tooltip displays after the mouse enters the target element (defaults to 500)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='hideDelay'>
          <xs:annotation>
            <xs:documentation>
Delay in milliseconds after the mouse exits the target element but before the tooltip actually hides (defaults to 200). Set to 0 for the tooltip to hide immediately.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='dismissDelay'>
          <xs:annotation>
            <xs:documentation>
Delay in milliseconds before the tooltip automatically hides (defaults to 5000). To disable automatic hiding, set dismissDelay = 0.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='mouseOffset'>
          <xs:annotation>
            <xs:documentation>
An XY offset from the mouse position where the tooltip should be shown (defaults to [15,18]).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='trackMouse'>
          <xs:annotation>
            <xs:documentation>
True to have the tooltip follow the mouse as it moves over the target element (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='anchorToTarget'>
          <xs:annotation>
            <xs:documentation>
True to anchor the tooltip to the target element, false to anchor it relative to the mouse coordinates (defaults to true). When <code>anchorToTarget</code> is true, use <code>{@link #defaultAlign}</code> to control tooltip alignment to the target element. When <code>anchorToTarget</code> is false, use <code>{@link #anchorPosition}</code> instead to control alignment.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='anchorOffset'>
          <xs:annotation>
            <xs:documentation>
A numeric pixel value used to offset the default position of the anchor arrow (defaults to 0). When the anchor position is on the top or bottom of the tooltip, <code>anchorOffset</code> will be used as a horizontal offset. Likewise, when the anchor position is on the left or right side, <code>anchorOffset</code> will be used as a vertical offset.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='delegate'>
          <xs:annotation>
            <xs:documentation>
<p>Optional. A {@link Ext.DomQuery DomQuery} selector which allows selection of individual elements within the <code>{@link #target}</code> element to trigger showing and hiding the ToolTip as the mouse moves within the target.</p><p>When specified, the child element of the target which caused a show event is placed into the <code>{@link #triggerElement}</code> property before the ToolTip is shown.</p><p>This may be useful when a Component has regular, repeating elements in it, each of which need a Tooltip which contains information specific to that element. For example:</p><pre><code>var myGrid = new Ext.grid.gridPanel(gridConfig);
myGrid.on('render', function(grid) {
var store = grid.getStore();  // Capture the Store.
var view = grid.getView();    // Capture the GridView.
myGrid.tip = new Ext.ToolTip({
target: view.mainBody,    // The overall target element.
delegate: '.x-grid3-row', // Each grid row causes its own seperate show and hide.
trackMouse: true,         // Moving within the row should not hide the tip.
renderTo: document.body,  // Render immediately so that tip.body can be
//  referenced prior to the first show.
listeners: {              // Change content dynamically depending on which element
//  triggered the show.
beforeshow: function updateTipBody(tip) {
var rowIndex = view.findRowIndex(tip.triggerElement);
tip.body.dom.innerHTML = 'Over Record ID ' + store.getAt(rowIndex).id;
}
}
});
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='tooltip' name='tooltip' type='ext:ext.ToolTip' substitutionGroup='ext:tip'>
    <xs:annotation>
      <xs:documentation>
A standard tooltip implementation for providing additional information when hovering over a target element.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.tree.TreePanel'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:sequence>
            <xs:element name='root' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The root node for the tree.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='dragConfig' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Custom config to pass to the {@link Ext.tree.TreeDragZone} instance
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='dropConfig' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Custom config to pass to the {@link Ext.tree.TreeDropZone} instance
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='selModel' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A tree selection model to use with this TreePanel (defaults to an {@link Ext.tree.DefaultSelectionModel})
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='loader' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A {@link Ext.tree.TreeLoader} for use with this TreePanel
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='root'>
          <xs:annotation>
            <xs:documentation>
The root node for the tree.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='rootVisible'>
          <xs:annotation>
            <xs:documentation>
<tt>false</tt> to hide the root node (defaults to <tt>true</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='lines'>
          <xs:annotation>
            <xs:documentation>
<tt>false</tt> to disable tree lines (defaults to <tt>true</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableDD'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to enable drag and drop
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableDrag'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to enable just drag
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableDrop'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to enable just drop
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='dragConfig'>
          <xs:annotation>
            <xs:documentation>
Custom config to pass to the {@link Ext.tree.TreeDragZone} instance
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='dropConfig'>
          <xs:annotation>
            <xs:documentation>
Custom config to pass to the {@link Ext.tree.TreeDropZone} instance
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='ddGroup'>
          <xs:annotation>
            <xs:documentation>
The DD group this TreePanel belongs to
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='ddAppendOnly'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> if the tree should only allow append drops (use for trees which are sorted)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='ddScroll'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to enable body scrolling
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='containerScroll'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to register this container with ScrollManager
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hlDrop'>
          <xs:annotation>
            <xs:documentation>
<tt>false</tt> to disable node highlight on drop (defaults to the value of {@link Ext#enableFx})
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='hlColor'>
          <xs:annotation>
            <xs:documentation>
The color of the node highlight (defaults to <tt>'C3DAF9'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='animate'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to enable animated expand/collapse (defaults to the value of {@link Ext#enableFx})
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='singleExpand'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> if only 1 node per branch may be expanded
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='selModel'>
          <xs:annotation>
            <xs:documentation>
A tree selection model to use with this TreePanel (defaults to an {@link Ext.tree.DefaultSelectionModel})
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='trackMouseOver'>
          <xs:annotation>
            <xs:documentation>
<tt>false</tt> to disable mouse over highlighting
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='loader'>
          <xs:annotation>
            <xs:documentation>
A {@link Ext.tree.TreeLoader} for use with this TreePanel
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='pathSeparator'>
          <xs:annotation>
            <xs:documentation>
The token used to separate sub-paths in path strings (defaults to <tt>'/'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='useArrows'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to use Vista-style arrows in the tree (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='requestMethod'>
          <xs:annotation>
            <xs:documentation>
The HTTP request method for loading data (defaults to the value of {@link Ext.Ajax#method}).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='treepanel' name='treepanel' type='ext:ext.tree.TreePanel' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>
<p>The TreePanel provides tree-structured UI representation of tree-structured data.</p><p>{@link Ext.tree.TreeNode TreeNode}s added to the TreePanel may each contain metadata used by your application in their {@link Ext.tree.TreeNode#attributes attributes} property.</p><p><b>A TreePanel must have a {@link #root} node before it is rendered.</b> This may either be specified using the {@link #root} config option, or using the {@link #setRootNode} method.</p><p>An example of tree rendered to an existing div:</p><pre><code>var tree = new Ext.tree.TreePanel({
renderTo: 'tree-div',
useArrows: true,
autoScroll: true,
animate: true,
enableDD: true,
containerScroll: true,
border: false,
// auto create TreeLoader
dataUrl: 'get-nodes.php',

root: {
nodeType: 'async',
text: 'Ext JS',
draggable: false,
id: 'source'
}
});

tree.getRootNode().expand();
</code></pre><p>The example above would work with a data packet similar to this:</p><pre><code>[{
"text": "adapter",
"id": "source\/adapter",
"cls": "folder"
}, {
"text": "dd",
"id": "source\/dd",
"cls": "folder"
}, {
"text": "debug.js",
"id": "source\/debug.js",
"leaf": true,
"cls": "file"
}]
</code></pre><p>An example of tree within a Viewport:</p><pre><code>new Ext.Viewport({
layout: 'border',
items: [{
region: 'west',
collapsible: true,
title: 'Navigation',
xtype: 'treepanel',
width: 200,
autoScroll: true,
split: true,
loader: new Ext.tree.TreeLoader(),
root: new Ext.tree.AsyncTreeNode({
expanded: true,
children: [{
text: 'Menu Option 1',
leaf: true
}, {
text: 'Menu Option 2',
leaf: true
}, {
text: 'Menu Option 3',
leaf: true
}]
}),
rootVisible: false,
listeners: {
click: function(n) {
Ext.Msg.alert('Navigation Tree Click', 'You clicked: "' + n.attributes.text + '"');
}
}
}, {
region: 'center',
xtype: 'tabpanel',
// remaining code not shown ...
}]
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.TriggerField'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.TextField'>
        <xs:sequence>
            <xs:element name='triggerConfig' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A {@link Ext.DomHelper DomHelper} config object specifying the structure of the trigger element for this Field. (Optional).</p><p>Specify this when you need a customized element to act as the trigger button for a TriggerField.</p><p>Note that when using this option, it is the developer's responsibility to ensure correct sizing, positioning and appearance of the trigger. Defaults to:</p><pre><code>{tag: "img", src: Ext.BLANK_IMAGE_URL, cls: "x-form-trigger " + this.triggerClass}</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:string' name='triggerClass'>
          <xs:annotation>
            <xs:documentation>
An additional CSS class used to style the trigger button. The trigger will always get the class <tt>'x-form-trigger'</tt> by default and <tt>triggerClass</tt> will be <b>appended</b> if specified.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='triggerConfig'>
          <xs:annotation>
            <xs:documentation>
<p>A {@link Ext.DomHelper DomHelper} config object specifying the structure of the trigger element for this Field. (Optional).</p><p>Specify this when you need a customized element to act as the trigger button for a TriggerField.</p><p>Note that when using this option, it is the developer's responsibility to ensure correct sizing, positioning and appearance of the trigger. Defaults to:</p><pre><code>{tag: "img", src: Ext.BLANK_IMAGE_URL, cls: "x-form-trigger " + this.triggerClass}</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideTrigger'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to hide the trigger element and display only the base text field (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='editable'>
          <xs:annotation>
            <xs:documentation>
<tt>false</tt> to prevent the user from typing text directly into the field, the field will only respond to a click on the trigger to set the value. (defaults to <tt>true</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='wrapFocusClass'>
          <xs:annotation>
            <xs:documentation>
The class added to the to the wrap of the trigger element. Defaults to <tt>x-trigger-wrap-focus</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='trigger' name='trigger' type='ext:ext.form.TriggerField' substitutionGroup='ext:textfield'>
    <xs:annotation>
      <xs:documentation>
Provides a convenient wrapper for TextFields that adds a clickable trigger button (looks like a combobox by default). The trigger has no default action, so you must assign a function to implement the trigger click handler by overriding {@link #onTriggerClick}. You can create a TriggerField directly, as it renders exactly like a combobox for which you can provide a custom implementation. For example: <pre><code>var trigger = new Ext.form.TriggerField();
trigger.onTriggerClick = myTriggerFn;
trigger.applyToMarkup('my-field');
</code></pre>However, in general you will most likely want to use TriggerField as the base class for a reusable component. {@link Ext.form.DateField} and {@link Ext.form.ComboBox} are perfect examples of this.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Viewport'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Container'>
        <xs:sequence>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='deferHeight'>
          <xs:annotation>
            <xs:documentation>
@hide
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='viewport' name='viewport' type='ext:ext.Viewport' substitutionGroup='ext:container'>
    <xs:annotation>
      <xs:documentation>
<p>A specialized container representing the viewable application area (the browser viewport).</p><p>The Viewport renders itself to the document body, and automatically sizes itself to the size of the browser viewport and manages window resizing. There may only be one Viewport created in a page. Inner layouts are available by virtue of the fact that all {@link Ext.Panel Panel}s added to the Viewport, either through its {@link #items}, or through the items, or the {@link #add} method of any of its child Panels may themselves have a layout.</p><p>The Viewport does not provide scrolling, so child Panels within the Viewport should provide for scrolling if needed using the {@link #autoScroll} config.</p><p>An example showing a classic application border layout:</p><pre><code>new Ext.Viewport({
layout: 'border',
items: [{
region: 'north',
html: '&lt;h1 class="x-panel-header"&gt;Page Title&lt;/h1&gt;',
autoHeight: true,
border: false,
margins: '0 0 5 0'
}, {
region: 'west',
collapsible: true,
title: 'Navigation',
width: 200
// the west region might typically utilize a {@link Ext.tree.TreePanel TreePanel} or a Panel with {@link Ext.layout.AccordionLayout Accordion layout} 
}, {
region: 'south',
title: 'Title for Panel',
collapsible: true,
html: 'Information goes here',
split: true,
height: 100,
minHeight: 100
}, {
region: 'east',
title: 'Title for the Grid Panel',
collapsible: true,
split: true,
width: 200,
xtype: 'grid',
// remaining grid configuration not shown ...
// notice that the GridPanel is added directly as the region
// it is not "overnested" inside another Panel
}, {
region: 'center',
xtype: 'tabpanel', // TabPanel itself has no title
items: {
title: 'Default Tab',
html: 'The first tab\'s content. Others may be added dynamically'
}
}]
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Window'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:sequence>
            <xs:element name='animateTarget' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Id or element from which the window should animate while opening (defaults to null with no animation).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='manager' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A reference to the WindowGroup that should manage this window (defaults to {@link Ext.WindowMgr}).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='defaultButton' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The id / index of a button or a button instance to focus when this window received the focus.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='onEsc' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Allows override of the built-in processing for the escape key. Default action is to close the Window (performing whatever action is specified in {@link #closeAction}. To prevent the Window closing when the escape key is pressed, specify this as Ext.emptyFn (See {@link Ext#emptyFn}).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute type='xs:boolean' name='modal'>
          <xs:annotation>
            <xs:documentation>
True to make the window modal and mask everything behind it when displayed, false to display it without restricting access to other UI elements (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='animateTarget'>
          <xs:annotation>
            <xs:documentation>
Id or element from which the window should animate while opening (defaults to null with no animation).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='resizeHandles'>
          <xs:annotation>
            <xs:documentation>
A valid {@link Ext.Resizable} handles config string (defaults to 'all'). Only applies when resizable = true.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='manager'>
          <xs:annotation>
            <xs:documentation>
A reference to the WindowGroup that should manage this window (defaults to {@link Ext.WindowMgr}).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultButton'>
          <xs:annotation>
            <xs:documentation>
The id / index of a button or a button instance to focus when this window received the focus.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='onEsc'>
          <xs:annotation>
            <xs:documentation>
Allows override of the built-in processing for the escape key. Default action is to close the Window (performing whatever action is specified in {@link #closeAction}. To prevent the Window closing when the escape key is pressed, specify this as Ext.emptyFn (See {@link Ext#emptyFn}).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='maximized'>
          <xs:annotation>
            <xs:documentation>
True to initially display the window in a maximized state. (Defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='resizable'>
          <xs:annotation>
            <xs:documentation>
True to allow user resizing at each edge and corner of the window, false to disable resizing (defaults to true).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='closeAction'>
          <xs:annotation>
            <xs:documentation>
<p>The action to take when the close header tool is clicked:</p><div class="mdetail-params"><ul><li><b><code>'{@link #close}'</code></b> : <b>Default</b><div class="sub-desc">{@link #close remove} the window from the DOM and {@link Ext.Component#destroy destroy} it and all descendant Components. The window will <b>not</b> be available to be redisplayed via the {@link #show} method.</div></li><li><b><code>'{@link #hide}'</code></b> : <div class="sub-desc">{@link #hide} the window by setting visibility to hidden and applying negative offsets. The window will be available to be redisplayed via the {@link #show} method.</div></li></ul></div><p><b>Note:</b> This setting does not affect the {@link #close} method which will always {@link Ext.Component#destroy destroy} the window. To programatically <i>hide</i> a window, call {@link #hide}.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='constrain'>
          <xs:annotation>
            <xs:documentation>
True to constrain the window within its containing element, false to allow it to fall outside of its containing element. By default the window will be rendered to document.body. To render and constrain the window within another element specify {@link #renderTo}. (defaults to false). Optionally the header only can be constrained using {@link #constrainHeader}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='constrainHeader'>
          <xs:annotation>
            <xs:documentation>
True to constrain the window header within its containing element (allowing the window body to fall outside of its containing element) or false to allow the header to fall outside its containing element (defaults to false). Optionally the entire window can be constrained using {@link #constrain}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='plain'>
          <xs:annotation>
            <xs:documentation>
True to render the window body with a transparent background so that it will blend into the framing elements, false to add a lighter background color to visually highlight the body element and separate it more distinctly from the surrounding frame (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='minimizable'>
          <xs:annotation>
            <xs:documentation>
True to display the 'minimize' tool button and allow the user to minimize the window, false to hide the button and disallow minimizing the window (defaults to false). Note that this button provides no implementation -- the behavior of minimizing a window is implementation-specific, so the minimize event must be handled and a custom minimize behavior implemented for this option to be useful.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='maximizable'>
          <xs:annotation>
            <xs:documentation>
True to display the 'maximize' tool button and allow the user to maximize the window, false to hide the button and disallow maximizing the window (defaults to false). Note that when a window is maximized, the tool button will automatically change to a 'restore' button with the appropriate behavior already built-in that will restore the window to its previous size.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minHeight'>
          <xs:annotation>
            <xs:documentation>
The minimum height in pixels allowed for this window (defaults to 100). Only applies when resizable = true.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width in pixels allowed for this window (defaults to 200). Only applies when resizable = true.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='expandOnShow'>
          <xs:annotation>
            <xs:documentation>
True to always expand the window when it is displayed, false to keep it in its current state (which may be {@link #collapsed}) when displayed (defaults to true).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='initHidden'>
          <xs:annotation>
            <xs:documentation>
True to hide the window until show() is explicitly called (defaults to true). @deprecated
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='window' name='window' type='ext:ext.Window' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>
<p>A specialized panel intended for use as an application window. Windows are floated, {@link #resizable}, and {@link #draggable} by default. Windows can be {@link #maximizable maximized} to fill the viewport, restored to their prior size, and can be {@link #minimize}d.</p><p>Windows can also be linked to a {@link Ext.WindowGroup} or managed by the {@link Ext.WindowMgr} to provide grouping, activation, to front, to back and other application-specific behavior.</p><p>By default, Windows will be rendered to document.body. To {@link #constrain} a Window to another element specify {@link Ext.Component#renderTo renderTo}.</p><p><b>Note:</b> By default, the <code>{@link #closable close}</code> header tool <i>destroys</i> the Window resulting in destruction of any child Components. This makes the Window object, and all its descendants <b>unusable</b>. To enable re-use of a Window, use <b><code>{@link #closeAction closeAction: 'hide'}</code></b>.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.data.XmlStore'>
    <xs:complexContent>
      <xs:extension base='ext:ext.data.Store'>
        <xs:sequence>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element id='xmlstore' name='xmlstore' type='ext:ext.data.XmlStore' substitutionGroup='ext:store'>
    <xs:annotation>
      <xs:documentation>
<p>Small helper class to make creating {@link Ext.data.Store}s from XML data easier. A XmlStore will be automatically configured with a {@link Ext.data.XmlReader}.</p><p>A store configuration would be something like:</p><pre><code>var store = new Ext.data.XmlStore({
// store configs
autoDestroy: true,
storeId: 'myStore',
url: 'sheldon.xml', // automatically configures a HttpProxy
// reader configs
record: 'Item', // records will have an "Item" tag
idPath: 'ASIN',
totalRecords: '@TotalResults'
fields: [
// set up the fields mapping into the xml doc
// The first needs mapping, the others are very basic
{name: 'Author', mapping: 'ItemAttributes &gt; Author'},
'Title', 'Manufacturer', 'ProductGroup'
]
});
</code></pre><br/><br/> <p>This store is configured to consume a returned object of the form:</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ItemSearchResponse xmlns="http://webservices.amazon.com/AWSECommerceService/2009-05-15"&gt;
&lt;Items&gt;
&lt;Request&gt;
&lt;IsValid&gt;True&lt;/IsValid&gt;
&lt;ItemSearchRequest&gt;
&lt;Author&gt;Sidney Sheldon&lt;/Author&gt;
&lt;SearchIndex&gt;Books&lt;/SearchIndex&gt;
&lt;/ItemSearchRequest&gt;
&lt;/Request&gt;
&lt;TotalResults&gt;203&lt;/TotalResults&gt;
&lt;TotalPages&gt;21&lt;/TotalPages&gt;
&lt;Item&gt;
&lt;ASIN&gt;0446355453&lt;/ASIN&gt;
&lt;DetailPageURL&gt;
http://www.amazon.com/
&lt;/DetailPageURL&gt;
&lt;ItemAttributes&gt;
&lt;Author&gt;Sidney Sheldon&lt;/Author&gt;
&lt;Manufacturer&gt;Warner Books&lt;/Manufacturer&gt;
&lt;ProductGroup&gt;Book&lt;/ProductGroup&gt;
&lt;Title&gt;Master of the Game&lt;/Title&gt;
&lt;/ItemAttributes&gt;
&lt;/Item&gt;
&lt;/Items&gt;
&lt;/ItemSearchResponse&gt;
</code></pre>An object literal of this form could also be used as the {@link #data} config option.<br/><br/> <p><b>Note:</b> Although not listed here, this class accepts all of the configuration options of <b>{@link Ext.data.XmlReader XmlReader}</b>.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
</xs:schema>
